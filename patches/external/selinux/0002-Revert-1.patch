From 7c0717ca631d1662954cd5518268f22da25285f9 Mon Sep 17 00:00:00 2001
From: Shilin Victor <chrono.monochrome@gmail.com>
Date: Thu, 21 Sep 2017 21:57:03 +0300
Subject: [PATCH 2/2] Revert "1"

This reverts commit d1490cd701c557b40d14e67b17d066647a7a1075.

Change-Id: I45cdc628366e3d55b85cb55b9c58c16916b9b4e1
---
 libselinux/Android.bp                            |    2 -
 libselinux/Android.mk                            |    2 +-
 libselinux/src/android/android.c                 | 1443 +++++++++++++++++++++-
 libselinux/src/avc.c                             |  754 ++++++++++-
 libselinux/src/avc_internal.c                    |  205 ++-
 libselinux/src/avc_sidtab.c                      |  116 +-
 libselinux/src/booleans.c                        |  499 +++++++-
 libselinux/src/callbacks.c                       |   51 +-
 libselinux/src/canonicalize_context.c            |   64 +-
 libselinux/src/checkAccess.c                     |   79 +-
 libselinux/src/check_context.c                   |   29 +-
 libselinux/src/compute_av.c                      |  111 +-
 libselinux/src/compute_create.c                  |  113 +-
 libselinux/src/compute_member.c                  |   70 +-
 libselinux/src/compute_relabel.c                 |   67 +-
 libselinux/src/compute_user.c                    |   88 +-
 libselinux/src/context.c                         |  122 +-
 libselinux/src/deny_unknown.c                    |   25 +-
 libselinux/src/disable.c                         |   21 +
 libselinux/src/enabled.c                         |   34 +-
 libselinux/src/fgetfilecon.c                     |   56 +-
 libselinux/src/freecon.c                         |    1 +
 libselinux/src/freeconary.c                      |    9 +
 libselinux/src/fsetfilecon.c                     |   27 +-
 libselinux/src/get_context_list.c                |  451 ++++++-
 libselinux/src/get_default_type.c                |   53 +
 libselinux/src/get_initial_context.c             |   50 +-
 libselinux/src/getenforce.c                      |   25 +-
 libselinux/src/getfilecon.c                      |   55 +-
 libselinux/src/getpeercon.c                      |   41 +-
 libselinux/src/init.c                            |  101 +-
 libselinux/src/is_customizable_type.c            |   71 ++
 libselinux/src/label.c                           |  117 +-
 libselinux/src/label_backends_android.c          |   38 +-
 libselinux/src/label_db.c                        |    7 +-
 libselinux/src/label_file.c                      |   17 +-
 libselinux/src/label_media.c                     |   14 +-
 libselinux/src/label_support.c                   |  103 +-
 libselinux/src/label_x.c                         |   14 +-
 libselinux/src/lgetfilecon.c                     |   55 +-
 libselinux/src/load_policy.c                     |  419 ++++++-
 libselinux/src/lsetfilecon.c                     |   27 +-
 libselinux/src/mapping.c                         |  147 ++-
 libselinux/src/matchmediacon.c                   |   52 +-
 libselinux/src/matchpathcon.c                    |  332 ++++-
 libselinux/src/policyvers.c                      |   29 +-
 libselinux/src/procattr.c                        |  237 +++-
 libselinux/src/query_user_context.c              |  122 +-
 libselinux/src/regex.c                           |  360 +++++-
 libselinux/src/selinux_check_securetty_context.c |   41 +-
 libselinux/src/selinux_config.c                  |  163 ++-
 libselinux/src/selinux_restorecon.c              |  478 ++++++-
 libselinux/src/sestatus.c                        |  188 ++-
 libselinux/src/setenforce.c                      |   22 +-
 libselinux/src/setexecfilecon.c                  |   56 +-
 libselinux/src/setfilecon.c                      |   27 +-
 libselinux/src/setrans_client.c                  |  129 +-
 libselinux/src/seusers.c                         |  156 ++-
 libselinux/src/sha1.c                            |   54 +
 libselinux/src/stringrep.c                       |  155 ++-
 60 files changed, 8145 insertions(+), 249 deletions(-)

diff --git a/libselinux/Android.bp b/libselinux/Android.bp
index c1d0ae5..94395cb 100644
--- a/libselinux/Android.bp
+++ b/libselinux/Android.bp
@@ -1,7 +1,5 @@
 common_LIBRARIES = ["libpcre2"]
 common_CFLAGS = [
-    "-Wno-unused-function",
-    "-Wno-unused-parameter",
     "-DUSE_PCRE2",
 
     // Persistently stored patterns (pcre2) are architecture dependent.
diff --git a/libselinux/Android.mk b/libselinux/Android.mk
index 0fe42ab..92697f4 100644
--- a/libselinux/Android.mk
+++ b/libselinux/Android.mk
@@ -9,7 +9,7 @@ include $(CLEAR_VARS)
 
 LOCAL_MODULE := sefcontext_compile
 LOCAL_MODULE_TAGS := optional
-LOCAL_CFLAGS := -Wall -DUSE_PCRE2 -DNO_PERSISTENTLY_STORED_PATTERNS
+LOCAL_CFLAGS := -Wall -Werror -DUSE_PCRE2 -DNO_PERSISTENTLY_STORED_PATTERNS
 LOCAL_SRC_FILES := utils/sefcontext_compile.c
 LOCAL_STATIC_LIBRARIES := libsepol libselinux
 LOCAL_WHOLE_STATIC_LIBRARIES := libpcre2
diff --git a/libselinux/src/android/android.c b/libselinux/src/android/android.c
index 9f2704e..d93b4e8 100644
--- a/libselinux/src/android/android.c
+++ b/libselinux/src/android/android.c
@@ -129,6 +129,9 @@ struct prefix_str {
 
 static void free_prefix_str(struct prefix_str *p)
 {
+	if (!p)
+		return;
+	free(p->str);
 }
 
 struct seapp_context {
@@ -172,6 +175,126 @@ static bool seapp_contexts_dup = false;
 
 static int seapp_context_cmp(const void *A, const void *B)
 {
+	const struct seapp_context *const *sp1 = (const struct seapp_context *const *) A;
+	const struct seapp_context *const *sp2 = (const struct seapp_context *const *) B;
+	const struct seapp_context *s1 = *sp1, *s2 = *sp2;
+	bool dup;
+
+	/* Give precedence to isSystemServer=true. */
+	if (s1->isSystemServer != s2->isSystemServer)
+		return (s1->isSystemServer ? -1 : 1);
+
+	/* Give precedence to a specified isEphemeral= over an
+	 * unspecified isEphemeral=. */
+	if (s1->isEphemeralAppSet != s2->isEphemeralAppSet)
+		return (s1->isEphemeralAppSet ? -1 : 1);
+
+	/* Give precedence to a specified isV2= over an
+	 * unspecified isV2=. */
+	if (s1->isV2AppSet != s2->isV2AppSet)
+		return (s1->isV2AppSet ? -1 : 1);
+
+
+	/* Give precedence to a specified isOwner= over an unspecified isOwner=. */
+	if (s1->isOwnerSet != s2->isOwnerSet)
+		return (s1->isOwnerSet ? -1 : 1);
+
+	/* Give precedence to a specified user= over an unspecified user=. */
+	if (s1->user.str && !s2->user.str)
+		return -1;
+	if (!s1->user.str && s2->user.str)
+		return 1;
+
+	if (s1->user.str) {
+		/* Give precedence to a fixed user= string over a prefix. */
+		if (s1->user.is_prefix != s2->user.is_prefix)
+			return (s2->user.is_prefix ? -1 : 1);
+
+		/* Give precedence to a longer prefix over a shorter prefix. */
+		if (s1->user.is_prefix && s1->user.len != s2->user.len)
+			return (s1->user.len > s2->user.len) ? -1 : 1;
+	}
+
+	/* Give precedence to a specified seinfo= over an unspecified seinfo=. */
+	if (s1->seinfo && !s2->seinfo)
+		return -1;
+	if (!s1->seinfo && s2->seinfo)
+		return 1;
+
+	/* Give precedence to a specified name= over an unspecified name=. */
+	if (s1->name.str && !s2->name.str)
+		return -1;
+	if (!s1->name.str && s2->name.str)
+		return 1;
+
+	if (s1->name.str) {
+		/* Give precedence to a fixed name= string over a prefix. */
+		if (s1->name.is_prefix != s2->name.is_prefix)
+			return (s2->name.is_prefix ? -1 : 1);
+
+		/* Give precedence to a longer prefix over a shorter prefix. */
+		if (s1->name.is_prefix && s1->name.len != s2->name.len)
+			return (s1->name.len > s2->name.len) ? -1 : 1;
+	}
+
+	/* Give precedence to a specified path= over an unspecified path=. */
+	if (s1->path.str && !s2->path.str)
+		return -1;
+	if (!s1->path.str && s2->path.str)
+		return 1;
+
+	if (s1->path.str) {
+		/* Give precedence to a fixed path= string over a prefix. */
+		if (s1->path.is_prefix != s2->path.is_prefix)
+			return (s2->path.is_prefix ? -1 : 1);
+
+		/* Give precedence to a longer prefix over a shorter prefix. */
+		if (s1->path.is_prefix && s1->path.len != s2->path.len)
+			return (s1->path.len > s2->path.len) ? -1 : 1;
+	}
+
+	/* Give precedence to a specified isPrivApp= over an unspecified isPrivApp=. */
+	if (s1->isPrivAppSet != s2->isPrivAppSet)
+		return (s1->isPrivAppSet ? -1 : 1);
+
+	/* Give precedence to a higher minTargetSdkVersion= over a lower minTargetSdkVersion=.
+	 * If unspecified, minTargetSdkVersion has a default value of 0.
+	 */
+	if (s1->minTargetSdkVersion > s2->minTargetSdkVersion)
+		return -1;
+	else if (s1->minTargetSdkVersion < s2->minTargetSdkVersion)
+		return 1;
+
+	/*
+	 * Check for a duplicated entry on the input selectors.
+	 * We already compared isSystemServer, isOwnerSet, and isOwner above.
+	 * We also have already checked that both entries specify the same
+	 * string fields, so if s1 has a non-NULL string, then so does s2.
+	 */
+	dup = (!s1->user.str || !strcmp(s1->user.str, s2->user.str)) &&
+		(!s1->seinfo || !strcmp(s1->seinfo, s2->seinfo)) &&
+		(!s1->name.str || !strcmp(s1->name.str, s2->name.str)) &&
+		(!s1->path.str || !strcmp(s1->path.str, s2->path.str)) &&
+		(s1->isPrivAppSet && s1->isPrivApp == s2->isPrivApp) &&
+		(s1->isOwnerSet && s1->isOwner == s2->isOwner) &&
+		(s1->isSystemServer && s1->isSystemServer == s2->isSystemServer) &&
+		(s1->isV2AppSet && s1->isV2App == s2->isV2App) &&
+		(s1->isEphemeralAppSet && s1->isEphemeralApp == s2->isEphemeralApp);
+
+	if (dup) {
+		seapp_contexts_dup = true;
+		selinux_log(SELINUX_ERROR, "seapp_contexts:  Duplicated entry\n");
+		if (s1->user.str)
+			selinux_log(SELINUX_ERROR, " user=%s\n", s1->user.str);
+		if (s1->seinfo)
+			selinux_log(SELINUX_ERROR, " seinfo=%s\n", s1->seinfo);
+		if (s1->name.str)
+			selinux_log(SELINUX_ERROR, " name=%s\n", s1->name.str);
+		if (s1->path.str)
+			selinux_log(SELINUX_ERROR, " path=%s\n", s1->path.str);
+	}
+
+	/* Anything else has equal precedence. */
 	return 0;
 }
 
@@ -180,21 +303,365 @@ static int nspec = 0;
 
 static void free_seapp_contexts(void)
 {
+	int n;
+
+	if (!seapp_contexts)
+		return;
+
+	for (n = 0; n < nspec; n++)
+		free_seapp_context(seapp_contexts[n]);
+
+	free(seapp_contexts);
+	seapp_contexts = NULL;
+	nspec = 0;
 }
 
 static int32_t get_minTargetSdkVersion(const char *value)
 {
-	return 0;
+	char *endptr;
+	long minTargetSdkVersion;
+	minTargetSdkVersion = strtol(value, &endptr, 10);
+	if (('\0' != *endptr) || (minTargetSdkVersion < 0) || (minTargetSdkVersion > INT32_MAX)) {
+		return -1; /* error parsing minTargetSdkVersion */
+	} else {
+		return (int32_t) minTargetSdkVersion;
+	}
 }
 
 int selinux_android_seapp_context_reload(void)
 {
-	return 0;
+	FILE *fp = NULL;
+	char line_buf[BUFSIZ];
+	char *token;
+	unsigned lineno;
+	struct seapp_context *cur;
+	char *p, *name = NULL, *value = NULL, *saveptr;
+	size_t i, len, files_len;
+	int n, ret;
+	const char *const *seapp_contexts_files;
+
+	// Prefer files from /system & /vendor, fall back to files from /
+	if (access(seapp_contexts_split[0], R_OK) != -1) {
+		seapp_contexts_files = seapp_contexts_split;
+		files_len = sizeof(seapp_contexts_split)/sizeof(seapp_contexts_split[0]);
+	} else {
+		seapp_contexts_files = seapp_contexts_rootfs;
+		files_len = sizeof(seapp_contexts_rootfs)/sizeof(seapp_contexts_rootfs[0]);
+	}
+
+	free_seapp_contexts();
+
+	nspec = 0;
+	for (i = 0; i < files_len; i++) {
+		fp = fopen(seapp_contexts_files[i], "re");
+		if (!fp) {
+			selinux_log(SELINUX_ERROR, "%s:  could not open seapp_contexts file: %s",
+				    __FUNCTION__, seapp_contexts_files[i]);
+			return -1;
+		}
+		while (fgets(line_buf, sizeof line_buf - 1, fp)) {
+			p = line_buf;
+			while (isspace(*p))
+				p++;
+			if (*p == '#' || *p == 0)
+				continue;
+			nspec++;
+		}
+		fclose(fp);
+	}
+
+	seapp_contexts = (struct seapp_context **) calloc(nspec, sizeof(struct seapp_context *));
+	if (!seapp_contexts)
+		goto oom;
+
+	nspec = 0;
+	for (i = 0; i < files_len; i++) {
+		lineno = 1;
+		fp = fopen(seapp_contexts_files[i], "re");
+		if (!fp) {
+			selinux_log(SELINUX_ERROR, "%s:  could not open seapp_contexts file: %s",
+				    __FUNCTION__, seapp_contexts_files[i]);
+			free_seapp_contexts();
+			return -1;
+		}
+		while (fgets(line_buf, sizeof line_buf - 1, fp)) {
+			len = strlen(line_buf);
+			if (line_buf[len - 1] == '\n')
+				line_buf[len - 1] = 0;
+			p = line_buf;
+			while (isspace(*p))
+				p++;
+			if (*p == '#' || *p == 0)
+				continue;
+
+			cur = (struct seapp_context *) calloc(1, sizeof(struct seapp_context));
+			if (!cur)
+				goto oom;
+
+			token = strtok_r(p, " \t", &saveptr);
+			if (!token) {
+				free_seapp_context(cur);
+				goto err;
+			}
+
+			while (1) {
+				name = token;
+				value = strchr(name, '=');
+				if (!value) {
+					free_seapp_context(cur);
+					goto err;
+				}
+				*value++ = 0;
+
+				if (!strcasecmp(name, "isSystemServer")) {
+					if (!strcasecmp(value, "true"))
+						cur->isSystemServer = true;
+					else if (!strcasecmp(value, "false"))
+						cur->isSystemServer = false;
+					else {
+						free_seapp_context(cur);
+						goto err;
+					}
+				} else if (!strcasecmp(name, "isEphemeralApp")) {
+					cur->isEphemeralAppSet = true;
+					if (!strcasecmp(value, "true"))
+						cur->isEphemeralApp = true;
+					else if (!strcasecmp(value, "false"))
+						cur->isEphemeralApp = false;
+					else {
+						free_seapp_context(cur);
+						goto err;
+					}
+				} else if (!strcasecmp(name, "isV2App")) {
+					cur->isV2AppSet = true;
+					if (!strcasecmp(value, "true"))
+						cur->isV2App = true;
+					else if (!strcasecmp(value, "false"))
+						cur->isV2App = false;
+					else {
+						free_seapp_context(cur);
+						goto err;
+					}
+				} else if (!strcasecmp(name, "isOwner")) {
+					cur->isOwnerSet = true;
+					if (!strcasecmp(value, "true"))
+						cur->isOwner = true;
+					else if (!strcasecmp(value, "false"))
+						cur->isOwner = false;
+					else {
+						free_seapp_context(cur);
+						goto err;
+					}
+				} else if (!strcasecmp(name, "user")) {
+					if (cur->user.str) {
+						free_seapp_context(cur);
+						goto err;
+					}
+					cur->user.str = strdup(value);
+					if (!cur->user.str) {
+						free_seapp_context(cur);
+						goto oom;
+					}
+					cur->user.len = strlen(cur->user.str);
+					if (cur->user.str[cur->user.len-1] == '*')
+						cur->user.is_prefix = 1;
+				} else if (!strcasecmp(name, "seinfo")) {
+					if (cur->seinfo) {
+						free_seapp_context(cur);
+						goto err;
+					}
+					cur->seinfo = strdup(value);
+					if (!cur->seinfo) {
+						free_seapp_context(cur);
+						goto oom;
+					}
+					if (strstr(value, ":")) {
+						free_seapp_context(cur);
+						goto err;
+					}
+				} else if (!strcasecmp(name, "name")) {
+					if (cur->name.str) {
+						free_seapp_context(cur);
+						goto err;
+					}
+					cur->name.str = strdup(value);
+					if (!cur->name.str) {
+						free_seapp_context(cur);
+						goto oom;
+					}
+					cur->name.len = strlen(cur->name.str);
+					if (cur->name.str[cur->name.len-1] == '*')
+						cur->name.is_prefix = 1;
+				} else if (!strcasecmp(name, "domain")) {
+					if (cur->domain) {
+						free_seapp_context(cur);
+						goto err;
+					}
+					cur->domain = strdup(value);
+					if (!cur->domain) {
+						free_seapp_context(cur);
+						goto oom;
+					}
+				} else if (!strcasecmp(name, "type")) {
+					if (cur->type) {
+						free_seapp_context(cur);
+						goto err;
+					}
+					cur->type = strdup(value);
+					if (!cur->type) {
+						free_seapp_context(cur);
+						goto oom;
+					}
+				} else if (!strcasecmp(name, "levelFromUid")) {
+					if (cur->levelFrom) {
+						free_seapp_context(cur);
+						goto err;
+					}
+					if (!strcasecmp(value, "true"))
+						cur->levelFrom = LEVELFROM_APP;
+					else if (!strcasecmp(value, "false"))
+						cur->levelFrom = LEVELFROM_NONE;
+					else {
+						free_seapp_context(cur);
+						goto err;
+					}
+				} else if (!strcasecmp(name, "levelFrom")) {
+					if (cur->levelFrom) {
+						free_seapp_context(cur);
+						goto err;
+					}
+					if (!strcasecmp(value, "none"))
+						cur->levelFrom = LEVELFROM_NONE;
+					else if (!strcasecmp(value, "app"))
+						cur->levelFrom = LEVELFROM_APP;
+					else if (!strcasecmp(value, "user"))
+						cur->levelFrom = LEVELFROM_USER;
+					else if (!strcasecmp(value, "all"))
+						cur->levelFrom = LEVELFROM_ALL;
+					else {
+						free_seapp_context(cur);
+						goto err;
+					}
+				} else if (!strcasecmp(name, "level")) {
+					if (cur->level) {
+						free_seapp_context(cur);
+						goto err;
+					}
+					cur->level = strdup(value);
+					if (!cur->level) {
+						free_seapp_context(cur);
+						goto oom;
+					}
+				} else if (!strcasecmp(name, "path")) {
+					if (cur->path.str) {
+						free_seapp_context(cur);
+						goto err;
+					}
+					cur->path.str = strdup(value);
+					if (!cur->path.str) {
+						free_seapp_context(cur);
+					goto oom;
+					}
+					cur->path.len = strlen(cur->path.str);
+					if (cur->path.str[cur->path.len-1] == '*')
+						cur->path.is_prefix = 1;
+				} else if (!strcasecmp(name, "isPrivApp")) {
+					cur->isPrivAppSet = true;
+					if (!strcasecmp(value, "true"))
+						cur->isPrivApp = true;
+					else if (!strcasecmp(value, "false"))
+						cur->isPrivApp = false;
+					else {
+						free_seapp_context(cur);
+						goto err;
+					}
+				} else if (!strcasecmp(name, "minTargetSdkVersion")) {
+					cur->minTargetSdkVersion = get_minTargetSdkVersion(value);
+					if (cur->minTargetSdkVersion < 0) {
+						free_seapp_context(cur);
+						goto err;
+					}
+				} else {
+					free_seapp_context(cur);
+					goto err;
+				}
+
+				token = strtok_r(NULL, " \t", &saveptr);
+				if (!token)
+					break;
+			}
+
+			if (cur->name.str &&
+			    (!cur->seinfo || !strcmp(cur->seinfo, "default"))) {
+				selinux_log(SELINUX_ERROR, "%s:  No specific seinfo value specified with name=\"%s\", on line %u:  insecure configuration!\n",
+					    seapp_contexts_files[i], cur->name.str, lineno);
+				free_seapp_context(cur);
+				goto err;
+			}
+
+			seapp_contexts[nspec] = cur;
+			nspec++;
+			lineno++;
+		}
+		fclose(fp);
+		fp = NULL;
+	}
+
+	qsort(seapp_contexts, nspec, sizeof(struct seapp_context *),
+	      seapp_context_cmp);
+
+	if (seapp_contexts_dup)
+		goto err_no_log;
+
+#if DEBUG
+	{
+		int i;
+		for (i = 0; i < nspec; i++) {
+			cur = seapp_contexts[i];
+			selinux_log(SELINUX_INFO, "%s:  isSystemServer=%s  isEphemeralApp=%s isV2App=%s isOwner=%s user=%s seinfo=%s "
+					"name=%s path=%s isPrivApp=%s minTargetSdkVersion=%d -> domain=%s type=%s level=%s levelFrom=%s",
+				__FUNCTION__,
+				cur->isSystemServer ? "true" : "false",
+				cur->isEphemeralAppSet ? (cur->isEphemeralApp ? "true" : "false") : "null",
+				cur->isV2AppSet ? (cur->isV2App ? "true" : "false") : "null",
+				cur->isOwnerSet ? (cur->isOwner ? "true" : "false") : "null",
+				cur->user.str,
+				cur->seinfo, cur->name.str, cur->path.str,
+				cur->isPrivAppSet ? (cur->isPrivApp ? "true" : "false") : "null",
+				cur->minTargetSdkVersion,
+				cur->domain, cur->type, cur->level,
+				levelFromName[cur->levelFrom]);
+		}
+	}
+#endif
+
+	ret = 0;
+
+out:
+	if (fp) {
+		fclose(fp);
+	}
+	return ret;
+
+err:
+	selinux_log(SELINUX_ERROR, "%s:  Invalid entry on line %u\n",
+		    seapp_contexts_files[i], lineno);
+err_no_log:
+	free_seapp_contexts();
+	ret = -1;
+	goto out;
+oom:
+	selinux_log(SELINUX_ERROR,
+		    "%s:  Out of memory\n", __FUNCTION__);
+	free_seapp_contexts();
+	ret = -1;
+	goto out;
 }
 
 
 static void seapp_context_init(void)
 {
+        selinux_android_seapp_context_reload();
 }
 
 static pthread_once_t once = PTHREAD_ONCE_INIT;
@@ -216,11 +683,40 @@ enum seapp_kind {
 #define TARGETSDKVERSION_STR ":targetSdkVersion="
 static int32_t get_app_targetSdkVersion(const char *seinfo)
 {
+	char *substr = strstr(seinfo, TARGETSDKVERSION_STR);
+	long targetSdkVersion;
+	char *endptr;
+	if (substr != NULL) {
+		substr = substr + strlen(TARGETSDKVERSION_STR);
+		if (substr != NULL) {
+			targetSdkVersion = strtol(substr, &endptr, 10);
+			if (('\0' != *endptr && ':' != *endptr)
+					|| (targetSdkVersion < 0) || (targetSdkVersion > INT32_MAX)) {
+				return -1; /* malformed targetSdkVersion value in seinfo */
+			} else {
+				return (int32_t) targetSdkVersion;
+			}
+		}
+	}
 	return 0; /* default to 0 when targetSdkVersion= is not present in seinfo */
 }
 
 static int seinfo_parse(char *dest, const char *src, size_t size)
 {
+	size_t len;
+	char *p;
+
+	if ((p = strchr(src, ':')) != NULL)
+		len = p - src;
+	else
+		len = strlen(src);
+
+	if (len > size - 1)
+		return -1;
+
+	strncpy(dest, src, len);
+	dest[len] = '\0';
+
 	return 0;
 }
 
@@ -232,7 +728,192 @@ static int seapp_context_lookup(enum seapp_kind kind,
 				const char *path,
 				context_t ctx)
 {
+	struct passwd *pwd;
+	bool isOwner;
+	const char *username = NULL;
+	struct seapp_context *cur = NULL;
+	int i;
+	size_t n;
+	uid_t userid;
+	uid_t appid;
+	bool isPrivApp = false;
+	bool isEphemeralApp = false;
+	int32_t targetSdkVersion = 0;
+	bool isV2App = false;
+	char parsedseinfo[BUFSIZ];
+
+	__selinux_once(once, seapp_context_init);
+
+	if (seinfo) {
+		if (seinfo_parse(parsedseinfo, seinfo, BUFSIZ))
+			goto err;
+		isPrivApp = strstr(seinfo, PRIVILEGED_APP_STR) ? true : false;
+		isEphemeralApp = strstr(seinfo, EPHEMERAL_APP_STR) ? true : false;
+		isV2App = strstr(seinfo, V2_APP_STR) ? true : false;
+		targetSdkVersion = get_app_targetSdkVersion(seinfo);
+		if (targetSdkVersion < 0) {
+			selinux_log(SELINUX_ERROR,
+					"%s:  Invalid targetSdkVersion passed for app with uid %d, seinfo %s, name %s\n",
+					__FUNCTION__, uid, seinfo, pkgname);
+			goto err;
+		}
+		seinfo = parsedseinfo;
+	}
+
+	userid = uid / AID_USER;
+	isOwner = (userid == 0);
+	appid = uid % AID_USER;
+	if (appid < AID_APP) {
+            /*
+             * This code is Android specific, bionic guarantees that
+             * calls to non-reentrant getpwuid() are thread safe.
+             */
+#ifndef __BIONIC__
+#warning "This code assumes that getpwuid is thread safe, only true with Bionic!"
+#endif
+		pwd = getpwuid(appid);
+		if (!pwd)
+			goto err;
+
+		username = pwd->pw_name;
+
+	} else if (appid < AID_ISOLATED_START) {
+		username = "_app";
+		appid -= AID_APP;
+	} else {
+		username = "_isolated";
+		appid -= AID_ISOLATED_START;
+	}
+
+	if (appid >= CAT_MAPPING_MAX_ID || userid >= CAT_MAPPING_MAX_ID)
+		goto err;
+
+	for (i = 0; i < nspec; i++) {
+		cur = seapp_contexts[i];
+
+		if (cur->isSystemServer != isSystemServer)
+			continue;
+
+		if (cur->isEphemeralAppSet && cur->isEphemeralApp != isEphemeralApp)
+			continue;
+
+		if (cur->isV2AppSet && cur->isV2App != isV2App)
+			continue;
+
+		if (cur->isOwnerSet && cur->isOwner != isOwner)
+			continue;
+
+		if (cur->user.str) {
+			if (cur->user.is_prefix) {
+				if (strncasecmp(username, cur->user.str, cur->user.len-1))
+					continue;
+			} else {
+				if (strcasecmp(username, cur->user.str))
+					continue;
+			}
+		}
+
+		if (cur->seinfo) {
+			if (!seinfo || strcasecmp(seinfo, cur->seinfo))
+				continue;
+		}
+
+		if (cur->name.str) {
+			if(!pkgname)
+				continue;
+
+			if (cur->name.is_prefix) {
+				if (strncasecmp(pkgname, cur->name.str, cur->name.len-1))
+					continue;
+			} else {
+				if (strcasecmp(pkgname, cur->name.str))
+					continue;
+			}
+		}
+
+		if (cur->isPrivAppSet && cur->isPrivApp != isPrivApp)
+			continue;
+
+		if (cur->minTargetSdkVersion > targetSdkVersion)
+			continue;
+
+		if (cur->path.str) {
+			if (!path)
+				continue;
+
+			if (cur->path.is_prefix) {
+				if (strncmp(path, cur->path.str, cur->path.len-1))
+					continue;
+			} else {
+				if (strcmp(path, cur->path.str))
+					continue;
+			}
+		}
+
+		if (kind == SEAPP_TYPE && !cur->type)
+			continue;
+		else if (kind == SEAPP_DOMAIN && !cur->domain)
+			continue;
+
+		if (kind == SEAPP_TYPE) {
+			if (context_type_set(ctx, cur->type))
+				goto oom;
+		} else if (kind == SEAPP_DOMAIN) {
+			if (context_type_set(ctx, cur->domain))
+				goto oom;
+		}
+
+		if (cur->levelFrom != LEVELFROM_NONE) {
+			char level[255];
+			switch (cur->levelFrom) {
+			case LEVELFROM_APP:
+				snprintf(level, sizeof level, "s0:c%u,c%u",
+					 appid & 0xff,
+					 256 + (appid>>8 & 0xff));
+				break;
+			case LEVELFROM_USER:
+				snprintf(level, sizeof level, "s0:c%u,c%u",
+					 512 + (userid & 0xff),
+					 768 + (userid>>8 & 0xff));
+				break;
+			case LEVELFROM_ALL:
+				snprintf(level, sizeof level, "s0:c%u,c%u,c%u,c%u",
+					 appid & 0xff,
+					 256 + (appid>>8 & 0xff),
+					 512 + (userid & 0xff),
+					 768 + (userid>>8 & 0xff));
+				break;
+			default:
+				goto err;
+			}
+			if (context_range_set(ctx, level))
+				goto oom;
+		} else if (cur->level) {
+			if (context_range_set(ctx, cur->level))
+				goto oom;
+		}
+
+		break;
+	}
+
+	if (kind == SEAPP_DOMAIN && i == nspec) {
+		/*
+		 * No match.
+		 * Fail to prevent staying in the zygote's context.
+		 */
+		selinux_log(SELINUX_ERROR,
+			    "%s:  No match for app with uid %d, seinfo %s, name %s\n",
+			    __FUNCTION__, uid, seinfo, pkgname);
+
+		if (security_getenforce() == 1)
+			goto err;
+	}
+
 	return 0;
+err:
+	return -1;
+oom:
+	return -2;
 }
 
 int selinux_android_setfilecon(const char *pkgdir,
@@ -240,12 +921,70 @@ int selinux_android_setfilecon(const char *pkgdir,
 				const char *seinfo,
 				uid_t uid)
 {
-	return 0;
+	char *orig_ctx_str = NULL;
+	char *ctx_str = NULL;
+	context_t ctx = NULL;
+	int rc = -1;
+
+	if (is_selinux_enabled() <= 0)
+		return 0;
+
+	rc = getfilecon(pkgdir, &ctx_str);
+	if (rc < 0)
+		goto err;
+
+	ctx = context_new(ctx_str);
+	orig_ctx_str = ctx_str;
+	if (!ctx)
+		goto oom;
+
+	rc = seapp_context_lookup(SEAPP_TYPE, uid, 0, seinfo, pkgname, NULL, ctx);
+	if (rc == -1)
+		goto err;
+	else if (rc == -2)
+		goto oom;
+
+	ctx_str = context_str(ctx);
+	if (!ctx_str)
+		goto oom;
+
+	rc = security_check_context(ctx_str);
+	if (rc < 0)
+		goto err;
+
+	if (strcmp(ctx_str, orig_ctx_str)) {
+		rc = setfilecon(pkgdir, ctx_str);
+		if (rc < 0)
+			goto err;
+	}
+
+	rc = 0;
+out:
+	freecon(orig_ctx_str);
+	context_free(ctx);
+	return rc;
+err:
+	selinux_log(SELINUX_ERROR, "%s:  Error setting context for pkgdir %s, uid %d: %s\n",
+		    __FUNCTION__, pkgdir, uid, strerror(errno));
+	rc = -1;
+	goto out;
+oom:
+	selinux_log(SELINUX_ERROR, "%s:  Out of memory\n", __FUNCTION__);
+	rc = -1;
+	goto out;
 }
 
 int selinux_android_setcon(const char *con)
 {
-	return 0;
+	int ret = setcon(con);
+	if (ret)
+		return ret;
+	/*
+	  System properties must be reinitialized after setcon() otherwise the
+	  previous property files will be leaked since mmap()'ed regions are not
+	  closed as a result of setcon().
+	*/
+	return __system_properties_init();
 }
 
 int selinux_android_setcontext(uid_t uid,
@@ -253,7 +992,64 @@ int selinux_android_setcontext(uid_t uid,
 			       const char *seinfo,
 			       const char *pkgname)
 {
-	return 0;
+	char *orig_ctx_str = NULL, *ctx_str;
+	context_t ctx = NULL;
+	int rc = -1;
+
+	if (is_selinux_enabled() <= 0)
+		return 0;
+
+	rc = getcon(&ctx_str);
+	if (rc)
+		goto err;
+
+	ctx = context_new(ctx_str);
+	orig_ctx_str = ctx_str;
+	if (!ctx)
+		goto oom;
+
+	rc = seapp_context_lookup(SEAPP_DOMAIN, uid, isSystemServer, seinfo, pkgname, NULL, ctx);
+	if (rc == -1)
+		goto err;
+	else if (rc == -2)
+		goto oom;
+
+	ctx_str = context_str(ctx);
+	if (!ctx_str)
+		goto oom;
+
+	rc = security_check_context(ctx_str);
+	if (rc < 0)
+		goto err;
+
+	if (strcmp(ctx_str, orig_ctx_str)) {
+		rc = selinux_android_setcon(ctx_str);
+		if (rc < 0)
+			goto err;
+	}
+
+	rc = 0;
+out:
+	freecon(orig_ctx_str);
+	context_free(ctx);
+	avc_netlink_close();
+	return rc;
+err:
+	if (isSystemServer)
+		selinux_log(SELINUX_ERROR,
+				"%s:  Error setting context for system server: %s\n",
+				__FUNCTION__, strerror(errno));
+	else
+		selinux_log(SELINUX_ERROR,
+				"%s:  Error setting context for app with uid %d, seinfo %s: %s\n",
+				__FUNCTION__, uid, seinfo, strerror(errno));
+
+	rc = -1;
+	goto out;
+oom:
+	selinux_log(SELINUX_ERROR, "%s:  Out of memory\n", __FUNCTION__);
+	rc = -1;
+	goto out;
 }
 
 static struct selabel_handle *fc_sehandle = NULL;
@@ -262,11 +1058,69 @@ static uint8_t fc_digest[FC_DIGEST_SIZE];
 
 static bool compute_file_contexts_hash(uint8_t c_digest[], const struct selinux_opt *opts, unsigned nopts)
 {
-        return 0;
+    int fd = -1;
+    void *map = MAP_FAILED;
+    bool ret = false;
+    uint8_t *fc_data = NULL;
+    size_t total_size = 0;
+    struct stat sb;
+    size_t i;
+
+    for (i = 0; i < nopts; i++) {
+        fd = open(opts[i].value, O_CLOEXEC | O_RDONLY);
+        if (fd < 0) {
+            selinux_log(SELINUX_ERROR, "SELinux:  Could not open %s:  %s\n",
+                    opts[i].value, strerror(errno));
+            goto cleanup;
+        }
+
+        if (fstat(fd, &sb) < 0) {
+            selinux_log(SELINUX_ERROR, "SELinux:  Could not stat %s:  %s\n",
+                    opts[i].value, strerror(errno));
+            goto cleanup;
+        }
+
+        map = mmap(NULL, sb.st_size, PROT_READ, MAP_PRIVATE, fd, 0);
+        if (map == MAP_FAILED) {
+            selinux_log(SELINUX_ERROR, "SELinux:  Could not map %s:  %s\n",
+                    opts[i].value, strerror(errno));
+            goto cleanup;
+        }
+
+        fc_data = realloc(fc_data, total_size + sb.st_size);
+        if (!fc_data) {
+            selinux_log(SELINUX_ERROR, "SELinux: Count not re-alloc for %s:  %s\n",
+                     opts[i].value, strerror(errno));
+            goto cleanup;
+        }
+
+        memcpy(fc_data + total_size, map, sb.st_size);
+        total_size += sb.st_size;
+
+        /* reset everything for next file */
+        munmap(map, sb.st_size);
+        close(fd);
+        map = MAP_FAILED;
+        fd = -1;
+    }
+
+    SHA1(fc_data, total_size, c_digest);
+    ret = true;
+
+cleanup:
+    if (map != MAP_FAILED)
+        munmap(map, sb.st_size);
+    if (fd >= 0)
+        close(fd);
+    free(fc_data);
+
+    return ret;
 }
 
 static void file_context_init(void)
 {
+    if (!fc_sehandle)
+        fc_sehandle = selinux_android_file_context_handle();
 }
 
 
@@ -278,22 +1132,74 @@ static struct pkg_info *pkgTab[PKGTAB_SIZE];
 
 static unsigned int pkghash(const char *pkgname)
 {
-        return 0;
+    unsigned int h = 7;
+    for (; *pkgname; pkgname++) {
+        h = h * 31 + *pkgname;
+    }
+    return h & (PKGTAB_SIZE - 1);
 }
 
 static bool pkg_parse_callback(pkg_info *info, void *userdata) {
 
-        return 0;
+    (void) userdata;
+
+    unsigned int hash = pkghash(info->name);
+    if (pkgTab[hash])
+        info->private_data = pkgTab[hash];
+    pkgTab[hash] = info;
+    return true;
 }
 
 static void package_info_init(void)
 {
+
+    bool rc = packagelist_parse(pkg_parse_callback, NULL);
+    if (!rc) {
+        selinux_log(SELINUX_ERROR, "SELinux: Could NOT parse package list\n");
+        return;
+    }
+
+#if DEBUG
+    {
+        unsigned int hash, buckets, entries, chainlen, longestchain;
+        struct pkg_info *info = NULL;
+
+        buckets = entries = longestchain = 0;
+        for (hash = 0; hash < PKGTAB_SIZE; hash++) {
+            if (pkgTab[hash]) {
+                buckets++;
+                chainlen = 0;
+                for (info = pkgTab[hash]; info; info = (pkg_info *)info->private_data) {
+                    chainlen++;
+                    selinux_log(SELINUX_INFO, "%s:  name=%s uid=%u debuggable=%s dataDir=%s seinfo=%s\n",
+                                __FUNCTION__,
+                                info->name, info->uid, info->debuggable ? "true" : "false", info->data_dir, info->seinfo);
+                }
+                entries += chainlen;
+                if (longestchain < chainlen)
+                    longestchain = chainlen;
+            }
+        }
+        selinux_log(SELINUX_INFO, "SELinux:  %d pkg entries and %d/%d buckets used, longest chain %d\n", entries, buckets, PKGTAB_SIZE, longestchain);
+    }
+#endif
+
 }
 
 static pthread_once_t pkg_once = PTHREAD_ONCE_INIT;
 
 struct pkg_info *package_info_lookup(const char *name)
 {
+    struct pkg_info *info;
+    unsigned int hash;
+
+    __selinux_once(pkg_once, package_info_init);
+
+    hash = pkghash(name);
+    for (info = pkgTab[hash]; info; info = (pkg_info *)info->private_data) {
+        if (!strcmp(name, info->name))
+            return info;
+    }
     return NULL;
 }
 
@@ -319,7 +1225,110 @@ static int pkgdir_selabel_lookup(const char *pathname,
                                  uid_t uid,
                                  char **secontextp)
 {
+    char *pkgname = NULL, *end = NULL;
+    struct pkg_info *info = NULL;
+    char *secontext = *secontextp;
+    context_t ctx = NULL;
+    int rc = 0;
+
+    /* Skip directory prefix before package name. */
+    if (!strncmp(pathname, DATA_DATA_PREFIX, sizeof(DATA_DATA_PREFIX)-1)) {
+        pathname += sizeof(DATA_DATA_PREFIX) - 1;
+    } else if (!strncmp(pathname, DATA_USER_PREFIX, sizeof(DATA_USER_PREFIX)-1)) {
+        pathname += sizeof(DATA_USER_PREFIX) - 1;
+        while (isdigit(*pathname))
+            pathname++;
+        if (*pathname == '/')
+            pathname++;
+        else
+            return 0;
+    } else if (!strncmp(pathname, DATA_USER_DE_PREFIX, sizeof(DATA_USER_DE_PREFIX)-1)) {
+        pathname += sizeof(DATA_USER_DE_PREFIX) - 1;
+        while (isdigit(*pathname))
+            pathname++;
+        if (*pathname == '/')
+            pathname++;
+        else
+            return 0;
+    } else if (!fnmatch(EXPAND_USER_PATH, pathname, FNM_LEADING_DIR|FNM_PATHNAME)) {
+        pathname += sizeof(EXPAND_USER_PATH);
+        while (isdigit(*pathname))
+            pathname++;
+        if (*pathname == '/')
+            pathname++;
+        else
+            return 0;
+    } else if (!fnmatch(EXPAND_USER_DE_PATH, pathname, FNM_LEADING_DIR|FNM_PATHNAME)) {
+        pathname += sizeof(EXPAND_USER_DE_PATH);
+        while (isdigit(*pathname))
+            pathname++;
+        if (*pathname == '/')
+            pathname++;
+        else
+            return 0;
+    } else
+        return 0;
+
+    if (!(*pathname))
         return 0;
+
+    pkgname = strdup(pathname);
+    if (!pkgname)
+        return -1;
+
+    for (end = pkgname; *end && *end != '/'; end++)
+        ;
+    pathname = end;
+    if (*end)
+        pathname++;
+    *end = '\0';
+
+    if (!seinfo) {
+        info = package_info_lookup(pkgname);
+        if (!info) {
+            selinux_log(SELINUX_WARNING, "SELinux:  Could not look up information for package %s, cannot restorecon %s.\n",
+                        pkgname, pathname);
+            free(pkgname);
+            return -1;
+        }
+    }
+
+    ctx = context_new(secontext);
+    if (!ctx)
+        goto err;
+
+    rc = seapp_context_lookup(SEAPP_TYPE, info ? info->uid : uid, 0,
+                              info ? info->seinfo : seinfo, info ? info->name : pkgname, pathname, ctx);
+    if (rc < 0)
+        goto err;
+
+    secontext = context_str(ctx);
+    if (!secontext)
+        goto err;
+
+    if (!strcmp(secontext, *secontextp))
+        goto out;
+
+    rc = security_check_context(secontext);
+    if (rc < 0)
+        goto err;
+
+    freecon(*secontextp);
+    *secontextp = strdup(secontext);
+    if (!(*secontextp))
+        goto err;
+
+    rc = 0;
+
+out:
+    free(pkgname);
+    context_free(ctx);
+    return rc;
+err:
+    selinux_log(SELINUX_ERROR, "%s:  Error looking up context for path %s, pkgname %s, seinfo %s, uid %u: %s\n",
+                __FUNCTION__, pathname, pkgname, info->seinfo, info->uid, strerror(errno));
+    rc = -1;
+    goto out;
 }
 
 #define RESTORECON_LAST "security.restorecon_last"
@@ -328,7 +1337,54 @@ static int restorecon_sb(const char *pathname, const struct stat *sb,
                          bool nochange, bool verbose,
                          const char *seinfo, uid_t uid)
 {
-        return 0;
+    char *secontext = NULL;
+    char *oldsecontext = NULL;
+    int rc = 0;
+
+    if (selabel_lookup(fc_sehandle, &secontext, pathname, sb->st_mode) < 0)
+        return 0;  /* no match, but not an error */
+
+    if (lgetfilecon(pathname, &oldsecontext) < 0)
+        goto err;
+
+    /*
+     * For subdirectories of /data/data or /data/user, we ignore selabel_lookup()
+     * and use pkgdir_selabel_lookup() instead. Files within those directories
+     * have different labeling rules, based off of /seapp_contexts, and
+     * installd is responsible for managing these labels instead of init.
+     */
+    if (!strncmp(pathname, DATA_DATA_PREFIX, sizeof(DATA_DATA_PREFIX)-1) ||
+        !strncmp(pathname, DATA_USER_PREFIX, sizeof(DATA_USER_PREFIX)-1) ||
+        !strncmp(pathname, DATA_USER_DE_PREFIX, sizeof(DATA_USER_DE_PREFIX)-1) ||
+        !fnmatch(EXPAND_USER_PATH, pathname, FNM_LEADING_DIR|FNM_PATHNAME) ||
+        !fnmatch(EXPAND_USER_DE_PATH, pathname, FNM_LEADING_DIR|FNM_PATHNAME)) {
+        if (pkgdir_selabel_lookup(pathname, seinfo, uid, &secontext) < 0)
+            goto err;
+    }
+
+    if (strcmp(oldsecontext, secontext) != 0) {
+        if (verbose)
+            selinux_log(SELINUX_INFO,
+                        "SELinux:  Relabeling %s from %s to %s.\n", pathname, oldsecontext, secontext);
+        if (!nochange) {
+            if (lsetfilecon(pathname, secontext) < 0)
+                goto err;
+        }
+    }
+
+    rc = 0;
+
+out:
+    freecon(oldsecontext);
+    freecon(secontext);
+    return rc;
+
+err:
+    selinux_log(SELINUX_ERROR,
+                "SELinux: Could not set context for %s:  %s\n",
+                pathname, strerror(errno));
+    rc = -1;
+    goto out;
 }
 
 #define SYS_PATH "/sys"
@@ -339,12 +1395,201 @@ static int selinux_android_restorecon_common(const char* pathname_orig,
                                              uid_t uid,
                                              unsigned int flags)
 {
+    bool nochange = (flags & SELINUX_ANDROID_RESTORECON_NOCHANGE) ? true : false;
+    bool verbose = (flags & SELINUX_ANDROID_RESTORECON_VERBOSE) ? true : false;
+    bool recurse = (flags & SELINUX_ANDROID_RESTORECON_RECURSE) ? true : false;
+    bool force = (flags & SELINUX_ANDROID_RESTORECON_FORCE) ? true : false;
+    bool datadata = (flags & SELINUX_ANDROID_RESTORECON_DATADATA) ? true : false;
+    bool skipce = (flags & SELINUX_ANDROID_RESTORECON_SKIPCE) ? true : false;
+    bool cross_filesystems = (flags & SELINUX_ANDROID_RESTORECON_CROSS_FILESYSTEMS) ? true : false;
+    bool issys;
+    bool setrestoreconlast = true;
+    struct stat sb;
+    struct statfs sfsb;
+    FTS *fts;
+    FTSENT *ftsent;
+    char *pathname = NULL, *pathdnamer = NULL, *pathdname, *pathbname;
+    char * paths[2] = { NULL , NULL };
+    int ftsflags = FTS_NOCHDIR | FTS_PHYSICAL;
+    int error, sverrno;
+    char xattr_value[FC_DIGEST_SIZE];
+    ssize_t size;
+
+    if (!cross_filesystems) {
+        ftsflags |= FTS_XDEV;
+    }
+
+    if (is_selinux_enabled() <= 0)
+        return 0;
+
+    __selinux_once(fc_once, file_context_init);
+
+    if (!fc_sehandle)
         return 0;
+
+    /*
+     * Convert passed-in pathname to canonical pathname by resolving realpath of
+     * containing dir, then appending last component name.
+     */
+    pathbname = basename(pathname_orig);
+    if (!strcmp(pathbname, "/") || !strcmp(pathbname, ".") || !strcmp(pathbname, "..")) {
+        pathname = realpath(pathname_orig, NULL);
+        if (!pathname)
+            goto realpatherr;
+    } else {
+        pathdname = dirname(pathname_orig);
+        pathdnamer = realpath(pathdname, NULL);
+        if (!pathdnamer)
+            goto realpatherr;
+        if (!strcmp(pathdnamer, "/"))
+            error = asprintf(&pathname, "/%s", pathbname);
+        else
+            error = asprintf(&pathname, "%s/%s", pathdnamer, pathbname);
+        if (error < 0)
+            goto oom;
+    }
+
+    paths[0] = pathname;
+    issys = (!strcmp(pathname, SYS_PATH)
+            || !strncmp(pathname, SYS_PREFIX, sizeof(SYS_PREFIX)-1)) ? true : false;
+
+    if (!recurse) {
+        if (lstat(pathname, &sb) < 0) {
+            error = -1;
+            goto cleanup;
+        }
+
+        error = restorecon_sb(pathname, &sb, nochange, verbose, seinfo, uid);
+        goto cleanup;
+    }
+
+    /*
+     * Ignore restorecon_last on /data/data or /data/user
+     * since their labeling is based on seapp_contexts and seinfo
+     * assignments rather than file_contexts and is managed by
+     * installd rather than init.
+     */
+    if (!strncmp(pathname, DATA_DATA_PREFIX, sizeof(DATA_DATA_PREFIX)-1) ||
+        !strncmp(pathname, DATA_USER_PREFIX, sizeof(DATA_USER_PREFIX)-1) ||
+        !strncmp(pathname, DATA_USER_DE_PREFIX, sizeof(DATA_USER_DE_PREFIX)-1) ||
+        !fnmatch(EXPAND_USER_PATH, pathname, FNM_LEADING_DIR|FNM_PATHNAME) ||
+        !fnmatch(EXPAND_USER_DE_PATH, pathname, FNM_LEADING_DIR|FNM_PATHNAME))
+        setrestoreconlast = false;
+
+    /* Also ignore on /sys since it is regenerated on each boot regardless. */
+    if (issys)
+        setrestoreconlast = false;
+
+    /* Ignore files on in-memory filesystems */
+    if (statfs(pathname, &sfsb) == 0) {
+        if (sfsb.f_type == RAMFS_MAGIC || sfsb.f_type == TMPFS_MAGIC)
+            setrestoreconlast = false;
+    }
+
+    if (setrestoreconlast) {
+        size = getxattr(pathname, RESTORECON_LAST, xattr_value, sizeof fc_digest);
+        if (!force && size == sizeof fc_digest && memcmp(fc_digest, xattr_value, sizeof fc_digest) == 0) {
+            selinux_log(SELINUX_INFO,
+                        "SELinux: Skipping restorecon_recursive(%s)\n",
+                        pathname);
+            error = 0;
+            goto cleanup;
+        }
+    }
+
+    fts = fts_open(paths, ftsflags, NULL);
+    if (!fts) {
+        error = -1;
+        goto cleanup;
+    }
+
+    error = 0;
+    while ((ftsent = fts_read(fts)) != NULL) {
+        switch (ftsent->fts_info) {
+        case FTS_DC:
+            selinux_log(SELINUX_ERROR,
+                        "SELinux:  Directory cycle on %s.\n", ftsent->fts_path);
+            errno = ELOOP;
+            error = -1;
+            goto out;
+        case FTS_DP:
+            continue;
+        case FTS_DNR:
+            selinux_log(SELINUX_ERROR,
+                        "SELinux:  Could not read %s: %s.\n", ftsent->fts_path, strerror(errno));
+            fts_set(fts, ftsent, FTS_SKIP);
+            continue;
+        case FTS_NS:
+            selinux_log(SELINUX_ERROR,
+                        "SELinux:  Could not stat %s: %s.\n", ftsent->fts_path, strerror(errno));
+            fts_set(fts, ftsent, FTS_SKIP);
+            continue;
+        case FTS_ERR:
+            selinux_log(SELINUX_ERROR,
+                        "SELinux:  Error on %s: %s.\n", ftsent->fts_path, strerror(errno));
+            fts_set(fts, ftsent, FTS_SKIP);
+            continue;
+        case FTS_D:
+            if (issys && !selabel_partial_match(fc_sehandle, ftsent->fts_path)) {
+                fts_set(fts, ftsent, FTS_SKIP);
+                continue;
+            }
+
+            if (skipce &&
+                (!strncmp(ftsent->fts_path, DATA_SYSTEM_CE_PREFIX, sizeof(DATA_SYSTEM_CE_PREFIX)-1) ||
+                 !strncmp(ftsent->fts_path, DATA_MISC_CE_PREFIX, sizeof(DATA_MISC_CE_PREFIX)-1))) {
+                // Don't label anything below this directory.
+                fts_set(fts, ftsent, FTS_SKIP);
+                // but fall through and make sure we label the directory itself
+            }
+
+            if (!datadata &&
+                (!strcmp(ftsent->fts_path, DATA_DATA_PATH) ||
+                 !strncmp(ftsent->fts_path, DATA_USER_PREFIX, sizeof(DATA_USER_PREFIX)-1) ||
+                 !strncmp(ftsent->fts_path, DATA_USER_DE_PREFIX, sizeof(DATA_USER_DE_PREFIX)-1) ||
+                 !fnmatch(EXPAND_USER_PATH, ftsent->fts_path, FNM_LEADING_DIR|FNM_PATHNAME) ||
+                 !fnmatch(EXPAND_USER_DE_PATH, ftsent->fts_path, FNM_LEADING_DIR|FNM_PATHNAME))) {
+                // Don't label anything below this directory.
+                fts_set(fts, ftsent, FTS_SKIP);
+                // but fall through and make sure we label the directory itself
+            }
+            /* fall through */
+        default:
+            error |= restorecon_sb(ftsent->fts_path, ftsent->fts_statp, nochange, verbose, seinfo, uid);
+            break;
+        }
+    }
+
+    // Labeling successful. Mark the top level directory as completed.
+    if (setrestoreconlast && !nochange && !error)
+        setxattr(pathname, RESTORECON_LAST, fc_digest, sizeof fc_digest, 0);
+
+out:
+    sverrno = errno;
+    (void) fts_close(fts);
+    errno = sverrno;
+cleanup:
+    free(pathdnamer);
+    free(pathname);
+    return error;
+oom:
+    sverrno = errno;
+    selinux_log(SELINUX_ERROR, "%s:  Out of memory\n", __FUNCTION__);
+    errno = sverrno;
+    error = -1;
+    goto cleanup;
+realpatherr:
+    sverrno = errno;
+    selinux_log(SELINUX_ERROR, "SELinux: Could not get canonical path for %s restorecon: %s.\n",
+            pathname_orig, strerror(errno));
+    errno = sverrno;
+    error = -1;
+    goto cleanup;
 }
 
 int selinux_android_restorecon(const char *file, unsigned int flags)
 {
-    return 0;
+    return selinux_android_restorecon_common(file, NULL, -1, flags);
 }
 
 int selinux_android_restorecon_pkgdir(const char *pkgdir,
@@ -352,65 +1597,223 @@ int selinux_android_restorecon_pkgdir(const char *pkgdir,
                                       uid_t uid,
                                       unsigned int flags)
 {
-    return 0;
+    return selinux_android_restorecon_common(pkgdir, seinfo, uid, flags | SELINUX_ANDROID_RESTORECON_DATADATA);
 }
 
 static struct selabel_handle* selinux_android_file_context(const struct selinux_opt *opts,
                                                     unsigned nopts)
 {
-    return NULL;
+    struct selabel_handle *sehandle;
+    struct selinux_opt fc_opts[nopts + 1];
+
+    memcpy(fc_opts, opts, nopts*sizeof(struct selinux_opt));
+    fc_opts[nopts].type = SELABEL_OPT_BASEONLY;
+    fc_opts[nopts].value = (char *)1;
+
+    sehandle = selabel_open(SELABEL_CTX_FILE, fc_opts, ARRAY_SIZE(fc_opts));
+    if (!sehandle) {
+        selinux_log(SELINUX_ERROR, "%s: Error getting file context handle (%s)\n",
+                __FUNCTION__, strerror(errno));
+        return NULL;
+    }
+    if (!compute_file_contexts_hash(fc_digest, opts, nopts)) {
+        selabel_close(sehandle);
+        return NULL;
+    }
+
+    selinux_log(SELINUX_INFO, "SELinux: Loaded file_contexts\n");
+
+    return sehandle;
 }
 
 static bool selinux_android_opts_file_exists(const struct selinux_opt *opt)
 {
-        return 0;
+    return (access(opt[0].value, R_OK) != -1);
 }
 
 struct selabel_handle* selinux_android_file_context_handle(void)
 {
-	return NULL;
+    if (selinux_android_opts_file_exists(seopts_file_split)) {
+        return selinux_android_file_context(seopts_file_split,
+                                            ARRAY_SIZE(seopts_file_split));
+    } else {
+        return selinux_android_file_context(seopts_file_rootfs,
+                                            ARRAY_SIZE(seopts_file_rootfs));
+    }
 }
 struct selabel_handle* selinux_android_prop_context_handle(void)
 {
+    struct selabel_handle* sehandle;
+    const struct selinux_opt* seopts_prop;
+
+    // Prefer files from /system & /vendor, fall back to files from /
+    if (access(seopts_prop_split[0].value, R_OK) != -1) {
+        seopts_prop = seopts_prop_split;
+    } else {
+        seopts_prop = seopts_prop_rootfs;
+    }
+
+    sehandle = selabel_open(SELABEL_CTX_ANDROID_PROP,
+            seopts_prop, 2);
+    if (!sehandle) {
+        selinux_log(SELINUX_ERROR, "%s: Error getting property context handle (%s)\n",
+                __FUNCTION__, strerror(errno));
         return NULL;
+    }
+    selinux_log(SELINUX_INFO, "SELinux: Loaded property_contexts from %s & %s.\n",
+            seopts_prop[0].value, seopts_prop[1].value);
+
+    return sehandle;
 }
 
 struct selabel_handle* selinux_android_service_open_context_handle(const struct selinux_opt* seopts_service,
                                                                    unsigned nopts)
 {
+    struct selabel_handle* sehandle;
+
+    sehandle = selabel_open(SELABEL_CTX_ANDROID_SERVICE,
+            seopts_service, nopts);
+
+    if (!sehandle) {
+        selinux_log(SELINUX_ERROR, "%s: Error getting service context handle (%s)\n",
+                __FUNCTION__, strerror(errno));
         return NULL;
+    }
+    selinux_log(SELINUX_INFO, "SELinux: Loaded service_contexts from:\n");
+    for (unsigned i = 0; i < nopts; i++) {
+        selinux_log(SELINUX_INFO, "    %s\n", seopts_service[i].value);
+    }
+    return sehandle;
 }
 
 struct selabel_handle* selinux_android_service_context_handle(void)
 {
-        return NULL;
+    const struct selinux_opt* seopts_service;
+
+    // Prefer files from /system & /vendor, fall back to files from /
+    if (access(seopts_service_split[0].value, R_OK) != -1) {
+        seopts_service = seopts_service_split;
+    } else {
+        seopts_service = seopts_service_rootfs;
+    }
+
+    // TODO(b/36866029) full treble devices can't load non-plat
+    return selinux_android_service_open_context_handle(seopts_service, 2);
 }
 
 struct selabel_handle* selinux_android_hw_service_context_handle(void)
 {
-        return NULL;
+    const struct selinux_opt* seopts_service;
+    if (access(seopts_hwservice_split[0].value, R_OK) != -1) {
+        seopts_service = seopts_hwservice_split;
+    } else {
+        seopts_service = seopts_hwservice_rootfs;
+    }
+
+    return selinux_android_service_open_context_handle(seopts_service, 2);
 }
 
 struct selabel_handle* selinux_android_vendor_service_context_handle(void)
 {
-        return NULL;
+    const struct selinux_opt* seopts_service;
+    if (access(seopts_vndservice.value, R_OK) != -1) {
+        seopts_service = &seopts_vndservice;
+    } else {
+        seopts_service = &seopts_vndservice_rootfs;
+    }
+
+    return selinux_android_service_open_context_handle(seopts_service, 1);
 }
 
 void selinux_android_set_sehandle(const struct selabel_handle *hndl)
 {
+    fc_sehandle = (struct selabel_handle *) hndl;
 }
 
 int selinux_android_load_policy()
 {
-	return 0;
+	int fd = -1;
+
+	fd = open(sepolicy_file, O_RDONLY | O_NOFOLLOW | O_CLOEXEC);
+	if (fd < 0) {
+		selinux_log(SELINUX_ERROR, "SELinux:  Could not open %s:  %s\n",
+				sepolicy_file, strerror(errno));
+		return -1;
+	}
+	int ret = selinux_android_load_policy_from_fd(fd, sepolicy_file);
+	close(fd);
+	return ret;
 }
 
 int selinux_android_load_policy_from_fd(int fd, const char *description)
 {
-        return 0;
+	int rc;
+	struct stat sb;
+	void *map = NULL;
+	static int load_successful = 0;
+
+	/*
+	 * Since updating policy at runtime has been abolished
+	 * we just check whether a policy has been loaded before
+	 * and return if this is the case.
+	 * There is no point in reloading policy.
+	 */
+	if (load_successful){
+	  selinux_log(SELINUX_WARNING, "SELinux: Attempted reload of SELinux policy!/n");
+	  return 0;
+	}
+
+	set_selinuxmnt(SELINUXMNT);
+	if (fstat(fd, &sb) < 0) {
+		selinux_log(SELINUX_ERROR, "SELinux:  Could not stat %s:  %s\n",
+				description, strerror(errno));
+		return -1;
+	}
+	map = mmap(NULL, sb.st_size, PROT_READ, MAP_PRIVATE, fd, 0);
+	if (map == MAP_FAILED) {
+		selinux_log(SELINUX_ERROR, "SELinux:  Could not map %s:  %s\n",
+				description, strerror(errno));
+		return -1;
+	}
+
+	rc = security_load_policy(map, sb.st_size);
+	if (rc < 0) {
+		selinux_log(SELINUX_ERROR, "SELinux:  Could not load policy:  %s\n",
+				strerror(errno));
+		munmap(map, sb.st_size);
+		return -1;
+	}
+
+	munmap(map, sb.st_size);
+	selinux_log(SELINUX_INFO, "SELinux: Loaded policy from %s\n", description);
+	load_successful = 1;
+	return 0;
 }
 
 int selinux_log_callback(int type, const char *fmt, ...)
 {
-        return 0;
+    va_list ap;
+    int priority;
+    char *strp;
+
+    switch(type) {
+    case SELINUX_WARNING:
+        priority = ANDROID_LOG_WARN;
+        break;
+    case SELINUX_INFO:
+        priority = ANDROID_LOG_INFO;
+        break;
+    default:
+        priority = ANDROID_LOG_ERROR;
+        break;
+    }
+
+    va_start(ap, fmt);
+    if (vasprintf(&strp, fmt, ap) != -1) {
+        LOG_PRI(priority, "SELinux", "%s", strp);
+        LOG_EVENT_STRING(AUDITD_LOG_TAG, strp);
+        free(strp);
+    }
+    va_end(ap);
+    return 0;
 }
diff --git a/libselinux/src/avc.c b/libselinux/src/avc.c
index 65cb1d8..b1ec57f 100644
--- a/libselinux/src/avc.c
+++ b/libselinux/src/avc.c
@@ -63,47 +63,101 @@ static struct sidtab avc_sidtab;
 static inline int avc_hash(security_id_t ssid,
 			   security_id_t tsid, security_class_t tclass)
 {
-	return 0;
+	return ((uintptr_t) ssid ^ ((uintptr_t) tsid << 2) ^ tclass)
+	    & (AVC_CACHE_SLOTS - 1);
 }
 
 int avc_context_to_sid_raw(const char * ctx, security_id_t * sid)
 {
-	return 0;
+	int rc;
+	/* avc_init needs to be called before this function */
+	assert(avc_running);
+
+	avc_get_lock(avc_lock);
+	rc = sidtab_context_to_sid(&avc_sidtab, ctx, sid);
+	avc_release_lock(avc_lock);
+	return rc;
 }
 
 int avc_context_to_sid(const char * ctx, security_id_t * sid)
 {
-        return 0;
+	int ret;
+	char * rctx;
+
+	if (selinux_trans_to_raw_context(ctx, &rctx))
+		return -1;
+
+	ret = avc_context_to_sid_raw(rctx, sid);
+
+	freecon(rctx);
+
+	return ret;
 }
 
 int avc_sid_to_context_raw(security_id_t sid, char ** ctx)
 {
-        return 0;
+	int rc;
+	*ctx = NULL;
+	avc_get_lock(avc_lock);
+	*ctx = strdup(sid->ctx);	/* caller must free via freecon */
+	rc = *ctx ? 0 : -1;
+	avc_release_lock(avc_lock);
+	return rc;
 }
 
 int avc_sid_to_context(security_id_t sid, char ** ctx)
 {
-        return 0;
+	int ret;
+	char * rctx;
+
+	ret = avc_sid_to_context_raw(sid, &rctx);
+
+	if (ret == 0) {
+		ret = selinux_raw_to_trans_context(rctx, ctx);
+		freecon(rctx);
+	}
+
+	return ret;
 }
 
 int sidget(security_id_t sid __attribute__((unused)))
 {
-	return 0;
+	return 1;
 }
 
 int sidput(security_id_t sid __attribute__((unused)))
 {
-	return 0;
+	return 1;
 }
 
 int avc_get_initial_sid(const char * name, security_id_t * sid)
 {
-        return 0;
+	int rc;
+	char * con;
+
+	rc = security_get_initial_context_raw(name, &con);
+	if (rc < 0)
+		return rc;
+	rc = avc_context_to_sid_raw(con, sid);
+
+	freecon(con);
+
+	return rc;
 }
 
 int avc_open(struct selinux_opt *opts, unsigned nopts)
 {
-        return 0;
+	avc_setenforce = 0;
+
+	while (nopts--)
+		switch(opts[nopts].type) {
+		case AVC_OPT_SETENFORCE:
+			avc_setenforce = 1;
+			avc_enforcing = !!opts[nopts].value;
+			break;
+		}
+
+	return avc_init("avc", NULL, NULL, NULL, NULL);
 }
 
 int avc_init(const char *prefix,
@@ -112,37 +166,210 @@ int avc_init(const char *prefix,
 	     const struct avc_thread_callback *thread_cb,
 	     const struct avc_lock_callback *lock_cb)
 {
-        return 0;
+	struct avc_node *new;
+	int i, rc = 0;
+
+	if (avc_running)
+		return 0;
+
+	if (prefix)
+		strncpy(avc_prefix, prefix, AVC_PREFIX_SIZE - 1);
+
+	set_callbacks(mem_cb, log_cb, thread_cb, lock_cb);
+
+	avc_lock = avc_alloc_lock();
+	avc_log_lock = avc_alloc_lock();
+
+	memset(&cache_stats, 0, sizeof(cache_stats));
+
+	for (i = 0; i < AVC_CACHE_SLOTS; i++)
+		avc_cache.slots[i] = 0;
+	avc_cache.lru_hint = 0;
+	avc_cache.active_nodes = 0;
+	avc_cache.latest_notif = 0;
+
+	rc = sidtab_init(&avc_sidtab);
+	if (rc) {
+		avc_log(SELINUX_ERROR,
+			"%s:  unable to initialize SID table\n",
+			avc_prefix);
+		goto out;
+	}
+
+	avc_audit_buf = (char *)avc_malloc(AVC_AUDIT_BUFSIZE);
+	if (!avc_audit_buf) {
+		avc_log(SELINUX_ERROR,
+			"%s:  unable to allocate audit buffer\n",
+			avc_prefix);
+		rc = -1;
+		goto out;
+	}
+
+	for (i = 0; i < AVC_CACHE_MAXNODES; i++) {
+		new = avc_malloc(sizeof(*new));
+		if (!new) {
+			avc_log(SELINUX_WARNING,
+				"%s:  warning: only got %d av entries\n",
+				avc_prefix, i);
+			break;
+		}
+		memset(new, 0, sizeof(*new));
+		new->next = avc_node_freelist;
+		avc_node_freelist = new;
+	}
+
+	if (!avc_setenforce) {
+		rc = security_getenforce();
+		if (rc < 0) {
+			avc_log(SELINUX_ERROR,
+				"%s:  could not determine enforcing mode: %s\n",
+				avc_prefix,
+				strerror(errno));
+			goto out;
+		}
+		avc_enforcing = rc;
+	}
+
+	rc = avc_netlink_open(0);
+	if (rc < 0) {
+		avc_log(SELINUX_ERROR,
+			"%s:  can't open netlink socket: %d (%s)\n",
+			avc_prefix, errno, strerror(errno));
+		goto out;
+	}
+	if (avc_using_threads) {
+		avc_netlink_thread = avc_create_thread(&avc_netlink_loop);
+		avc_netlink_trouble = 0;
+	}
+	avc_running = 1;
+      out:
+	return rc;
 }
 
 void avc_cache_stats(struct avc_cache_stats *p)
 {
+	memcpy(p, &cache_stats, sizeof(cache_stats));
 }
 
 void avc_sid_stats(void)
 {
+	/* avc_init needs to be called before this function */
+	assert(avc_running);
+	avc_get_lock(avc_log_lock);
+	avc_get_lock(avc_lock);
+	sidtab_sid_stats(&avc_sidtab, avc_audit_buf, AVC_AUDIT_BUFSIZE);
+	avc_release_lock(avc_lock);
+	avc_log(SELINUX_INFO, "%s", avc_audit_buf);
+	avc_release_lock(avc_log_lock);
 }
 
 void avc_av_stats(void)
 {
+	int i, chain_len, max_chain_len, slots_used;
+	struct avc_node *node;
+
+	avc_get_lock(avc_lock);
+
+	slots_used = 0;
+	max_chain_len = 0;
+	for (i = 0; i < AVC_CACHE_SLOTS; i++) {
+		node = avc_cache.slots[i];
+		if (node) {
+			slots_used++;
+			chain_len = 0;
+			while (node) {
+				chain_len++;
+				node = node->next;
+			}
+			if (chain_len > max_chain_len)
+				max_chain_len = chain_len;
+		}
+	}
+
+	avc_release_lock(avc_lock);
+
+	avc_log(SELINUX_INFO, "%s:  %u AV entries and %d/%d buckets used, "
+		"longest chain length %d\n", avc_prefix,
+		avc_cache.active_nodes,
+		slots_used, AVC_CACHE_SLOTS, max_chain_len);
 }
 
 hidden_def(avc_av_stats)
 
 static inline struct avc_node *avc_reclaim_node(void)
 {
+	struct avc_node *prev, *cur;
+	int try;
+	uint32_t hvalue;
+
+	hvalue = avc_cache.lru_hint;
+	for (try = 0; try < 2; try++) {
+		do {
+			prev = NULL;
+			cur = avc_cache.slots[hvalue];
+			while (cur) {
+				if (!cur->ae.used)
+					goto found;
+
+				cur->ae.used = 0;
+
+				prev = cur;
+				cur = cur->next;
+			}
+			hvalue = (hvalue + 1) & (AVC_CACHE_SLOTS - 1);
+		} while (hvalue != avc_cache.lru_hint);
+	}
+
+	errno = ENOMEM;		/* this was a panic in the kernel... */
 	return NULL;
+
+      found:
+	avc_cache.lru_hint = hvalue;
+
+	if (prev == NULL)
+		avc_cache.slots[hvalue] = cur->next;
+	else
+		prev->next = cur->next;
+
+	return cur;
 }
 
 static inline void avc_clear_avc_entry(struct avc_entry *ae)
 {
+	memset(ae, 0, sizeof(*ae));
 }
 
 static inline struct avc_node *avc_claim_node(security_id_t ssid,
 					      security_id_t tsid,
 					      security_class_t tclass)
 {
-	return NULL;
+	struct avc_node *new;
+	int hvalue;
+
+	if (!avc_node_freelist)
+		avc_cleanup();
+
+	if (avc_node_freelist) {
+		new = avc_node_freelist;
+		avc_node_freelist = avc_node_freelist->next;
+		avc_cache.active_nodes++;
+	} else {
+		new = avc_reclaim_node();
+		if (!new)
+			goto out;
+	}
+
+	hvalue = avc_hash(ssid, tsid, tclass);
+	avc_clear_avc_entry(&new->ae);
+	new->ae.used = 1;
+	new->ae.ssid = ssid;
+	new->ae.tsid = tsid;
+	new->ae.tclass = tclass;
+	new->next = avc_cache.slots[hvalue];
+	avc_cache.slots[hvalue] = new;
+
+      out:
+	return new;
 }
 
 static inline struct avc_node *avc_search_node(security_id_t ssid,
@@ -150,7 +377,32 @@ static inline struct avc_node *avc_search_node(security_id_t ssid,
 					       security_class_t tclass,
 					       int *probes)
 {
-	return NULL;
+	struct avc_node *cur;
+	int hvalue;
+	int tprobes = 1;
+
+	hvalue = avc_hash(ssid, tsid, tclass);
+	cur = avc_cache.slots[hvalue];
+	while (cur != NULL &&
+	       (ssid != cur->ae.ssid ||
+		tclass != cur->ae.tclass || tsid != cur->ae.tsid)) {
+		tprobes++;
+		cur = cur->next;
+	}
+
+	if (cur == NULL) {
+		/* cache miss */
+		goto out;
+	}
+
+	/* cache hit */
+	if (probes)
+		*probes = tprobes;
+
+	cur->ae.used = 1;
+
+      out:
+	return cur;
 }
 
 /**
@@ -172,7 +424,23 @@ static int avc_lookup(security_id_t ssid, security_id_t tsid,
 		      security_class_t tclass,
 		      access_vector_t requested, struct avc_entry_ref *aeref)
 {
-	return 0;
+	struct avc_node *node;
+	int probes, rc = 0;
+
+	avc_cache_stats_incr(cav_lookups);
+	node = avc_search_node(ssid, tsid, tclass, &probes);
+
+	if (node && ((node->ae.avd.decided & requested) == requested)) {
+		avc_cache_stats_incr(cav_hits);
+		avc_cache_stats_add(cav_probes, probes);
+		aeref->ae = &node->ae;
+		goto out;
+	}
+
+	avc_cache_stats_incr(cav_misses);
+	rc = -1;
+      out:
+	return rc;
 }
 
 /**
@@ -198,7 +466,28 @@ static int avc_insert(security_id_t ssid, security_id_t tsid,
 		      security_class_t tclass,
 		      struct avc_entry *ae, struct avc_entry_ref *aeref)
 {
-	return 0;
+	struct avc_node *node;
+	int rc = 0;
+
+	if (ae->avd.seqno < avc_cache.latest_notif) {
+		avc_log(SELINUX_WARNING,
+			"%s:  seqno %u < latest_notif %u\n", avc_prefix,
+			ae->avd.seqno, avc_cache.latest_notif);
+		errno = EAGAIN;
+		rc = -1;
+		goto out;
+	}
+
+	node = avc_claim_node(ssid, tsid, tclass);
+	if (!node) {
+		rc = -1;
+		goto out;
+	}
+
+	memcpy(&node->ae.avd, &ae->avd, sizeof(ae->avd));
+	aeref->ae = &node->ae;
+      out:
+	return rc;
 }
 
 void avc_cleanup(void)
@@ -209,13 +498,88 @@ hidden_def(avc_cleanup)
 
 int avc_reset(void)
 {
+	struct avc_callback_node *c;
+	int i, ret, rc = 0, errsave = 0;
+	struct avc_node *node, *tmp;
+	errno = 0;
+
+	if (!avc_running)
 		return 0;
+
+	avc_get_lock(avc_lock);
+
+	for (i = 0; i < AVC_CACHE_SLOTS; i++) {
+		node = avc_cache.slots[i];
+		while (node) {
+			tmp = node;
+			node = node->next;
+			avc_clear_avc_entry(&tmp->ae);
+			tmp->next = avc_node_freelist;
+			avc_node_freelist = tmp;
+			avc_cache.active_nodes--;
+		}
+		avc_cache.slots[i] = 0;
+	}
+	avc_cache.lru_hint = 0;
+
+	avc_release_lock(avc_lock);
+
+	memset(&cache_stats, 0, sizeof(cache_stats));
+
+	for (c = avc_callbacks; c; c = c->next) {
+		if (c->events & AVC_CALLBACK_RESET) {
+			ret = c->callback(AVC_CALLBACK_RESET, 0, 0, 0, 0, 0);
+			if (ret && !rc) {
+				rc = ret;
+				errsave = errno;
+			}
+		}
+	}
+	errno = errsave;
+	return rc;
 }
 
 hidden_def(avc_reset)
 
 void avc_destroy(void)
 {
+	struct avc_callback_node *c;
+	struct avc_node *node, *tmp;
+	int i;
+	/* avc_init needs to be called before this function */
+	assert(avc_running);
+
+	avc_get_lock(avc_lock);
+
+	if (avc_using_threads)
+		avc_stop_thread(avc_netlink_thread);
+	avc_netlink_close();
+
+	for (i = 0; i < AVC_CACHE_SLOTS; i++) {
+		node = avc_cache.slots[i];
+		while (node) {
+			tmp = node;
+			node = node->next;
+			avc_free(tmp);
+		}
+	}
+	while (avc_node_freelist) {
+		tmp = avc_node_freelist;
+		avc_node_freelist = tmp->next;
+		avc_free(tmp);
+	}
+	avc_release_lock(avc_lock);
+
+	while (avc_callbacks) {
+		c = avc_callbacks;
+		avc_callbacks = c->next;
+		avc_free(c);
+	}
+	sidtab_destroy(&avc_sidtab);
+	avc_free_lock(avc_lock);
+	avc_free_lock(avc_log_lock);
+	avc_free(avc_audit_buf);
+	avc_running = 0;
 }
 
 /* ratelimit stuff put aside for now --EFW */
@@ -282,6 +646,30 @@ static inline int check_avc_ratelimit(void)
  */
 static void avc_dump_av(security_class_t tclass, access_vector_t av)
 {
+	const char *permstr;
+	access_vector_t bit = 1;
+
+	if (av == 0) {
+		log_append(avc_audit_buf, " null");
+		return;
+	}
+
+	log_append(avc_audit_buf, " {");
+
+	while (av) {
+		if (av & bit) {
+			permstr = security_av_perm_to_string(tclass, bit);
+			if (!permstr)
+				break;
+			log_append(avc_audit_buf, " %s", permstr);
+			av &= ~bit;
+		}
+		bit <<= 1;
+	}
+
+	if (av)
+		log_append(avc_audit_buf, " 0x%x", av);
+	log_append(avc_audit_buf, " }");
 }
 
 /**
@@ -293,12 +681,52 @@ static void avc_dump_av(security_class_t tclass, access_vector_t av)
 static void avc_dump_query(security_id_t ssid, security_id_t tsid,
 			   security_class_t tclass)
 {
+	avc_get_lock(avc_lock);
+
+	log_append(avc_audit_buf, "scontext=%s tcontext=%s",
+		   ssid->ctx, tsid->ctx);
+
+	avc_release_lock(avc_lock);
+	log_append(avc_audit_buf, " tclass=%s",
+		   security_class_to_string(tclass));
 }
 
 void avc_audit(security_id_t ssid, security_id_t tsid,
 	       security_class_t tclass, access_vector_t requested,
 	       struct av_decision *avd, int result, void *a)
 {
+	access_vector_t denied, audited;
+
+	denied = requested & ~avd->allowed;
+	if (denied)
+		audited = denied & avd->auditdeny;
+	else if (!requested || result)
+		audited = denied = requested;
+	else
+		audited = requested & avd->auditallow;
+	if (!audited)
+		return;
+#if 0
+	if (!check_avc_ratelimit())
+		return;
+#endif
+	/* prevent overlapping buffer writes */
+	avc_get_lock(avc_log_lock);
+	snprintf(avc_audit_buf, AVC_AUDIT_BUFSIZE,
+		 "%s:  %s ", avc_prefix, (denied || !requested) ? "denied" : "granted");
+	avc_dump_av(tclass, audited);
+	log_append(avc_audit_buf, " for ");
+
+	/* get any extra information printed by the callback */
+	avc_suppl_audit(a, tclass, avc_audit_buf + strlen(avc_audit_buf),
+			AVC_AUDIT_BUFSIZE - strlen(avc_audit_buf));
+
+	log_append(avc_audit_buf, " ");
+	avc_dump_query(ssid, tsid, tclass);
+	log_append(avc_audit_buf, "\n");
+	avc_log(SELINUX_AVC, "%s", avc_audit_buf);
+
+	avc_release_lock(avc_log_lock);
 }
 
 hidden_def(avc_audit)
@@ -306,6 +734,11 @@ hidden_def(avc_audit)
 
 static void avd_init(struct av_decision *avd)
 {
+	avd->allowed = 0;
+	avd->auditallow = 0;
+	avd->auditdeny = 0xffffffff;
+	avd->seqno = avc_cache.latest_notif;
+	avd->flags = 0;
 }
 
 int avc_has_perm_noaudit(security_id_t ssid,
@@ -314,7 +747,78 @@ int avc_has_perm_noaudit(security_id_t ssid,
 			 access_vector_t requested,
 			 struct avc_entry_ref *aeref, struct av_decision *avd)
 {
-	return 0;
+	struct avc_entry *ae;
+	int rc = 0;
+	struct avc_entry entry;
+	access_vector_t denied;
+	struct avc_entry_ref ref;
+
+	if (avd)
+		avd_init(avd);
+
+	if (!avc_using_threads && !avc_app_main_loop) {
+		(void)avc_netlink_check_nb();
+	}
+
+	if (!aeref) {
+		avc_entry_ref_init(&ref);
+		aeref = &ref;
+	}
+
+	avc_get_lock(avc_lock);
+	avc_cache_stats_incr(entry_lookups);
+	ae = aeref->ae;
+	if (ae) {
+		if (ae->ssid == ssid &&
+		    ae->tsid == tsid &&
+		    ae->tclass == tclass &&
+		    ((ae->avd.decided & requested) == requested)) {
+			avc_cache_stats_incr(entry_hits);
+			ae->used = 1;
+		} else {
+			avc_cache_stats_incr(entry_discards);
+			ae = 0;
+		}
+	}
+
+	if (!ae) {
+		avc_cache_stats_incr(entry_misses);
+		rc = avc_lookup(ssid, tsid, tclass, requested, aeref);
+		if (rc) {
+			rc = security_compute_av_flags_raw(ssid->ctx, tsid->ctx,
+							   tclass, requested,
+							   &entry.avd);
+			if (rc && errno == EINVAL && !avc_enforcing) {
+				rc = errno = 0;
+				goto out;
+			}
+			if (rc)
+				goto out;
+			rc = avc_insert(ssid, tsid, tclass, &entry, aeref);
+			if (rc)
+				goto out;
+		}
+		ae = aeref->ae;
+	}
+
+	if (avd)
+		memcpy(avd, &ae->avd, sizeof(*avd));
+
+	denied = requested & ~(ae->avd.allowed);
+
+	if (!requested || denied) {
+		if (!avc_enforcing ||
+		    (ae->avd.flags & SELINUX_AVD_FLAGS_PERMISSIVE))
+			ae->avd.allowed |= requested;
+		else {
+			errno = EACCES;
+			rc = -1;
+		}
+	}
+
+      out:
+	avc_release_lock(avc_lock);
+	return rc;
 }
 
 hidden_def(avc_has_perm_noaudit)
@@ -323,19 +827,84 @@ int avc_has_perm(security_id_t ssid, security_id_t tsid,
 		 security_class_t tclass, access_vector_t requested,
 		 struct avc_entry_ref *aeref, void *auditdata)
 {
-	return 0;
+	struct av_decision avd;
+	int errsave, rc;
+
+	rc = avc_has_perm_noaudit(ssid, tsid, tclass, requested, aeref, &avd);
+	errsave = errno;
+	avc_audit(ssid, tsid, tclass, requested, &avd, rc, auditdata);
+	errno = errsave;
+	return rc;
 }
 
 int avc_compute_create(security_id_t ssid,  security_id_t tsid,
 		       security_class_t tclass, security_id_t *newsid)
 {
-	return 0;
+	int rc;
+	struct avc_entry_ref aeref;
+	struct avc_entry entry;
+	char * ctx;
+
+	*newsid = NULL;
+	avc_entry_ref_init(&aeref);
+
+	avc_get_lock(avc_lock);
+
+	/* check for a cached entry */
+	rc = avc_lookup(ssid, tsid, tclass, 0, &aeref);
+	if (rc) {
+		/* need to make a cache entry for this tuple */
+		rc = security_compute_av_flags_raw(ssid->ctx, tsid->ctx,
+						   tclass, 0, &entry.avd);
+		if (rc)
+			goto out;
+		rc = avc_insert(ssid, tsid, tclass, &entry, &aeref);
+		if (rc)
+			goto out;
+	}
+
+	/* check for a saved compute_create value */
+	if (!aeref.ae->create_sid) {
+		/* need to query the kernel policy */
+		rc = security_compute_create_raw(ssid->ctx, tsid->ctx, tclass,
+						 &ctx);
+		if (rc)
+			goto out;
+		rc = sidtab_context_to_sid(&avc_sidtab, ctx, newsid);
+		freecon(ctx);
+		if (rc)
+			goto out;
+
+		aeref.ae->create_sid = *newsid;
+	} else {
+		/* found saved value */
+		*newsid = aeref.ae->create_sid;
+	}
+
+	rc = 0;
+out:
+	avc_release_lock(avc_lock);
+	return rc;
 }
 
 int avc_compute_member(security_id_t ssid,  security_id_t tsid,
 		       security_class_t tclass, security_id_t *newsid)
 {
-	return 0;
+	int rc;
+	char * ctx = NULL;
+	*newsid = NULL;
+	/* avc_init needs to be called before this function */
+	assert(avc_running);
+	avc_get_lock(avc_lock);
+
+	rc = security_compute_member_raw(ssid->ctx, tsid->ctx, tclass, &ctx);
+	if (rc)
+		goto out;
+	rc = sidtab_context_to_sid(&avc_sidtab, ctx, newsid);
+	freecon(ctx);
+out:
+	avc_release_lock(avc_lock);
+	return rc;
 }
 
 int avc_add_callback(int (*callback) (uint32_t event, security_id_t ssid,
@@ -347,23 +916,88 @@ int avc_add_callback(int (*callback) (uint32_t event, security_id_t ssid,
 		     security_id_t tsid,
 		     security_class_t tclass, access_vector_t perms)
 {
-	return 0;
+	struct avc_callback_node *c;
+	int rc = 0;
+
+	c = avc_malloc(sizeof(*c));
+	if (!c) {
+		rc = -1;
+		goto out;
+	}
+
+	c->callback = callback;
+	c->events = events;
+	c->ssid = ssid;
+	c->tsid = tsid;
+	c->tclass = tclass;
+	c->perms = perms;
+	c->next = avc_callbacks;
+	avc_callbacks = c;
+      out:
+	return rc;
 }
 
 static inline int avc_sidcmp(security_id_t x, security_id_t y)
 {
-        return 0;
+	return (x == y || x == SECSID_WILD || y == SECSID_WILD);
 }
 
 static inline void avc_update_node(uint32_t event, struct avc_node *node,
 				   access_vector_t perms)
 {
+	switch (event) {
+	case AVC_CALLBACK_GRANT:
+		node->ae.avd.allowed |= perms;
+		break;
+	case AVC_CALLBACK_TRY_REVOKE:
+	case AVC_CALLBACK_REVOKE:
+		node->ae.avd.allowed &= ~perms;
+		break;
+	case AVC_CALLBACK_AUDITALLOW_ENABLE:
+		node->ae.avd.auditallow |= perms;
+		break;
+	case AVC_CALLBACK_AUDITALLOW_DISABLE:
+		node->ae.avd.auditallow &= ~perms;
+		break;
+	case AVC_CALLBACK_AUDITDENY_ENABLE:
+		node->ae.avd.auditdeny |= perms;
+		break;
+	case AVC_CALLBACK_AUDITDENY_DISABLE:
+		node->ae.avd.auditdeny &= ~perms;
+		break;
+	}
 }
 
 static int avc_update_cache(uint32_t event, security_id_t ssid,
 			    security_id_t tsid, security_class_t tclass,
 			    access_vector_t perms)
 {
+	struct avc_node *node;
+	int i;
+
+	avc_get_lock(avc_lock);
+
+	if (ssid == SECSID_WILD || tsid == SECSID_WILD) {
+		/* apply to all matching nodes */
+		for (i = 0; i < AVC_CACHE_SLOTS; i++) {
+			for (node = avc_cache.slots[i]; node; node = node->next) {
+				if (avc_sidcmp(ssid, node->ae.ssid) &&
+				    avc_sidcmp(tsid, node->ae.tsid) &&
+				    tclass == node->ae.tclass) {
+					avc_update_node(event, node, perms);
+				}
+			}
+		}
+	} else {
+		/* apply to one node */
+		node = avc_search_node(ssid, tsid, tclass, 0);
+		if (node) {
+			avc_update_node(event, node, perms);
+		}
+	}
+
+	avc_release_lock(avc_lock);
+
 	return 0;
 }
 
@@ -377,7 +1011,51 @@ static int avc_control(uint32_t event, security_id_t ssid,
 		       access_vector_t perms,
 		       uint32_t seqno, access_vector_t * out_retained)
 {
-	return 0;
+	struct avc_callback_node *c;
+	access_vector_t tretained = 0, cretained = 0;
+	int ret, rc = 0, errsave = 0;
+	errno = 0;
+
+	/*
+	 * try_revoke only removes permissions from the cache
+	 * state if they are not retained by the object manager.
+	 * Hence, try_revoke must wait until after the callbacks have
+	 * been invoked to update the cache state.
+	 */
+	if (event != AVC_CALLBACK_TRY_REVOKE)
+		avc_update_cache(event, ssid, tsid, tclass, perms);
+
+	for (c = avc_callbacks; c; c = c->next) {
+		if ((c->events & event) &&
+		    avc_sidcmp(c->ssid, ssid) &&
+		    avc_sidcmp(c->tsid, tsid) &&
+		    c->tclass == tclass && (c->perms & perms)) {
+			cretained = 0;
+			ret = c->callback(event, ssid, tsid, tclass,
+					  (c->perms & perms), &cretained);
+			if (ret && !rc) {
+				rc = ret;
+				errsave = errno;
+			}
+			if (!ret)
+				tretained |= cretained;
+		}
+	}
+
+	if (event == AVC_CALLBACK_TRY_REVOKE) {
+		/* revoke any unretained permissions */
+		perms &= ~tretained;
+		avc_update_cache(event, ssid, tsid, tclass, perms);
+		*out_retained = tretained;
+	}
+
+	avc_get_lock(avc_lock);
+	if (seqno > avc_cache.latest_notif)
+		avc_cache.latest_notif = seqno;
+	avc_release_lock(avc_lock);
+
+	errno = errsave;
+	return rc;
 }
 
 /**
@@ -392,7 +1070,8 @@ int avc_ss_grant(security_id_t ssid, security_id_t tsid,
 		 security_class_t tclass, access_vector_t perms,
 		 uint32_t seqno)
 {
-	return 0;
+	return avc_control(AVC_CALLBACK_GRANT,
+			   ssid, tsid, tclass, perms, seqno, 0);
 }
 
 /**
@@ -413,7 +1092,8 @@ int avc_ss_try_revoke(security_id_t ssid, security_id_t tsid,
 		      access_vector_t perms, uint32_t seqno,
 		      access_vector_t * out_retained)
 {
-        return 0;
+	return avc_control(AVC_CALLBACK_TRY_REVOKE,
+			   ssid, tsid, tclass, perms, seqno, out_retained);
 }
 
 /**
@@ -431,7 +1111,8 @@ int avc_ss_revoke(security_id_t ssid, security_id_t tsid,
 		  security_class_t tclass, access_vector_t perms,
 		  uint32_t seqno)
 {
-        return 0;
+	return avc_control(AVC_CALLBACK_REVOKE,
+			   ssid, tsid, tclass, perms, seqno, 0);
 }
 
 /**
@@ -440,7 +1121,16 @@ int avc_ss_revoke(security_id_t ssid, security_id_t tsid,
  */
 int avc_ss_reset(uint32_t seqno)
 {
-        return 0;
+	int rc;
+
+	rc = avc_reset();
+
+	avc_get_lock(avc_lock);
+	if (seqno > avc_cache.latest_notif)
+		avc_cache.latest_notif = seqno;
+	avc_release_lock(avc_lock);
+
+	return rc;
 }
 
 /**
@@ -456,7 +1146,12 @@ int avc_ss_set_auditallow(security_id_t ssid, security_id_t tsid,
 			  security_class_t tclass, access_vector_t perms,
 			  uint32_t seqno, uint32_t enable)
 {
-        return 0;
+	if (enable)
+		return avc_control(AVC_CALLBACK_AUDITALLOW_ENABLE,
+				   ssid, tsid, tclass, perms, seqno, 0);
+	else
+		return avc_control(AVC_CALLBACK_AUDITALLOW_DISABLE,
+				   ssid, tsid, tclass, perms, seqno, 0);
 }
 
 /**
@@ -472,5 +1167,10 @@ int avc_ss_set_auditdeny(security_id_t ssid, security_id_t tsid,
 			 security_class_t tclass, access_vector_t perms,
 			 uint32_t seqno, uint32_t enable)
 {
-        return 0;
+	if (enable)
+		return avc_control(AVC_CALLBACK_AUDITDENY_ENABLE,
+				   ssid, tsid, tclass, perms, seqno, 0);
+	else
+		return avc_control(AVC_CALLBACK_AUDITDENY_DISABLE,
+				   ssid, tsid, tclass, perms, seqno, 0);
 }
diff --git a/libselinux/src/avc_internal.c b/libselinux/src/avc_internal.c
index ceb3d21..49cecc9 100644
--- a/libselinux/src/avc_internal.c
+++ b/libselinux/src/avc_internal.c
@@ -57,38 +57,237 @@ static int fd = -1;
 
 int avc_netlink_open(int blocking)
 {
-        return 0;
+	int len, rc = 0;
+	struct sockaddr_nl addr;
+
+	fd = socket(PF_NETLINK, SOCK_RAW | SOCK_CLOEXEC, NETLINK_SELINUX);
+	if (fd < 0) {
+		rc = fd;
+		goto out;
+	}
+	
+	if (!blocking && fcntl(fd, F_SETFL, O_NONBLOCK)) {
+		close(fd);
+		fd = -1;
+		rc = -1;
+		goto out;
+	}
+
+	len = sizeof(addr);
+
+	memset(&addr, 0, len);
+	addr.nl_family = AF_NETLINK;
+	addr.nl_groups = SELNL_GRP_AVC;
+
+	if (bind(fd, (struct sockaddr *)&addr, len) < 0) {
+		close(fd);
+		fd = -1;
+		rc = -1;
+		goto out;
+	}
+      out:
+	return rc;
 }
 
 void avc_netlink_close(void)
 {
+	if (fd >= 0)
+		close(fd);
+	fd = -1;
 }
 
 static int avc_netlink_receive(void *buf, unsigned buflen, int blocking)
 {
+	int rc;
+	struct pollfd pfd = { fd, POLLIN | POLLPRI, 0 };
+	struct sockaddr_nl nladdr;
+	socklen_t nladdrlen = sizeof nladdr;
+	struct nlmsghdr *nlh = (struct nlmsghdr *)buf;
+
+	do {
+		rc = poll(&pfd, 1, (blocking ? -1 : 0));
+	} while (rc < 0 && errno == EINTR);
+
+	if (rc == 0 && !blocking) {
+		errno = EWOULDBLOCK;
+		return -1;
+	}
+	else if (rc < 1) {
+		avc_log(SELINUX_ERROR, "%s:  netlink poll: error %d\n",
+			avc_prefix, errno);
+		return rc;
+	}
+
+	rc = recvfrom(fd, buf, buflen, 0, (struct sockaddr *)&nladdr,
+		      &nladdrlen);
+	if (rc < 0)
+		return rc;
+
+	if (nladdrlen != sizeof nladdr) {
+		avc_log(SELINUX_WARNING,
+			"%s:  warning: netlink address truncated, len %u?\n",
+			avc_prefix, nladdrlen);
+		return -1;
+	}
+
+	if (nladdr.nl_pid) {
+		avc_log(SELINUX_WARNING,
+			"%s:  warning: received spoofed netlink packet from: %u\n",
+			avc_prefix, nladdr.nl_pid);
+		return -1;
+	}
+
+	if (rc == 0) {
+		avc_log(SELINUX_WARNING,
+			"%s:  warning: received EOF on netlink socket\n",
+			avc_prefix);
+		errno = EBADFD;
+		return -1;
+	}
+
+	if (nlh->nlmsg_flags & MSG_TRUNC || nlh->nlmsg_len > (unsigned)rc) {
+		avc_log(SELINUX_WARNING,
+			"%s:  warning: incomplete netlink message\n",
+			avc_prefix);
+		return -1;
+	}
+
 	return 0;
 }
 
 static int avc_netlink_process(void *buf)
 {
+	int rc;
+	struct nlmsghdr *nlh = (struct nlmsghdr *)buf;
+
+	switch (nlh->nlmsg_type) {
+	case NLMSG_ERROR:{
+		struct nlmsgerr *err = NLMSG_DATA(nlh);
+
+		/* Netlink ack */
+		if (err->error == 0)
+			break;
+
+		errno = -err->error;
+		avc_log(SELINUX_ERROR,
+			"%s:  netlink error: %d\n", avc_prefix, errno);
+		return -1;
+	}
+
+	case SELNL_MSG_SETENFORCE:{
+		struct selnl_msg_setenforce *msg = NLMSG_DATA(nlh);
+		msg->val = !!msg->val;
+		avc_log(SELINUX_INFO,
+			"%s:  received setenforce notice (enforcing=%d)\n",
+			avc_prefix, msg->val);
+		if (avc_setenforce)
+			break;
+		avc_enforcing = msg->val;
+		if (avc_enforcing && (rc = avc_ss_reset(0)) < 0) {
+			avc_log(SELINUX_ERROR,
+				"%s:  cache reset returned %d (errno %d)\n",
+				avc_prefix, rc, errno);
+			return rc;
+		}
+		rc = selinux_netlink_setenforce(msg->val);
+		if (rc < 0)
+			return rc;
+		break;
+	}
+
+	case SELNL_MSG_POLICYLOAD:{
+		struct selnl_msg_policyload *msg = NLMSG_DATA(nlh);
+		avc_log(SELINUX_INFO,
+			"%s:  received policyload notice (seqno=%u)\n",
+			avc_prefix, msg->seqno);
+		rc = avc_ss_reset(msg->seqno);
+		if (rc < 0) {
+			avc_log(SELINUX_ERROR,
+				"%s:  cache reset returned %d (errno %d)\n",
+				avc_prefix, rc, errno);
+			return rc;
+		}
+		rc = selinux_netlink_policyload(msg->seqno);
+		if (rc < 0)
+			return rc;
+		break;
+	}
+
+	default:
+		avc_log(SELINUX_WARNING,
+			"%s:  warning: unknown netlink message %d\n",
+			avc_prefix, nlh->nlmsg_type);
+	}
 	return 0;
 }
 
 int avc_netlink_check_nb(void)
 {
-        return 0;
+	int rc;
+	char buf[1024] __attribute__ ((aligned));
+
+	while (1) {
+		errno = 0;
+		rc = avc_netlink_receive(buf, sizeof(buf), 0);
+		if (rc < 0) {
+			if (errno == EWOULDBLOCK)
+				return 0;
+			if (errno == 0 || errno == EINTR)
+				continue;
+			else {
+				avc_log(SELINUX_ERROR,
+					"%s:  netlink recvfrom: error %d\n",
+					avc_prefix, errno);
+				return rc;
+			}
+		}
+
+		(void)avc_netlink_process(buf);
+	}
+	return 0;
 }
 
 /* run routine for the netlink listening thread */
 void avc_netlink_loop(void)
 {
+	int rc;
+	char buf[1024] __attribute__ ((aligned));
+
+	while (1) {
+		errno = 0;
+		rc = avc_netlink_receive(buf, sizeof(buf), 1);
+		if (rc < 0) {
+			if (errno == 0 || errno == EINTR)
+				continue;
+			else {
+				avc_log(SELINUX_ERROR,
+					"%s:  netlink recvfrom: error %d\n",
+					avc_prefix, errno);
+				break;
+			}
+		}
+
+		rc = avc_netlink_process(buf);
+		if (rc < 0)
+			break;
+	}
+
+	close(fd);
+	fd = -1;
+	avc_netlink_trouble = 1;
+	avc_log(SELINUX_ERROR,
+		"%s:  netlink thread: errors encountered, terminating\n",
+		avc_prefix);
 }
 
 int avc_netlink_acquire_fd(void)
 {
-        return 0;
+    avc_app_main_loop = 1;
+
+    return fd;
 }
 
 void avc_netlink_release_fd(void)
 {
+    avc_app_main_loop = 0;
 }
diff --git a/libselinux/src/avc_sidtab.c b/libselinux/src/avc_sidtab.c
index eb73099..9669264 100644
--- a/libselinux/src/avc_sidtab.c
+++ b/libselinux/src/avc_sidtab.c
@@ -15,30 +15,138 @@
 
 static inline unsigned sidtab_hash(const char * key)
 {
-        return 0;
+	char *p, *keyp;
+	unsigned int size;
+	unsigned int val;
+
+	val = 0;
+	keyp = (char *)key;
+	size = strlen(keyp);
+	for (p = keyp; (unsigned int)(p - keyp) < size; p++)
+		val =
+		    (val << 4 | (val >> (8 * sizeof(unsigned int) - 4))) ^ (*p);
+	return val & (SIDTAB_SIZE - 1);
 }
 
 int sidtab_init(struct sidtab *s)
 {
-        return 0;
+	int i, rc = 0;
+
+	s->htable = (struct sidtab_node **)avc_malloc
+	    (sizeof(struct sidtab_node *) * SIDTAB_SIZE);
+
+	if (!s->htable) {
+		rc = -1;
+		goto out;
+	}
+	for (i = 0; i < SIDTAB_SIZE; i++)
+		s->htable[i] = NULL;
+	s->nel = 0;
+      out:
+	return rc;
 }
 
 int sidtab_insert(struct sidtab *s, const char * ctx)
 {
-	return 0;
+	int hvalue, rc = 0;
+	struct sidtab_node *newnode;
+	char * newctx;
+
+	newnode = (struct sidtab_node *)avc_malloc(sizeof(*newnode));
+	if (!newnode) {
+		rc = -1;
+		goto out;
+	}
+	newctx = (char *) strdup(ctx);
+	if (!newctx) {
+		rc = -1;
+		avc_free(newnode);
+		goto out;
+	}
+
+	hvalue = sidtab_hash(newctx);
+	newnode->next = s->htable[hvalue];
+	newnode->sid_s.ctx = newctx;
+	newnode->sid_s.refcnt = 1;	/* unused */
+	s->htable[hvalue] = newnode;
+	s->nel++;
+      out:
+	return rc;
 }
 
 int
 sidtab_context_to_sid(struct sidtab *s,
 		      const char * ctx, security_id_t * sid)
 {
-	return 0;
+	int hvalue, rc = 0;
+	struct sidtab_node *cur;
+
+	*sid = NULL;
+	hvalue = sidtab_hash(ctx);
+
+      loop:
+	cur = s->htable[hvalue];
+	while (cur != NULL && strcmp(cur->sid_s.ctx, ctx))
+		cur = cur->next;
+
+	if (cur == NULL) {	/* need to make a new entry */
+		rc = sidtab_insert(s, ctx);
+		if (rc)
+			goto out;
+		goto loop;	/* find the newly inserted node */
+	}
+
+	*sid = &cur->sid_s;
+      out:
+	return rc;
 }
 
 void sidtab_sid_stats(struct sidtab *h, char *buf, int buflen)
 {
+	int i, chain_len, slots_used, max_chain_len;
+	struct sidtab_node *cur;
+
+	slots_used = 0;
+	max_chain_len = 0;
+	for (i = 0; i < SIDTAB_SIZE; i++) {
+		cur = h->htable[i];
+		if (cur) {
+			slots_used++;
+			chain_len = 0;
+			while (cur) {
+				chain_len++;
+				cur = cur->next;
+			}
+
+			if (chain_len > max_chain_len)
+				max_chain_len = chain_len;
+		}
+	}
+
+	snprintf(buf, buflen,
+		 "%s:  %u SID entries and %d/%d buckets used, longest "
+		 "chain length %d\n", avc_prefix, h->nel, slots_used,
+		 SIDTAB_SIZE, max_chain_len);
 }
 
 void sidtab_destroy(struct sidtab *s)
 {
+	int i;
+	struct sidtab_node *cur, *temp;
+
+	if (!s)
+		return;
+
+	for (i = 0; i < SIDTAB_SIZE; i++) {
+		cur = s->htable[i];
+		while (cur != NULL) {
+			temp = cur;
+			cur = cur->next;
+			freecon(temp->sid_s.ctx);
+			avc_free(temp);
+		}
+		s->htable[i] = NULL;
+	}
+	avc_free(s->htable);
+	s->htable = NULL;
 }
diff --git a/libselinux/src/booleans.c b/libselinux/src/booleans.c
index 1fce8d3..ba9d934 100644
--- a/libselinux/src/booleans.c
+++ b/libselinux/src/booleans.c
@@ -29,72 +29,535 @@
 
 static int filename_select(const struct dirent *d)
 {
-	return 0;
+	if (d->d_name[0] == '.'
+	    && (d->d_name[1] == '\0'
+		|| (d->d_name[1] == '.' && d->d_name[2] == '\0')))
+		return 0;
+	return 1;
 }
 
 int security_get_boolean_names(char ***names, int *len)
 {
-        return 0;
+	char path[PATH_MAX];
+	int i, rc;
+	struct dirent **namelist;
+	char **n;
+
+	if (!len || names == NULL) {
+		errno = EINVAL;
+		return -1;
+	}
+	if (!selinux_mnt) {
+		errno = ENOENT;
+		return -1;
+	}
+
+	snprintf(path, sizeof path, "%s%s", selinux_mnt, SELINUX_BOOL_DIR);
+	*len = scandir(path, &namelist, &filename_select, alphasort);
+	if (*len <= 0) {
+		return -1;
+	}
+
+	n = (char **)malloc(sizeof(char *) * *len);
+	if (!n) {
+		rc = -1;
+		goto bad;
+	}
+
+	for (i = 0; i < *len; i++) {
+		n[i] = strdup(namelist[i]->d_name);
+		if (!n[i]) {
+			rc = -1;
+			goto bad_freen;
+		}
+	}
+	rc = 0;
+	*names = n;
+      out:
+	for (i = 0; i < *len; i++) {
+		free(namelist[i]);
+	}
+	free(namelist);
+	return rc;
+      bad_freen:
+	for (--i; i >= 0; --i)
+		free(n[i]);
+	free(n);
+      bad:
+	goto out;
 }
 
 char *selinux_boolean_sub(const char *name)
 {
-	return NULL;
+	char *sub = NULL;
+	char *line_buf = NULL;
+	size_t line_len;
+	FILE *cfg;
+
+	if (!name)
+		return NULL;
+
+	cfg = fopen(selinux_booleans_subs_path(), "r");
+	if (!cfg)
+		goto out;
+
+	while (getline(&line_buf, &line_len, cfg) != -1) {
+		char *ptr;
+		char *src = line_buf;
+		char *dst;
+		while (*src && isspace(*src))
+			src++;
+		if (!*src)
+			continue;
+		if (src[0] == '#')
+			continue;
+
+		ptr = src;
+		while (*ptr && !isspace(*ptr))
+			ptr++;
+		*ptr++ = '\0';
+		if (strcmp(src, name) != 0)
+			continue;
+
+		dst = ptr;
+		while (*dst && isspace(*dst))
+			dst++;
+		if (!*dst)
+			continue;
+		ptr=dst;
+		while (*ptr && !isspace(*ptr))
+			ptr++;
+		*ptr='\0';
+
+		sub = strdup(dst);
+
+		break;
+	}
+	free(line_buf);
+	fclose(cfg);
+out:
+	if (!sub)
+		sub = strdup(name);
+	return sub;
 }
 
 static int bool_open(const char *name, int flag) {
-	return 0;
+	char *fname = NULL;
+	char *alt_name = NULL;
+	int len;
+	int fd = -1;
+	int ret;
+	char *ptr;
+
+	if (!name) {
+		errno = EINVAL;
+		return -1;
+	}
+
+	/* note the 'sizeof' gets us enough room for the '\0' */
+	len = strlen(name) + strlen(selinux_mnt) + sizeof(SELINUX_BOOL_DIR);
+	fname = malloc(sizeof(char) * len);
+	if (!fname)
+		return -1;
+
+	ret = snprintf(fname, len, "%s%s%s", selinux_mnt, SELINUX_BOOL_DIR, name);
+	if (ret < 0)
+		goto out;
+	assert(ret < len);
+
+	fd = open(fname, flag);
+	if (fd >= 0 || errno != ENOENT)
+		goto out;
+
+	alt_name = selinux_boolean_sub(name);
+	if (!alt_name)
+		goto out;
+
+	/* note the 'sizeof' gets us enough room for the '\0' */
+	len = strlen(alt_name) + strlen(selinux_mnt) + sizeof(SELINUX_BOOL_DIR);
+	ptr = realloc(fname, len);
+	if (!ptr)
+		goto out;
+	fname = ptr;
+
+	ret = snprintf(fname, len, "%s%s%s", selinux_mnt, SELINUX_BOOL_DIR, alt_name);
+	if (ret < 0)
+		goto out;
+	assert(ret < len);
+
+	fd = open(fname, flag);
+out:
+	free(fname);
+	free(alt_name);
+
+	return fd;
 }
 
 #define STRBUF_SIZE 3
 static int get_bool_value(const char *name, char **buf)
 {
+	int fd, len;
+	int errno_tmp;
+
+	if (!selinux_mnt) {
+		errno = ENOENT;
+		return -1;
+	}
+
+	*buf = malloc(sizeof(char) * (STRBUF_SIZE + 1));
+	if (!*buf)
+		return -1;
+
+	(*buf)[STRBUF_SIZE] = 0;
+
+	fd = bool_open(name, O_RDONLY);
+	if (fd < 0)
+		goto out_err;
+
+	len = read(fd, *buf, STRBUF_SIZE);
+	errno_tmp = errno;
+	close(fd);
+	errno = errno_tmp;
+	if (len != STRBUF_SIZE)
+		goto out_err;
+
 	return 0;
+out_err:
+	free(*buf);
+	return -1;
 }
 
 int security_get_boolean_pending(const char *name)
 {
-	return 0;
+	char *buf;
+	int val;
+
+	if (get_bool_value(name, &buf))
+		return -1;
+
+	if (atoi(&buf[1]))
+		val = 1;
+	else
+		val = 0;
+	free(buf);
+	return val;
 }
 
 int security_get_boolean_active(const char *name)
 {
-	return 0;
+	char *buf;
+	int val;
+
+	if (get_bool_value(name, &buf))
+		return -1;
+
+	buf[1] = '\0';
+	if (atoi(buf))
+		val = 1;
+	else
+		val = 0;
+	free(buf);
+	return val;
 }
 
 int security_set_boolean(const char *name, int value)
 {
-	return 0;
+	int fd, ret;
+	char buf[2];
+
+	if (!selinux_mnt) {
+		errno = ENOENT;
+		return -1;
+	}
+	if (value < 0 || value > 1) {
+		errno = EINVAL;
+		return -1;
+	}
+
+	fd = bool_open(name, O_WRONLY);
+	if (fd < 0)
+		return -1;
+
+	if (value)
+		buf[0] = '1';
+	else
+		buf[0] = '0';
+	buf[1] = '\0';
+
+	ret = write(fd, buf, 2);
+	close(fd);
+
+	if (ret > 0)
+		return 0;
+	else
+		return -1;
 }
 
 int security_commit_booleans(void)
 {
-        return 0;
+	int fd, ret;
+	char buf[2];
+	char path[PATH_MAX];
+
+	if (!selinux_mnt) {
+		errno = ENOENT;
+		return -1;
+	}
+
+	snprintf(path, sizeof path, "%s/commit_pending_bools", selinux_mnt);
+	fd = open(path, O_WRONLY);
+	if (fd < 0)
+		return -1;
+
+	buf[0] = '1';
+	buf[1] = '\0';
+
+	ret = write(fd, buf, 2);
+	close(fd);
+
+	if (ret > 0)
+		return 0;
+	else
+		return -1;
 }
 
 static char *strtrim(char *dest, char *source, int size)
 {
-	return NULL;
+	int i = 0;
+	char *ptr = source;
+	i = 0;
+	while (isspace(*ptr) && i < size) {
+		ptr++;
+		i++;
+	}
+	strncpy(dest, ptr, size);
+	for (i = strlen(dest) - 1; i > 0; i--) {
+		if (!isspace(dest[i]))
+			break;
+	}
+	dest[i + 1] = '\0';
+	return dest;
 }
 static int process_boolean(char *buffer, char *name, int namesize, int *val)
 {
-	return 0;
+	char name1[BUFSIZ];
+	char *ptr = NULL;
+	char *tok = strtok_r(buffer, "=", &ptr);
+	if (tok) {
+		strncpy(name1, tok, BUFSIZ - 1);
+		strtrim(name, name1, namesize - 1);
+		if (name[0] == '#')
+			return 0;
+		tok = strtok_r(NULL, "\0", &ptr);
+		if (tok) {
+			while (isspace(*tok))
+				tok++;
+			*val = -1;
+			if (isdigit(tok[0]))
+				*val = atoi(tok);
+			else if (!strncasecmp(tok, "true", sizeof("true") - 1))
+				*val = 1;
+			else if (!strncasecmp
+				 (tok, "false", sizeof("false") - 1))
+				*val = 0;
+			if (*val != 0 && *val != 1) {
+				errno = EINVAL;
+				return -1;
+			}
+
+		}
+	}
+	return 1;
 }
 static int save_booleans(size_t boolcnt, SELboolean * boollist)
 {
+	ssize_t len;
+	size_t i;
+	char outbuf[BUFSIZ];
+	char *inbuf = NULL;
+
+	/* Open file */
+	const char *bool_file = selinux_booleans_path();
+	char local_bool_file[PATH_MAX];
+	char tmp_bool_file[PATH_MAX];
+	FILE *boolf;
+	int fd;
+	int *used = (int *)malloc(sizeof(int) * boolcnt);
+	if (!used) {
+		return -1;
+	}
+	/* zero out used field */
+	for (i = 0; i < boolcnt; i++)
+		used[i] = 0;
+
+	snprintf(tmp_bool_file, sizeof(tmp_bool_file), "%s.XXXXXX", bool_file);
+	fd = mkstemp(tmp_bool_file);
+	if (fd < 0) {
+		free(used);
+		return -1;
+	}
+
+	snprintf(local_bool_file, sizeof(local_bool_file), "%s.local",
+		 bool_file);
+	boolf = fopen(local_bool_file, "r");
+	if (boolf != NULL) {
+		ssize_t ret;
+		size_t size = 0;
+		int val;
+		char boolname[BUFSIZ];
+		char *buffer;
+		inbuf = NULL;
+		__fsetlocking(boolf, FSETLOCKING_BYCALLER);
+		while ((len = getline(&inbuf, &size, boolf)) > 0) {
+			buffer = strdup(inbuf);
+			if (!buffer)
+				goto close_remove_fail;
+			ret =
+			    process_boolean(inbuf, boolname, sizeof(boolname),
+					    &val);
+			if (ret != 1) {
+				ret = write(fd, buffer, len);
+				free(buffer);
+				if (ret != len)
+					goto close_remove_fail;
+			} else {
+				free(buffer);
+				for (i = 0; i < boolcnt; i++) {
+					if (strcmp(boollist[i].name, boolname)
+					    == 0) {
+						snprintf(outbuf, sizeof(outbuf),
+							 "%s=%d\n", boolname,
+							 boollist[i].value);
+						len = strlen(outbuf);
+						used[i] = 1;
+						if (write(fd, outbuf, len) !=
+						    len)
+							goto close_remove_fail;
+						else
+							break;
+					}
+				}
+				if (i == boolcnt) {
+					snprintf(outbuf, sizeof(outbuf),
+						 "%s=%d\n", boolname, val);
+					len = strlen(outbuf);
+					if (write(fd, outbuf, len) != len)
+						goto close_remove_fail;
+				}
+			}
+			free(inbuf);
+			inbuf = NULL;
+		}
+		fclose(boolf);
+	}
+
+	for (i = 0; i < boolcnt; i++) {
+		if (used[i] == 0) {
+			snprintf(outbuf, sizeof(outbuf), "%s=%d\n",
+				 boollist[i].name, boollist[i].value);
+			len = strlen(outbuf);
+			if (write(fd, outbuf, len) != len) {
+			      close_remove_fail:
+				free(inbuf);
+				close(fd);
+			      remove_fail:
+				unlink(tmp_bool_file);
+				free(used);
+				return -1;
+			}
+		}
+
+	}
+	if (fchmod(fd, S_IRUSR | S_IWUSR) != 0)
+		goto close_remove_fail;
+	close(fd);
+	if (rename(tmp_bool_file, local_bool_file) != 0)
+		goto remove_fail;
+
+	free(used);
 	return 0;
 }
 static void rollback(SELboolean * boollist, int end)
 {
+	int i;
+
+	for (i = 0; i < end; i++)
+		security_set_boolean(boollist[i].name,
+				     security_get_boolean_active(boollist[i].
+								 name));
 }
 
 int security_set_boolean_list(size_t boolcnt, SELboolean * boollist,
 			      int permanent)
 {
+
+	size_t i;
+	for (i = 0; i < boolcnt; i++) {
+		if (security_set_boolean(boollist[i].name, boollist[i].value)) {
+			rollback(boollist, i);
+			return -1;
+		}
+	}
+
+	/* OK, let's do the commit */
+	if (security_commit_booleans()) {
+		return -1;
+	}
+
+	if (permanent)
+		return save_booleans(boolcnt, boollist);
+
 	return 0;
 }
 int security_load_booleans(char *path)
-	return0;
+{
+	FILE *boolf;
+	char *inbuf;
+	char localbools[BUFSIZ];
+	size_t len = 0, errors = 0;
+	int val;
+	char name[BUFSIZ];
+
+	boolf = fopen(path ? path : selinux_booleans_path(), "r");
+	if (boolf == NULL)
+		goto localbool;
+
+	__fsetlocking(boolf, FSETLOCKING_BYCALLER);
+	while (getline(&inbuf, &len, boolf) > 0) {
+		int ret = process_boolean(inbuf, name, sizeof(name), &val);
+		if (ret == -1)
+			errors++;
+		if (ret == 1)
+			if (security_set_boolean(name, val) < 0) {
+				errors++;
+			}
+	}
+	fclose(boolf);
+      localbool:
+	snprintf(localbools, sizeof(localbools), "%s.local",
+		 (path ? path : selinux_booleans_path()));
+	boolf = fopen(localbools, "r");
+
+	if (boolf != NULL) {
+		int ret;
+		__fsetlocking(boolf, FSETLOCKING_BYCALLER);
+		while (getline(&inbuf, &len, boolf) > 0) {
+			ret = process_boolean(inbuf, name, sizeof(name), &val);
+			if (ret == -1)
+				errors++;
+			if (ret == 1)
+				if (security_set_boolean(name, val) < 0) {
+					errors++;
+				}
+		}
+		fclose(boolf);
+	}
+	if (security_commit_booleans() < 0)
+		return -1;
+
+	if (errors)
+		errno = EINVAL;
+	return errors ? -1 : 0;
 }
 
 #else
@@ -106,39 +569,39 @@ int security_set_boolean_list(size_t boolcnt __attribute__((unused)),
 	SELboolean * boollist __attribute__((unused)),
 	int permanent __attribute__((unused)))
 {
-	return 0;
+	return -1;
 }
 
 int security_load_booleans(char *path __attribute__((unused)))
 {
-	return 0;
+	return -1;
 }
 
 int security_get_boolean_names(char ***names __attribute__((unused)),
 	int *len __attribute__((unused)))
 {
-	return 0;
+	return -1;
 }
 
 int security_get_boolean_pending(const char *name __attribute__((unused)))
 {
-	return 0;
+	return -1;
 }
 
 int security_get_boolean_active(const char *name __attribute__((unused)))
 {
-	return 0;
+	return -1;
 }
 
 int security_set_boolean(const char *name __attribute__((unused)),
 	int value __attribute__((unused)))
 {
-	return 0;
+	return -1;
 }
 
 int security_commit_booleans(void)
 {
-	return 0;
+	return -1;
 }
 
 char *selinux_boolean_sub(const char *name __attribute__((unused)))
diff --git a/libselinux/src/callbacks.c b/libselinux/src/callbacks.c
index 0911dd8..c18ccc5 100644
--- a/libselinux/src/callbacks.c
+++ b/libselinux/src/callbacks.c
@@ -14,7 +14,12 @@
 static int __attribute__ ((format(printf, 2, 3)))
 default_selinux_log(int type __attribute__((unused)), const char *fmt, ...)
 {
-	return 0;
+	int rc;
+	va_list ap;
+	va_start(ap, fmt);
+	rc = vfprintf(stderr, fmt, ap);
+	va_end(ap);
+	return rc;
 }
 
 static int
@@ -74,6 +79,23 @@ int
 void
 selinux_set_callback(int type, union selinux_callback cb)
 {
+	switch (type) {
+	case SELINUX_CB_LOG:
+		selinux_log = cb.func_log;
+		break;
+	case SELINUX_CB_AUDIT:
+		selinux_audit = cb.func_audit;
+		break;
+	case SELINUX_CB_VALIDATE:
+		selinux_validate = cb.func_validate;
+		break;
+	case SELINUX_CB_SETENFORCE:
+		selinux_netlink_setenforce = cb.func_setenforce;
+		break;
+	case SELINUX_CB_POLICYLOAD:
+		selinux_netlink_policyload = cb.func_policyload;
+		break;
+	}
 }
 
 /* callback getting function */
@@ -81,10 +103,27 @@ union selinux_callback
 selinux_get_callback(int type)
 {
 	union selinux_callback cb;
-        cb.func_log = NULL;
-        cb.func_audit = NULL;
-        cb.func_validate = NULL;
-        cb.func_setenforce = NULL;
-        cb.func_policyload = NULL;
+
+	switch (type) {
+	case SELINUX_CB_LOG:
+		cb.func_log = selinux_log;
+		break;
+	case SELINUX_CB_AUDIT:
+		cb.func_audit = selinux_audit;
+		break;
+	case SELINUX_CB_VALIDATE:
+		cb.func_validate = selinux_validate;
+		break;
+	case SELINUX_CB_SETENFORCE:
+		cb.func_setenforce = selinux_netlink_setenforce;
+		break;
+	case SELINUX_CB_POLICYLOAD:
+		cb.func_policyload = selinux_netlink_policyload;
+		break;
+	default:
+		memset(&cb, 0, sizeof(cb));
+		errno = EINVAL;
+		break;
+	}
 	return cb;
 }
diff --git a/libselinux/src/canonicalize_context.c b/libselinux/src/canonicalize_context.c
index 9c9557f..7cf3139 100644
--- a/libselinux/src/canonicalize_context.c
+++ b/libselinux/src/canonicalize_context.c
@@ -12,7 +12,52 @@
 int security_canonicalize_context_raw(const char * con,
 				      char ** canoncon)
 {
-        return 0;
+	char path[PATH_MAX];
+	char *buf;
+	size_t size;
+	int fd, ret;
+
+	if (!selinux_mnt) {
+		errno = ENOENT;
+		return -1;
+	}
+
+	snprintf(path, sizeof path, "%s/context", selinux_mnt);
+	fd = open(path, O_RDWR);
+	if (fd < 0)
+		return -1;
+
+	size = selinux_page_size;
+	buf = malloc(size);
+	if (!buf) {
+		ret = -1;
+		goto out;
+	}
+	strncpy(buf, con, size);
+
+	ret = write(fd, buf, strlen(buf) + 1);
+	if (ret < 0)
+		goto out2;
+
+	memset(buf, 0, size);
+	ret = read(fd, buf, size - 1);
+	if (ret < 0 && errno == EINVAL) {
+		/* Fall back to the original context for kernels
+		   that do not support the extended interface. */
+		strncpy(buf, con, size);
+	}
+
+	*canoncon = strdup(buf);
+	if (!(*canoncon)) {
+		ret = -1;
+		goto out2;
+	}
+	ret = 0;
+      out2:
+	free(buf);
+      out:
+	close(fd);
+	return ret;
 }
 
 hidden_def(security_canonicalize_context_raw)
@@ -20,7 +65,22 @@ hidden_def(security_canonicalize_context_raw)
 int security_canonicalize_context(const char * con,
 				      char ** canoncon)
 {
-        return 0;
+	int ret;
+	char * rcon;
+	char * rcanoncon;
+
+	if (selinux_trans_to_raw_context(con, &rcon))
+		return -1;
+
+	ret = security_canonicalize_context_raw(rcon, &rcanoncon);
+
+	freecon(rcon);
+	if (!ret) {
+		ret = selinux_raw_to_trans_context(rcanoncon, canoncon);
+		freecon(rcanoncon);
+	}
+
+	return ret;
 }
 
 hidden_def(security_canonicalize_context)
diff --git a/libselinux/src/checkAccess.c b/libselinux/src/checkAccess.c
index 2fef20f..8de5747 100644
--- a/libselinux/src/checkAccess.c
+++ b/libselinux/src/checkAccess.c
@@ -17,25 +17,102 @@ static int avc_reset_callback(uint32_t event __attribute__((unused)),
 		      access_vector_t perms __attribute__((unused)),
 		      access_vector_t *out_retained __attribute__((unused)))
 {
+	flush_class_cache();
 	return 0;
 }
 
 static void avc_init_once(void)
 {
+	selinux_enabled = is_selinux_enabled();
+	if (selinux_enabled == 1) {
+		if (avc_open(NULL, 0))
+			return;
+		avc_add_callback(avc_reset_callback, AVC_CALLBACK_RESET,
+				 0, 0, 0, 0);
+	}
 }
 
 int selinux_check_access(const char *scon, const char *tcon, const char *class, const char *perm, void *aux) {
+	int rc;
+	security_id_t scon_id;
+	security_id_t tcon_id;
+	security_class_t sclass;
+	access_vector_t av;
+
+	__selinux_once(once, avc_init_once);
+
+	if (selinux_enabled != 1)
 		return 0;
+
+	rc = avc_context_to_sid(scon, &scon_id);
+	if (rc < 0)
+		return rc;
+
+	rc = avc_context_to_sid(tcon, &tcon_id);
+	if (rc < 0)
+		return rc;
+
+	(void) avc_netlink_check_nb();
+
+       sclass = string_to_security_class(class);
+       if (sclass == 0) {
+	       rc = errno;
+	       avc_log(SELINUX_ERROR, "Unknown class %s", class);
+	       if (security_deny_unknown() == 0)
+		       return 0;
+	       errno = rc;
+	       return -1;
+       }
+
+       av = string_to_av_perm(sclass, perm);
+       if (av == 0) {
+	       rc = errno;
+	       avc_log(SELINUX_ERROR, "Unknown permission %s for class %s", perm, class);
+	       if (security_deny_unknown() == 0)
+		       return 0;
+	       errno = rc;
+	       return -1;
+       }
+
+       return avc_has_perm (scon_id, tcon_id, sclass, av, NULL, aux);
 }
 
 int selinux_check_passwd_access(access_vector_t requested)
 {
+	int status = -1;
+	char *user_context;
+	if (is_selinux_enabled() == 0)
 		return 0;
+	if (getprevcon_raw(&user_context) == 0) {
+		security_class_t passwd_class;
+		struct av_decision avd;
+		int retval;
+
+		passwd_class = string_to_security_class("passwd");
+		if (passwd_class == 0)
+			return 0;
+
+		retval = security_compute_av_raw(user_context,
+						     user_context,
+						     passwd_class,
+						     requested,
+						     &avd);
+
+		if ((retval == 0) && ((requested & avd.allowed) == requested)) {
+			status = 0;
+		}
+		freecon(user_context);
+	}
+
+	if (status != 0 && security_getenforce() == 0)
+		status = 0;
+
+	return status;
 }
 
 hidden_def(selinux_check_passwd_access)
 
 int checkPasswdAccess(access_vector_t requested)
 {
-	return 0;
+	return selinux_check_passwd_access(requested);
 }
diff --git a/libselinux/src/check_context.c b/libselinux/src/check_context.c
index edb3be7..52063fa 100644
--- a/libselinux/src/check_context.c
+++ b/libselinux/src/check_context.c
@@ -11,6 +11,23 @@
 
 int security_check_context_raw(const char * con)
 {
+	char path[PATH_MAX];
+	int fd, ret;
+
+	if (!selinux_mnt) {
+		errno = ENOENT;
+		return -1;
+	}
+
+	snprintf(path, sizeof path, "%s/context", selinux_mnt);
+	fd = open(path, O_RDWR);
+	if (fd < 0)
+		return -1;
+
+	ret = write(fd, con, strlen(con) + 1);
+	close(fd);
+	if (ret < 0)
+		return -1;
 	return 0;
 }
 
@@ -18,7 +35,17 @@ hidden_def(security_check_context_raw)
 
 int security_check_context(const char * con)
 {
-        return 0;
+	int ret;
+	char * rcon;
+
+	if (selinux_trans_to_raw_context(con, &rcon))
+		return -1;
+
+	ret = security_check_context_raw(rcon);
+
+	freecon(rcon);
+
+	return ret;
 }
 
 hidden_def(security_check_context)
diff --git a/libselinux/src/compute_av.c b/libselinux/src/compute_av.c
index 82afd98..937e5c3 100644
--- a/libselinux/src/compute_av.c
+++ b/libselinux/src/compute_av.c
@@ -16,7 +16,60 @@ int security_compute_av_flags_raw(const char * scon,
 				  access_vector_t requested,
 				  struct av_decision *avd)
 {
-        return 0;
+	char path[PATH_MAX];
+	char *buf;
+	size_t len;
+	int fd, ret;
+
+	if (!selinux_mnt) {
+		errno = ENOENT;
+		return -1;
+	}
+
+	snprintf(path, sizeof path, "%s/access", selinux_mnt);
+	fd = open(path, O_RDWR);
+	if (fd < 0)
+		return -1;
+
+	len = selinux_page_size;
+	buf = malloc(len);
+	if (!buf) {
+		ret = -1;
+		goto out;
+	}
+
+	snprintf(buf, len, "%s %s %hu %x", scon, tcon,
+		 unmap_class(tclass), unmap_perm(tclass, requested));
+
+	ret = write(fd, buf, strlen(buf));
+	if (ret < 0)
+		goto out2;
+
+	memset(buf, 0, len);
+	ret = read(fd, buf, len - 1);
+	if (ret < 0)
+		goto out2;
+
+	ret = sscanf(buf, "%x %x %x %x %u %x",
+		     &avd->allowed, &avd->decided,
+		     &avd->auditallow, &avd->auditdeny,
+		     &avd->seqno, &avd->flags);
+	if (ret < 5) {
+		ret = -1;
+		goto out2;
+	} else if (ret < 6)
+		avd->flags = 0;
+
+	/* If tclass invalid, kernel sets avd according to deny_unknown flag */
+	if (tclass != 0)
+		map_decision(tclass, avd);
+
+	ret = 0;
+      out2:
+	free(buf);
+      out:
+	close(fd);
+	return ret;
 }
 
 hidden_def(security_compute_av_flags_raw)
@@ -27,7 +80,23 @@ int security_compute_av_raw(const char * scon,
 			    access_vector_t requested,
 			    struct av_decision *avd)
 {
-        return 0;
+	struct av_decision lavd;
+	int ret;
+
+	ret = security_compute_av_flags_raw(scon, tcon, tclass,
+					    requested, &lavd);
+	if (ret == 0) {
+		avd->allowed = lavd.allowed;
+		avd->decided = lavd.decided;
+		avd->auditallow = lavd.auditallow;
+		avd->auditdeny = lavd.auditdeny;
+		avd->seqno = lavd.seqno;
+		/* NOTE:
+		 * We should not return avd->flags via the interface
+		 * due to the binary compatibility.
+		 */
+	}
+	return ret;
 }
 
 hidden_def(security_compute_av_raw)
@@ -38,7 +107,23 @@ int security_compute_av_flags(const char * scon,
 			      access_vector_t requested,
 			      struct av_decision *avd)
 {
-        return 0;
+	char * rscon;
+	char * rtcon;
+	int ret;
+
+	if (selinux_trans_to_raw_context(scon, &rscon))
+		return -1;
+	if (selinux_trans_to_raw_context(tcon, &rtcon)) {
+		freecon(rscon);
+		return -1;
+	}
+	ret = security_compute_av_flags_raw(rscon, rtcon, tclass,
+					    requested, avd);
+
+	freecon(rscon);
+	freecon(rtcon);
+
+	return ret;
 }
 
 hidden_def(security_compute_av_flags)
@@ -48,7 +133,25 @@ int security_compute_av(const char * scon,
 			security_class_t tclass,
 			access_vector_t requested, struct av_decision *avd)
 {
-        return 0;
+	struct av_decision lavd;
+	int ret;
+
+	ret = security_compute_av_flags(scon, tcon, tclass,
+					requested, &lavd);
+	if (ret == 0)
+	{
+		avd->allowed = lavd.allowed;
+		avd->decided = lavd.decided;
+		avd->auditallow = lavd.auditallow;
+		avd->auditdeny = lavd.auditdeny;
+		avd->seqno = lavd.seqno;
+		/* NOTE:
+		 * We should not return avd->flags via the interface
+		 * due to the binary compatibility.
+		 */
+	}
+
+	return ret;
 }
 
 hidden_def(security_compute_av)
diff --git a/libselinux/src/compute_create.c b/libselinux/src/compute_create.c
index c955b56..9559d42 100644
--- a/libselinux/src/compute_create.c
+++ b/libselinux/src/compute_create.c
@@ -13,7 +13,39 @@
 
 static int object_name_encode(const char *objname, char *buffer, size_t buflen)
 {
-        return 0;
+	int	code;
+	size_t	offset = 0;
+
+	if (buflen - offset < 1)
+		return -1;
+	buffer[offset++] = ' ';
+
+	do {
+		code = *objname++;
+
+		if (isalnum(code) || code == '\0' || code == '-' ||
+		    code == '.' || code == '_' || code == '~') {
+			if (buflen - offset < 1)
+				return -1;
+			buffer[offset++] = code;
+		} else if (code == ' ') {
+			if (buflen - offset < 1)
+				return -1;
+			buffer[offset++] = '+';
+		} else {
+			static const char *table = "0123456789ABCDEF";
+			int	l = (code & 0x0f);
+			int	h = (code & 0xf0) >> 4;
+
+			if (buflen - offset < 3)
+				return -1;
+			buffer[offset++] = '%';
+			buffer[offset++] = table[h];
+			buffer[offset++] = table[l];
+		}
+	} while (code != '\0');
+
+	return 0;
 }
 
 int security_compute_create_name_raw(const char * scon,
@@ -22,7 +54,56 @@ int security_compute_create_name_raw(const char * scon,
 				     const char *objname,
 				     char ** newcon)
 {
-        return 0;
+	char path[PATH_MAX];
+	char *buf;
+	size_t size;
+	int fd, ret, len;
+
+	if (!selinux_mnt) {
+		errno = ENOENT;
+		return -1;
+	}
+
+	snprintf(path, sizeof path, "%s/create", selinux_mnt);
+	fd = open(path, O_RDWR);
+	if (fd < 0)
+		return -1;
+
+	size = selinux_page_size;
+	buf = malloc(size);
+	if (!buf) {
+		ret = -1;
+		goto out;
+	}
+	len = snprintf(buf, size, "%s %s %hu",
+		       scon, tcon, unmap_class(tclass));
+	if (objname &&
+	    object_name_encode(objname, buf + len, size - len) < 0) {
+		errno = ENAMETOOLONG;
+		ret = -1;
+		goto out2;
+	}
+
+	ret = write(fd, buf, strlen(buf));
+	if (ret < 0)
+		goto out2;
+
+	memset(buf, 0, size);
+	ret = read(fd, buf, size - 1);
+	if (ret < 0)
+		goto out2;
+
+	*newcon = strdup(buf);
+	if (!(*newcon)) {
+		ret = -1;
+		goto out2;
+	}
+	ret = 0;
+      out2:
+	free(buf);
+      out:
+	close(fd);
+	return ret;
 }
 hidden_def(security_compute_create_name_raw)
 
@@ -31,7 +112,8 @@ int security_compute_create_raw(const char * scon,
 				security_class_t tclass,
 				char ** newcon)
 {
-        return 0;
+	return security_compute_create_name_raw(scon, tcon, tclass,
+						NULL, newcon);
 }
 hidden_def(security_compute_create_raw)
 
@@ -41,7 +123,28 @@ int security_compute_create_name(const char * scon,
 				 const char *objname,
 				 char ** newcon)
 {
-        return 0;
+	int ret;
+	char * rscon;
+	char * rtcon;
+	char * rnewcon;
+
+	if (selinux_trans_to_raw_context(scon, &rscon))
+		return -1;
+	if (selinux_trans_to_raw_context(tcon, &rtcon)) {
+		freecon(rscon);
+		return -1;
+	}
+
+	ret = security_compute_create_name_raw(rscon, rtcon, tclass,
+					       objname, &rnewcon);
+	freecon(rscon);
+	freecon(rtcon);
+	if (!ret) {
+		ret = selinux_raw_to_trans_context(rnewcon, newcon);
+		freecon(rnewcon);
+	}
+
+	return ret;
 }
 hidden_def(security_compute_create_name)
 
@@ -50,6 +153,6 @@ int security_compute_create(const char * scon,
 			    security_class_t tclass,
 				char ** newcon)
 {
-        return 0;
+	return security_compute_create_name(scon, tcon, tclass, NULL, newcon);
 }
 hidden_def(security_compute_create)
diff --git a/libselinux/src/compute_member.c b/libselinux/src/compute_member.c
index 51ffc6a..1fc7e41 100644
--- a/libselinux/src/compute_member.c
+++ b/libselinux/src/compute_member.c
@@ -15,7 +15,49 @@ int security_compute_member_raw(const char * scon,
 				security_class_t tclass,
 				char ** newcon)
 {
-        return 0;
+	char path[PATH_MAX];
+	char *buf;
+	size_t size;
+	int fd, ret;
+
+	if (!selinux_mnt) {
+		errno = ENOENT;
+		return -1;
+	}
+
+	snprintf(path, sizeof path, "%s/member", selinux_mnt);
+	fd = open(path, O_RDWR);
+	if (fd < 0)
+		return -1;
+
+	size = selinux_page_size;
+	buf = malloc(size);
+	if (!buf) {
+		ret = -1;
+		goto out;
+	}
+	snprintf(buf, size, "%s %s %hu", scon, tcon, unmap_class(tclass));
+
+	ret = write(fd, buf, strlen(buf));
+	if (ret < 0)
+		goto out2;
+
+	memset(buf, 0, size);
+	ret = read(fd, buf, size - 1);
+	if (ret < 0)
+		goto out2;
+
+	*newcon = strdup(buf);
+	if (!(*newcon)) {
+		ret = -1;
+		goto out2;
+	}
+	ret = 0;
+      out2:
+	free(buf);
+      out:
+	close(fd);
+	return ret;
 }
 
 hidden_def(security_compute_member_raw)
@@ -25,5 +67,29 @@ int security_compute_member(const char * scon,
 			    security_class_t tclass,
 			    char ** newcon)
 {
-        return 0;
+	int ret;
+	char * rscon;
+	char * rtcon;
+	char * rnewcon;
+
+	if (selinux_trans_to_raw_context(scon, &rscon))
+		return -1;
+	if (selinux_trans_to_raw_context(tcon, &rtcon)) {
+		freecon(rscon);
+		return -1;
+	}
+
+	ret = security_compute_member_raw(rscon, rtcon, tclass, &rnewcon);
+
+	freecon(rscon);
+	freecon(rtcon);
+	if (!ret) {
+		if (selinux_raw_to_trans_context(rnewcon, newcon)) {
+			*newcon = NULL;
+			ret = -1;
+		}
+		freecon(rnewcon);
+	}
+
+	return ret;
 }
diff --git a/libselinux/src/compute_relabel.c b/libselinux/src/compute_relabel.c
index 8ae9099..4615aee 100644
--- a/libselinux/src/compute_relabel.c
+++ b/libselinux/src/compute_relabel.c
@@ -15,7 +15,49 @@ int security_compute_relabel_raw(const char * scon,
 				 security_class_t tclass,
 				 char ** newcon)
 {
-        return 0;
+	char path[PATH_MAX];
+	char *buf;
+	size_t size;
+	int fd, ret;
+
+	if (!selinux_mnt) {
+		errno = ENOENT;
+		return -1;
+	}
+
+	snprintf(path, sizeof path, "%s/relabel", selinux_mnt);
+	fd = open(path, O_RDWR);
+	if (fd < 0)
+		return -1;
+
+	size = selinux_page_size;
+	buf = malloc(size);
+	if (!buf) {
+		ret = -1;
+		goto out;
+	}
+	snprintf(buf, size, "%s %s %hu", scon, tcon, unmap_class(tclass));
+
+	ret = write(fd, buf, strlen(buf));
+	if (ret < 0)
+		goto out2;
+
+	memset(buf, 0, size);
+	ret = read(fd, buf, size - 1);
+	if (ret < 0)
+		goto out2;
+
+	*newcon = strdup(buf);
+	if (!*newcon) {
+		ret = -1;
+		goto out2;
+	}
+	ret = 0;
+      out2:
+	free(buf);
+      out:
+	close(fd);
+	return ret;
 }
 
 hidden_def(security_compute_relabel_raw)
@@ -25,5 +67,26 @@ int security_compute_relabel(const char * scon,
 			     security_class_t tclass,
 			     char ** newcon)
 {
-        return 0;
+	int ret;
+	char * rscon;
+	char * rtcon;
+	char * rnewcon;
+
+	if (selinux_trans_to_raw_context(scon, &rscon))
+		return -1;
+	if (selinux_trans_to_raw_context(tcon, &rtcon)) {
+		freecon(rscon);
+		return -1;
+	}
+
+	ret = security_compute_relabel_raw(rscon, rtcon, tclass, &rnewcon);
+
+	freecon(rscon);
+	freecon(rtcon);
+	if (!ret) {
+		ret = selinux_raw_to_trans_context(rnewcon, newcon);
+		freecon(rnewcon);
+	}
+
+	return ret;
 }
diff --git a/libselinux/src/compute_user.c b/libselinux/src/compute_user.c
index 8e484e2..b37c5d3 100644
--- a/libselinux/src/compute_user.c
+++ b/libselinux/src/compute_user.c
@@ -12,7 +12,69 @@
 int security_compute_user_raw(const char * scon,
 			      const char *user, char *** con)
 {
-        return 0;
+	char path[PATH_MAX];
+	char **ary;
+	char *buf, *ptr;
+	size_t size;
+	int fd, ret;
+	unsigned int i, nel;
+
+	if (!selinux_mnt) {
+		errno = ENOENT;
+		return -1;
+	}
+
+	snprintf(path, sizeof path, "%s/user", selinux_mnt);
+	fd = open(path, O_RDWR);
+	if (fd < 0)
+		return -1;
+
+	size = selinux_page_size;
+	buf = malloc(size);
+	if (!buf) {
+		ret = -1;
+		goto out;
+	}
+	snprintf(buf, size, "%s %s", scon, user);
+
+	ret = write(fd, buf, strlen(buf));
+	if (ret < 0)
+		goto out2;
+
+	memset(buf, 0, size);
+	ret = read(fd, buf, size - 1);
+	if (ret < 0)
+		goto out2;
+
+	if (sscanf(buf, "%u", &nel) != 1) {
+		ret = -1;
+		goto out2;
+	}
+
+	ary = malloc((nel + 1) * sizeof(char *));
+	if (!ary) {
+		ret = -1;
+		goto out2;
+	}
+
+	ptr = buf + strlen(buf) + 1;
+	for (i = 0; i < nel; i++) {
+		ary[i] = strdup(ptr);
+		if (!ary[i]) {
+			freeconary(ary);
+			ret = -1;
+			goto out2;
+		}
+		ptr += strlen(ptr) + 1;
+	}
+	ary[nel] = NULL;
+	*con = ary;
+	ret = 0;
+      out2:
+	free(buf);
+      out:
+	close(fd);
+	return ret;
 }
 
 hidden_def(security_compute_user_raw)
@@ -20,7 +82,29 @@ hidden_def(security_compute_user_raw)
 int security_compute_user(const char * scon,
 			  const char *user, char *** con)
 {
-        return 0;
+	int ret;
+	char * rscon;
+
+	if (selinux_trans_to_raw_context(scon, &rscon))
+		return -1;
+
+	ret = security_compute_user_raw(rscon, user, con);
+
+	freecon(rscon);
+	if (!ret) {
+		char **ptr, *tmpcon;
+		for (ptr = *con; *ptr; ptr++) {
+			if (selinux_raw_to_trans_context(*ptr, &tmpcon)) {
+				freeconary(*con);
+				*con = NULL;
+				return -1;
+			}
+			freecon(*ptr);
+			*ptr = tmpcon;
+		}
+	}
+
+	return ret;
 }
 
 hidden_def(security_compute_user)
diff --git a/libselinux/src/context.c b/libselinux/src/context.c
index b3cf739..b673733 100644
--- a/libselinux/src/context.c
+++ b/libselinux/src/context.c
@@ -21,6 +21,64 @@ typedef struct {
  */
 context_t context_new(const char *str)
 {
+	int i, count;
+	errno = 0;
+	context_private_t *n =
+	    (context_private_t *) malloc(sizeof(context_private_t));
+	context_t result = (context_t) malloc(sizeof(context_s_t));
+	const char *p, *tok;
+
+	if (result)
+		result->ptr = n;
+	else
+		free(n);
+	if (n == 0 || result == 0) {
+		goto err;
+	}
+	n->current_str = n->component[0] = n->component[1] = n->component[2] =
+	    n->component[3] = 0;
+	for (i = count = 0, p = str; *p; p++) {
+		switch (*p) {
+		case ':':
+			count++;
+			break;
+		case '\n':
+		case '\t':
+		case '\r':
+			goto err;	/* sanity check */
+		case ' ':
+			if (count < 3)
+				goto err;	/* sanity check */
+		}
+	}
+	/*
+	 * Could be anywhere from 2 - 5
+	 * e.g user:role:type to user:role:type:sens1:cata-sens2:catb
+	 */
+	if (count < 2 || count > 5) {	/* might not have a range */
+		goto err;
+	}
+
+	n->component[3] = 0;
+	for (i = 0, tok = str; *tok; i++) {
+		if (i < 3)
+			for (p = tok; *p && *p != ':'; p++) {	/* empty */
+		} else {
+			/* MLS range is one component */
+			for (p = tok; *p; p++) {	/* empty */
+			}
+		}
+		n->component[i] = (char *)malloc(p - tok + 1);
+		if (n->component[i] == 0)
+			goto err;
+		strncpy(n->component[i], tok, p - tok);
+		n->component[i][p - tok] = '\0';
+		tok = *p ? p + 1 : p;
+	}
+	return result;
+      err:
+	if (errno == 0) errno = EINVAL;
+	context_free(result);
 	return 0;
 }
 
@@ -28,6 +86,10 @@ hidden_def(context_new)
 
 static void conditional_free(char **v)
 {
+	if (*v) {
+		free(*v);
+	}
+	*v = 0;
 }
 
 /*
@@ -36,6 +98,19 @@ static void conditional_free(char **v)
  */
 void context_free(context_t context)
 {
+	context_private_t *n;
+	int i;
+	if (context) {
+		n = context->ptr;
+		if (n) {
+			conditional_free(&n->current_str);
+			for (i = 0; i < 4; i++) {
+				conditional_free(&n->component[i]);
+			}
+			free(n);
+		}
+		free(context);
+	}
 }
 
 hidden_def(context_free)
@@ -45,7 +120,28 @@ hidden_def(context_free)
  */
 char *context_str(context_t context)
 {
-	return NULL;
+	context_private_t *n = context->ptr;
+	int i;
+	size_t total = 0;
+	conditional_free(&n->current_str);
+	for (i = 0; i < 4; i++) {
+		if (n->component[i]) {
+			total += strlen(n->component[i]) + 1;
+		}
+	}
+	n->current_str = malloc(total);
+	if (n->current_str != 0) {
+		char *cp = n->current_str;
+
+		cp = stpcpy(cp, n->component[0]);
+		for (i = 1; i < 4; i++) {
+			if (n->component[i]) {
+				*cp++ = ':';
+				cp = stpcpy(cp, n->component[i]);
+			}
+		}
+	}
+	return n->current_str;
 }
 
 hidden_def(context_str)
@@ -53,13 +149,33 @@ hidden_def(context_str)
 /* Returns nonzero iff failed */
 static int set_comp(context_private_t * n, int idx, const char *str)
 {
+	char *t = NULL;
+	const char *p;
+	if (str) {
+		t = (char *)malloc(strlen(str) + 1);
+		if (!t) {
+			return 1;
+		}
+		for (p = str; *p; p++) {
+			if (*p == '\t' || *p == '\n' || *p == '\r' ||
+			    ((*p == ':' || *p == ' ') && idx != COMP_RANGE)) {
+				free(t);
+				errno = EINVAL;
+				return 1;
+			}
+		}
+		strcpy(t, str);
+	}
+	conditional_free(&n->component[idx]);
+	n->component[idx] = t;
 	return 0;
 }
 
 #define def_get(name,tag) \
 const char * context_ ## name ## _get(context_t context) \
 { \
-        return NULL; \
+        context_private_t *n = context->ptr; \
+        return n->component[tag]; \
 } \
 hidden_def(context_ ## name ## _get)
 
@@ -70,7 +186,7 @@ def_get(type, COMP_TYPE)
 #define def_set(name,tag) \
 int context_ ## name ## _set(context_t context, const char* str) \
 { \
-        return 0; \
+        return set_comp(context->ptr,tag,str);\
 } \
 hidden_def(context_ ## name ## _set)
     def_set(type, COMP_TYPE)
diff --git a/libselinux/src/deny_unknown.c b/libselinux/src/deny_unknown.c
index 19f46c9..c93998a 100644
--- a/libselinux/src/deny_unknown.c
+++ b/libselinux/src/deny_unknown.c
@@ -11,7 +11,30 @@
 
 int security_deny_unknown(void)
 {
-	return 0;
+	int fd, ret, deny_unknown = 0;
+	char path[PATH_MAX];
+	char buf[20];
+
+	if (!selinux_mnt) {
+		errno = ENOENT;
+		return -1;
+	}
+
+	snprintf(path, sizeof(path), "%s/deny_unknown", selinux_mnt);
+	fd = open(path, O_RDONLY);
+	if (fd < 0)
+		return -1;
+
+	memset(buf, 0, sizeof(buf));
+	ret = read(fd, buf, sizeof(buf) - 1);
+	close(fd);
+	if (ret < 0)
+		return -1;
+
+	if (sscanf(buf, "%d", &deny_unknown) != 1)
+		return -1;
+
+	return deny_unknown;
 }
 
 hidden_def(security_deny_unknown);
diff --git a/libselinux/src/disable.c b/libselinux/src/disable.c
index 0921e80..dac0f5b 100644
--- a/libselinux/src/disable.c
+++ b/libselinux/src/disable.c
@@ -11,6 +11,27 @@
 
 int security_disable(void)
 {
+	int fd, ret;
+	char path[PATH_MAX];
+	char buf[20];
+
+	if (!selinux_mnt) {
+		errno = ENOENT;
+		return -1;
+	}
+
+	snprintf(path, sizeof path, "%s/disable", selinux_mnt);
+	fd = open(path, O_WRONLY);
+	if (fd < 0)
+		return -1;
+
+	buf[0] = '1';
+	buf[1] = '\0';
+	ret = write(fd, buf, strlen(buf));
+	close(fd);
+	if (ret < 0)
+		return -1;
+
 	return 0;
 }
 
diff --git a/libselinux/src/enabled.c b/libselinux/src/enabled.c
index 07b8390..2ec6797 100644
--- a/libselinux/src/enabled.c
+++ b/libselinux/src/enabled.c
@@ -10,7 +10,14 @@
 
 int is_selinux_enabled(void)
 {
-	return 1;
+	/* init_selinuxmnt() gets called before this function. We
+ 	 * will assume that if a selinux file system is mounted, then
+ 	 * selinux is enabled. */
+#ifdef ANDROID
+	return (selinux_mnt ? 1 : 0);
+#else
+	return (selinux_mnt && has_selinux_config);
+#endif
 }
 
 hidden_def(is_selinux_enabled)
@@ -22,7 +29,30 @@ hidden_def(is_selinux_enabled)
  */
 int is_selinux_mls_enabled(void)
 {
-	return 0;
+	char buf[20], path[PATH_MAX];
+	int fd, ret, enabled = 0;
+
+	if (!selinux_mnt)
+		return enabled;
+
+	snprintf(path, sizeof path, "%s/mls", selinux_mnt);
+	fd = open(path, O_RDONLY);
+	if (fd < 0)
+		return enabled;
+
+	memset(buf, 0, sizeof buf);
+
+	do {
+		ret = read(fd, buf, sizeof buf - 1);
+	} while (ret < 0 && errno == EINTR);
+	close(fd);
+	if (ret < 0)
+		return enabled;
+
+	if (!strcmp(buf, "1"))
+		enabled = 1;
+
+	return enabled;
 }
 
 hidden_def(is_selinux_mls_enabled)
diff --git a/libselinux/src/fgetfilecon.c b/libselinux/src/fgetfilecon.c
index 9b5ef02..5522ac1 100644
--- a/libselinux/src/fgetfilecon.c
+++ b/libselinux/src/fgetfilecon.c
@@ -9,12 +9,64 @@
 
 int fgetfilecon_raw(int fd, char ** context)
 {
-	return 0;
+	char *buf;
+	ssize_t size;
+	ssize_t ret;
+
+	size = INITCONTEXTLEN + 1;
+	buf = malloc(size);
+	if (!buf)
+		return -1;
+	memset(buf, 0, size);
+
+	ret = fgetxattr(fd, XATTR_NAME_SELINUX, buf, size - 1);
+	if (ret < 0 && errno == ERANGE) {
+		char *newbuf;
+
+		size = fgetxattr(fd, XATTR_NAME_SELINUX, NULL, 0);
+		if (size < 0)
+			goto out;
+
+		size++;
+		newbuf = realloc(buf, size);
+		if (!newbuf)
+			goto out;
+
+		buf = newbuf;
+		memset(buf, 0, size);
+		ret = fgetxattr(fd, XATTR_NAME_SELINUX, buf, size - 1);
+	}
+      out:
+	if (ret == 0) {
+		/* Re-map empty attribute values to errors. */
+		errno = ENOTSUP;
+		ret = -1;
+	}
+	if (ret < 0)
+		free(buf);
+	else
+		*context = buf;
+	return ret;
 }
 
 hidden_def(fgetfilecon_raw)
 
 int fgetfilecon(int fd, char ** context)
 {
-	return 0;
+	char * rcontext = NULL;
+	int ret;
+
+	*context = NULL;
+
+	ret = fgetfilecon_raw(fd, &rcontext);
+
+	if (ret > 0) {
+		ret = selinux_raw_to_trans_context(rcontext, context);
+		freecon(rcontext);
+	}
+
+	if (ret >= 0 && *context)
+		return strlen(*context) + 1;
+
+	return ret;
 }
diff --git a/libselinux/src/freecon.c b/libselinux/src/freecon.c
index 4b32069..5290dfa 100644
--- a/libselinux/src/freecon.c
+++ b/libselinux/src/freecon.c
@@ -5,6 +5,7 @@
 
 void freecon(char * con)
 {
+	free(con);
 }
 
 hidden_def(freecon)
diff --git a/libselinux/src/freeconary.c b/libselinux/src/freeconary.c
index c11fdfc..8d07718 100644
--- a/libselinux/src/freeconary.c
+++ b/libselinux/src/freeconary.c
@@ -5,6 +5,15 @@
 
 void freeconary(char ** con)
 {
+	char **ptr;
+
+	if (!con)
+		return;
+
+	for (ptr = con; *ptr; ptr++) {
+		free(*ptr);
+	}
+	free(con);
 }
 
 hidden_def(freeconary)
diff --git a/libselinux/src/fsetfilecon.c b/libselinux/src/fsetfilecon.c
index c8c3599..52707d0 100644
--- a/libselinux/src/fsetfilecon.c
+++ b/libselinux/src/fsetfilecon.c
@@ -9,12 +9,35 @@
 
 int fsetfilecon_raw(int fd, const char * context)
 {
-        return 0;
+	int rc = fsetxattr(fd, XATTR_NAME_SELINUX, context, strlen(context) + 1,
+			 0);
+	if (rc < 0 && errno == ENOTSUP) {
+		char * ccontext = NULL;
+		int err = errno;
+		if ((fgetfilecon_raw(fd, &ccontext) >= 0) &&
+		    (strcmp(context,ccontext) == 0)) {
+			rc = 0;
+		} else {
+			errno = err;
+		}
+		freecon(ccontext);
+	}
+	return rc;
 }
 
 hidden_def(fsetfilecon_raw)
 
 int fsetfilecon(int fd, const char *context)
 {
-        return 0;
+	int ret;
+	char * rcontext;
+
+	if (selinux_trans_to_raw_context(context, &rcontext))
+		return -1;
+
+	ret = fsetfilecon_raw(fd, rcontext);
+
+	freecon(rcontext);
+
+	return ret;
 }
diff --git a/libselinux/src/get_context_list.c b/libselinux/src/get_context_list.c
index 757d598..f3fa4a9 100644
--- a/libselinux/src/get_context_list.c
+++ b/libselinux/src/get_context_list.c
@@ -15,7 +15,40 @@ int get_default_context_with_role(const char *user,
 				  char * fromcon,
 				  char ** newcon)
 {
-        return 0;
+	char **conary;
+	char **ptr;
+	context_t con;
+	const char *role2;
+	int rc;
+
+	rc = get_ordered_context_list(user, fromcon, &conary);
+	if (rc <= 0)
+		return -1;
+
+	for (ptr = conary; *ptr; ptr++) {
+		con = context_new(*ptr);
+		if (!con)
+			continue;
+		role2 = context_role_get(con);
+		if (role2 && !strcmp(role, role2)) {
+			context_free(con);
+			break;
+		}
+		context_free(con);
+	}
+
+	rc = -1;
+	if (!(*ptr)) {
+		errno = EINVAL;
+		goto out;
+	}
+	*newcon = strdup(*ptr);
+	if (!(*newcon))
+		goto out;
+	rc = 0;
+      out:
+	freeconary(conary);
+	return rc;
 }
 
 hidden_def(get_default_context_with_role)
@@ -26,19 +59,99 @@ int get_default_context_with_rolelevel(const char *user,
 				       char * fromcon,
 				       char ** newcon)
 {
-        return 0;
+
+	int rc = 0;
+	int freefrom = 0;
+	context_t con;
+	char *newfromcon;
+	if (!level)
+		return get_default_context_with_role(user, role, fromcon,
+						     newcon);
+
+	if (!fromcon) {
+		rc = getcon(&fromcon);
+		if (rc < 0)
+			return rc;
+		freefrom = 1;
+	}
+
+	rc = -1;
+	con = context_new(fromcon);
+	if (!con)
+		goto out;
+
+	if (context_range_set(con, level))
+		goto out;
+
+	newfromcon = context_str(con);
+	if (!newfromcon)
+		goto out;
+
+	rc = get_default_context_with_role(user, role, newfromcon, newcon);
+
+      out:
+	context_free(con);
+	if (freefrom)
+		freecon(fromcon);
+	return rc;
+
 }
 
 int get_default_context(const char *user,
 			char * fromcon, char ** newcon)
 {
-        return 0;
+	char **conary;
+	int rc;
+
+	rc = get_ordered_context_list(user, fromcon, &conary);
+	if (rc <= 0)
+		return -1;
+
+	*newcon = strdup(conary[0]);
+	freeconary(conary);
+	if (!(*newcon))
+		return -1;
+	return 0;
 }
 
 static int find_partialcon(char ** list,
 			   unsigned int nreach, char *part)
 {
-        return 0;
+	const char *conrole, *contype;
+	char *partrole, *parttype, *ptr;
+	context_t con;
+	unsigned int i;
+
+	partrole = part;
+	ptr = part;
+	while (*ptr && !isspace(*ptr) && *ptr != ':')
+		ptr++;
+	if (*ptr != ':')
+		return -1;
+	*ptr++ = 0;
+	parttype = ptr;
+	while (*ptr && !isspace(*ptr) && *ptr != ':')
+		ptr++;
+	*ptr = 0;
+
+	for (i = 0; i < nreach; i++) {
+		con = context_new(list[i]);
+		if (!con)
+			return -1;
+		conrole = context_role_get(con);
+		contype = context_type_get(con);
+		if (!conrole || !contype) {
+			context_free(con);
+			return -1;
+		}
+		if (!strcmp(conrole, partrole) && !strcmp(contype, parttype)) {
+			context_free(con);
+			return i;
+		}
+		context_free(con);
+	}
+
+	return -1;
 }
 
 static int get_context_order(FILE * fp,
@@ -47,12 +160,157 @@ static int get_context_order(FILE * fp,
 			     unsigned int nreach,
 			     unsigned int *ordering, unsigned int *nordered)
 {
-        return 0;
+	char *start, *end = NULL;
+	char *line = NULL;
+	size_t line_len = 0;
+	ssize_t len;
+	int found = 0;
+	const char *fromrole, *fromtype;
+	char *linerole, *linetype;
+	unsigned int i;
+	context_t con;
+	int rc;
+
+	errno = -EINVAL;
+
+	/* Extract the role and type of the fromcon for matching.
+	   User identity and MLS range can be variable. */
+	con = context_new(fromcon);
+	if (!con)
+		return -1;
+	fromrole = context_role_get(con);
+	fromtype = context_type_get(con);
+	if (!fromrole || !fromtype) {
+		context_free(con);
+		return -1;
+	}
+
+	while ((len = getline(&line, &line_len, fp)) > 0) {
+		if (line[len - 1] == '\n')
+			line[len - 1] = 0;
+
+		/* Skip leading whitespace. */
+		start = line;
+		while (*start && isspace(*start))
+			start++;
+		if (!(*start))
+			continue;
+
+		/* Find the end of the (partial) fromcon in the line. */
+		end = start;
+		while (*end && !isspace(*end))
+			end++;
+		if (!(*end))
+			continue;
+
+		/* Check for a match. */
+		linerole = start;
+		while (*start && !isspace(*start) && *start != ':')
+			start++;
+		if (*start != ':')
+			continue;
+		*start = 0;
+		linetype = ++start;
+		while (*start && !isspace(*start) && *start != ':')
+			start++;
+		if (!(*start))
+			continue;
+		*start = 0;
+		if (!strcmp(fromrole, linerole) && !strcmp(fromtype, linetype)) {
+			found = 1;
+			break;
+		}
+	}
+
+	if (!found) {
+		errno = ENOENT;
+		rc = -1;
+		goto out;
+	}
+
+	start = ++end;
+	while (*start) {
+		/* Skip leading whitespace */
+		while (*start && isspace(*start))
+			start++;
+		if (!(*start))
+			break;
+
+		/* Find the end of this partial context. */
+		end = start;
+		while (*end && !isspace(*end))
+			end++;
+		if (*end)
+			*end++ = 0;
+
+		/* Check for a match in the reachable list. */
+		rc = find_partialcon(reachable, nreach, start);
+		if (rc < 0) {
+			/* No match, skip it. */
+			start = end;
+			continue;
+		}
+
+		/* If a match is found and the entry is not already ordered
+		   (e.g. due to prior match in prior config file), then set
+		   the ordering for it. */
+		i = rc;
+		if (ordering[i] == nreach)
+			ordering[i] = (*nordered)++;
+		start = end;
+	}
+
+	rc = 0;
+
+      out:
+	context_free(con);
+	free(line);
+	return rc;
 }
 
 static int get_failsafe_context(const char *user, char ** newcon)
 {
-        return 0;
+	FILE *fp;
+	char buf[255], *ptr;
+	size_t plen, nlen;
+	int rc;
+
+	fp = fopen(selinux_failsafe_context_path(), "r");
+	if (!fp)
+		return -1;
+
+	ptr = fgets_unlocked(buf, sizeof buf, fp);
+	fclose(fp);
+
+	if (!ptr)
+		return -1;
+	plen = strlen(ptr);
+	if (buf[plen - 1] == '\n')
+		buf[plen - 1] = 0;
+
+	nlen = strlen(user) + 1 + plen + 1;
+	*newcon = malloc(nlen);
+	if (!(*newcon))
+		return -1;
+	rc = snprintf(*newcon, nlen, "%s:%s", user, ptr);
+	if (rc < 0 || (size_t) rc >= nlen) {
+		free(*newcon);
+		*newcon = 0;
+		return -1;
+	}
+
+	/* If possible, check the context to catch
+	   errors early rather than waiting until the
+	   caller tries to use setexeccon on the context.
+	   But this may not always be possible, e.g. if
+	   selinuxfs isn't mounted. */
+	if (security_check_context(*newcon) && errno != ENOENT) {
+		free(*newcon);
+		*newcon = 0;
+		return -1;
+	}
+
+	return 0;
 }
 
 struct context_order {
@@ -62,7 +320,12 @@ struct context_order {
 
 static int order_compare(const void *A, const void *B)
 {
-        return 0;
+	const struct context_order *c1 = A, *c2 = B;
+	if (c1->order < c2->order)
+		return -1;
+	else if (c1->order > c2->order)
+		return 1;
+	return strcmp(c1->con, c2->con);
 }
 
 int get_ordered_context_list_with_level(const char *user,
@@ -70,7 +333,40 @@ int get_ordered_context_list_with_level(const char *user,
 					char * fromcon,
 					char *** list)
 {
-        return 0;
+	int rc;
+	int freefrom = 0;
+	context_t con;
+	char *newfromcon;
+
+	if (!level)
+		return get_ordered_context_list(user, fromcon, list);
+
+	if (!fromcon) {
+		rc = getcon(&fromcon);
+		if (rc < 0)
+			return rc;
+		freefrom = 1;
+	}
+
+	rc = -1;
+	con = context_new(fromcon);
+	if (!con)
+		goto out;
+
+	if (context_range_set(con, level))
+		goto out;
+
+	newfromcon = context_str(con);
+	if (!newfromcon)
+		goto out;
+
+	rc = get_ordered_context_list(user, newfromcon, list);
+
+      out:
+	context_free(con);
+	if (freefrom)
+		freecon(fromcon);
+	return rc;
 }
 
 hidden_def(get_ordered_context_list_with_level)
@@ -80,6 +376,17 @@ int get_default_context_with_level(const char *user,
 				   char * fromcon,
 				   char ** newcon)
 {
+	char **conary;
+	int rc;
+
+	rc = get_ordered_context_list_with_level(user, level, fromcon, &conary);
+	if (rc <= 0)
+		return -1;
+
+	*newcon = strdup(conary[0]);
+	freeconary(conary);
+	if (!(*newcon))
+		return -1;
 	return 0;
 }
 
@@ -87,7 +394,133 @@ int get_ordered_context_list(const char *user,
 			     char * fromcon,
 			     char *** list)
 {
-        return 0;
+	char **reachable = NULL;
+	unsigned int *ordering = NULL;
+	struct context_order *co = NULL;
+	char **ptr;
+	int rc = 0;
+	unsigned int nreach = 0, nordered = 0, freefrom = 0, i;
+	FILE *fp;
+	char *fname = NULL;
+	size_t fname_len;
+	const char *user_contexts_path = selinux_user_contexts_path();
+
+	if (!fromcon) {
+		/* Get the current context and use it for the starting context */
+		rc = getcon(&fromcon);
+		if (rc < 0)
+			return rc;
+		freefrom = 1;
+	}
+
+	/* Determine the set of reachable contexts for the user. */
+	rc = security_compute_user(fromcon, user, &reachable);
+	if (rc < 0)
+		goto failsafe;
+	nreach = 0;
+	for (ptr = reachable; *ptr; ptr++)
+		nreach++;
+	if (!nreach)
+		goto failsafe;
+
+	/* Initialize ordering array. */
+	ordering = malloc(nreach * sizeof(unsigned int));
+	if (!ordering)
+		goto failsafe;
+	for (i = 0; i < nreach; i++)
+		ordering[i] = nreach;
+
+	/* Determine the ordering to apply from the optional per-user config
+	   and from the global config. */
+	fname_len = strlen(user_contexts_path) + strlen(user) + 2;
+	fname = malloc(fname_len);
+	if (!fname)
+		goto failsafe;
+	snprintf(fname, fname_len, "%s%s", user_contexts_path, user);
+	fp = fopen(fname, "r");
+	if (fp) {
+		__fsetlocking(fp, FSETLOCKING_BYCALLER);
+		rc = get_context_order(fp, fromcon, reachable, nreach, ordering,
+				       &nordered);
+		fclose(fp);
+		if (rc < 0 && errno != ENOENT) {
+			fprintf(stderr,
+				"%s:  error in processing configuration file %s\n",
+				__FUNCTION__, fname);
+			/* Fall through, try global config */
+		}
+	}
+	free(fname);
+	fp = fopen(selinux_default_context_path(), "r");
+	if (fp) {
+		__fsetlocking(fp, FSETLOCKING_BYCALLER);
+		rc = get_context_order(fp, fromcon, reachable, nreach, ordering,
+				       &nordered);
+		fclose(fp);
+		if (rc < 0 && errno != ENOENT) {
+			fprintf(stderr,
+				"%s:  error in processing configuration file %s\n",
+				__FUNCTION__, selinux_default_context_path());
+			/* Fall through */
+		}
+		rc = 0;
+	}
+
+	if (!nordered)
+		goto failsafe;
+
+	/* Apply the ordering. */
+	co = malloc(nreach * sizeof(struct context_order));
+	if (!co)
+		goto failsafe;
+	for (i = 0; i < nreach; i++) {
+		co[i].con = reachable[i];
+		co[i].order = ordering[i];
+	}
+	qsort(co, nreach, sizeof(struct context_order), order_compare);
+	for (i = 0; i < nreach; i++)
+		reachable[i] = co[i].con;
+	free(co);
+
+	/* Only report the ordered entries to the caller. */
+	if (nordered <= nreach) {
+		for (i = nordered; i < nreach; i++)
+			free(reachable[i]);
+		reachable[nordered] = NULL;
+		rc = nordered;
+	}
+
+      out:
+	if (rc > 0)
+		*list = reachable;
+	else
+		freeconary(reachable);
+
+	free(ordering);
+	if (freefrom)
+		freecon(fromcon);
+
+	return rc;
+
+      failsafe:
+	/* Unable to determine a reachable context list, try to fall back to
+	   the "failsafe" context to at least permit root login
+	   for emergency recovery if possible. */
+	freeconary(reachable);
+	reachable = malloc(2 * sizeof(char *));
+	if (!reachable) {
+		rc = -1;
+		goto out;
+	}
+	reachable[0] = reachable[1] = 0;
+	rc = get_failsafe_context(user, &reachable[0]);
+	if (rc < 0) {
+		freeconary(reachable);
+		reachable = NULL;
+		goto out;
+	}
+	rc = 1;			/* one context in the list */
+	goto out;
 }
 
 hidden_def(get_ordered_context_list)
diff --git a/libselinux/src/get_default_type.c b/libselinux/src/get_default_type.c
index cd1d726..27f2ae5 100644
--- a/libselinux/src/get_default_type.c
+++ b/libselinux/src/get_default_type.c
@@ -9,10 +9,63 @@ static int find_default_type(FILE * fp, const char *role, char **type);
 
 int get_default_type(const char *role, char **type)
 {
+	FILE *fp = NULL;
+
+	fp = fopen(selinux_default_type_path(), "r");
+	if (!fp)
+		return -1;
+
+	if (find_default_type(fp, role, type) < 0) {
+		fclose(fp);
+		return -1;
+	}
+
+	fclose(fp);
 	return 0;
 }
 
 static int find_default_type(FILE * fp, const char *role, char **type)
 {
+	char buf[250];
+	const char *ptr = "", *end;
+	char *t;
+	size_t len;
+	int found = 0;
+
+	len = strlen(role);
+	while (!feof_unlocked(fp)) {
+		if (!fgets_unlocked(buf, sizeof buf, fp)) {
+			errno = EINVAL;
+			return -1;
+		}
+		if (buf[strlen(buf) - 1])
+			buf[strlen(buf) - 1] = 0;
+
+		ptr = buf;
+		while (*ptr && isspace(*ptr))
+			ptr++;
+		if (!(*ptr))
+			continue;
+
+		if (!strncmp(role, ptr, len)) {
+			end = ptr + len;
+			if (*end == ':') {
+				found = 1;
+				ptr = ++end;
+				break;
+			}
+		}
+	}
+
+	if (!found) {
+		errno = EINVAL;
+		return -1;
+	}
+
+	t = malloc(strlen(buf) - len);
+	if (!t)
+		return -1;
+	strcpy(t, ptr);
+	*type = t;
 	return 0;
 }
diff --git a/libselinux/src/get_initial_context.c b/libselinux/src/get_initial_context.c
index 93ade44..522ed78 100644
--- a/libselinux/src/get_initial_context.c
+++ b/libselinux/src/get_initial_context.c
@@ -13,14 +13,60 @@
 
 int security_get_initial_context_raw(const char * name, char ** con)
 {
-        return 0;
+	char path[PATH_MAX];
+	char *buf;
+	size_t size;
+	int fd, ret;
+
+	if (!selinux_mnt) {
+		errno = ENOENT;
+		return -1;
+	}
+
+	snprintf(path, sizeof path, "%s%s%s", 
+		 selinux_mnt, SELINUX_INITCON_DIR, name);
+	fd = open(path, O_RDONLY);
+	if (fd < 0)
+		return -1;
+
+	size = selinux_page_size;
+	buf = malloc(size);
+	if (!buf) {
+		ret = -1;
+		goto out;
+	}
+	memset(buf, 0, size);
+	ret = read(fd, buf, size - 1);
+	if (ret < 0)
+		goto out2;
+
+	*con = strdup(buf);
+	if (!(*con)) {
+		ret = -1;
+		goto out2;
+	}
+	ret = 0;
+      out2:
+	free(buf);
+      out:
+	close(fd);
+	return ret;
 }
 
 hidden_def(security_get_initial_context_raw)
 
 int security_get_initial_context(const char * name, char ** con)
 {
-        return 0;
+	int ret;
+	char * rcon;
+
+	ret = security_get_initial_context_raw(name, &rcon);
+	if (!ret) {
+		ret = selinux_raw_to_trans_context(rcon, con);
+		freecon(rcon);
+	}
+
+	return ret;
 }
 
 hidden_def(security_get_initial_context)
diff --git a/libselinux/src/getenforce.c b/libselinux/src/getenforce.c
index 59349ed..03d3abc 100644
--- a/libselinux/src/getenforce.c
+++ b/libselinux/src/getenforce.c
@@ -11,7 +11,30 @@
 
 int security_getenforce(void)
 {
-	return 0;
+	int fd, ret, enforce = 0;
+	char path[PATH_MAX];
+	char buf[20];
+
+	if (!selinux_mnt) {
+		errno = ENOENT;
+		return -1;
+	}
+
+	snprintf(path, sizeof path, "%s/enforce", selinux_mnt);
+	fd = open(path, O_RDONLY);
+	if (fd < 0)
+		return -1;
+
+	memset(buf, 0, sizeof buf);
+	ret = read(fd, buf, sizeof buf - 1);
+	close(fd);
+	if (ret < 0)
+		return -1;
+
+	if (sscanf(buf, "%d", &enforce) != 1)
+		return -1;
+
+	return !!enforce;
 }
 
 hidden_def(security_getenforce)
diff --git a/libselinux/src/getfilecon.c b/libselinux/src/getfilecon.c
index 2b867f2..20bee8a 100644
--- a/libselinux/src/getfilecon.c
+++ b/libselinux/src/getfilecon.c
@@ -9,14 +9,65 @@
 
 int getfilecon_raw(const char *path, char ** context)
 {
-	return 0;
+	char *buf;
+	ssize_t size;
+	ssize_t ret;
+
+	size = INITCONTEXTLEN + 1;
+	buf = malloc(size);
+	if (!buf)
+		return -1;
+	memset(buf, 0, size);
+
+	ret = getxattr(path, XATTR_NAME_SELINUX, buf, size - 1);
+	if (ret < 0 && errno == ERANGE) {
+		char *newbuf;
+
+		size = getxattr(path, XATTR_NAME_SELINUX, NULL, 0);
+		if (size < 0)
+			goto out;
+
+		size++;
+		newbuf = realloc(buf, size);
+		if (!newbuf)
+			goto out;
+
+		buf = newbuf;
+		memset(buf, 0, size);
+		ret = getxattr(path, XATTR_NAME_SELINUX, buf, size - 1);
+	}
+      out:
+	if (ret == 0) {
+		/* Re-map empty attribute values to errors. */
+		errno = ENOTSUP;
+		ret = -1;
+	}
+	if (ret < 0)
+		free(buf);
+	else
+		*context = buf;
+	return ret;
 }
 
 hidden_def(getfilecon_raw)
 
 int getfilecon(const char *path, char ** context)
 {
-        return 0;
+	int ret;
+	char * rcontext = NULL;
+
+	*context = NULL;
+
+	ret = getfilecon_raw(path, &rcontext);
+
+	if (ret > 0) {
+		ret = selinux_raw_to_trans_context(rcontext, context);
+		freecon(rcontext);
+	}
+	if (ret >= 0 && *context)
+		return strlen(*context) + 1;
+
+	return ret;
 }
 
 hidden_def(getfilecon)
diff --git a/libselinux/src/getpeercon.c b/libselinux/src/getpeercon.c
index da5aa0e..3a77a2d 100644
--- a/libselinux/src/getpeercon.c
+++ b/libselinux/src/getpeercon.c
@@ -13,12 +13,49 @@
 
 int getpeercon_raw(int fd, char ** context)
 {
-        return 0;
+	char *buf;
+	socklen_t size;
+	ssize_t ret;
+
+	size = INITCONTEXTLEN + 1;
+	buf = malloc(size);
+	if (!buf)
+		return -1;
+	memset(buf, 0, size);
+
+	ret = getsockopt(fd, SOL_SOCKET, SO_PEERSEC, buf, &size);
+	if (ret < 0 && errno == ERANGE) {
+		char *newbuf;
+
+		newbuf = realloc(buf, size);
+		if (!newbuf)
+			goto out;
+
+		buf = newbuf;
+		memset(buf, 0, size);
+		ret = getsockopt(fd, SOL_SOCKET, SO_PEERSEC, buf, &size);
+	}
+      out:
+	if (ret < 0)
+		free(buf);
+	else
+		*context = buf;
+	return ret;
 }
 
 hidden_def(getpeercon_raw)
 
 int getpeercon(int fd, char ** context)
 {
-        return 0;
+	int ret;
+	char * rcontext;
+
+	ret = getpeercon_raw(fd, &rcontext);
+
+	if (!ret) {
+		ret = selinux_raw_to_trans_context(rcontext, context);
+		freecon(rcontext);
+	}
+
+	return ret;
 }
diff --git a/libselinux/src/init.c b/libselinux/src/init.c
index ba13065..ddf91f8 100644
--- a/libselinux/src/init.c
+++ b/libselinux/src/init.c
@@ -31,27 +31,118 @@ int has_selinux_config = 0;
 */
 static int verify_selinuxmnt(const char *mnt)
 {
-        return 0;
+	struct statfs sfbuf;
+	int rc;
+
+	do {
+		rc = statfs(mnt, &sfbuf);
+	} while (rc < 0 && errno == EINTR);
+	if (rc == 0) {
+		if ((uint32_t)sfbuf.f_type == (uint32_t)SELINUX_MAGIC) {
+			struct statvfs vfsbuf;
+			rc = statvfs(mnt, &vfsbuf);
+			if (rc == 0) {
+				if (!(vfsbuf.f_flag & ST_RDONLY)) {
+					set_selinuxmnt(mnt);
+				}
+				return 0;
+			}
+		}
+	}
+
+	return -1;
 }
 
 int selinuxfs_exists(void)
 {
-	return 0;
+	int exists = 0;
+	FILE *fp = NULL;
+	char *buf = NULL;
+	size_t len;
+	ssize_t num;
+
+	fp = fopen("/proc/filesystems", "r");
+	if (!fp)
+		return 1; /* Fail as if it exists */
+	__fsetlocking(fp, FSETLOCKING_BYCALLER);
+
+	num = getline(&buf, &len, fp);
+	while (num != -1) {
+		if (strstr(buf, SELINUXFS)) {
+			exists = 1;
+			break;
+		}
+		num = getline(&buf, &len, fp);
+	}
+
+	free(buf);
+	fclose(fp);
+	return exists;
 }
 hidden_def(selinuxfs_exists)
 
 static void init_selinuxmnt(void)
 {
+	char *buf=NULL, *p;
+	FILE *fp=NULL;
+	size_t len;
+	ssize_t num;
+
+	if (selinux_mnt)
+		return;
+
+	if (verify_selinuxmnt(SELINUXMNT) == 0) return;
+
+	if (verify_selinuxmnt(OLDSELINUXMNT) == 0) return;
+
+	/* Drop back to detecting it the long way. */
+	if (!selinuxfs_exists())
+		goto out;
+
+	/* At this point, the usual spot doesn't have an selinuxfs so
+	 * we look around for it */
+	fp = fopen("/proc/mounts", "r");
+	if (!fp)
+		goto out;
+
+	__fsetlocking(fp, FSETLOCKING_BYCALLER);
+	while ((num = getline(&buf, &len, fp)) != -1) {
+		char *tmp;
+		p = strchr(buf, ' ');
+		if (!p)
+			goto out;
+		p++;
+		tmp = strchr(p, ' ');
+		if (!tmp)
+			goto out;
+		if (!strncmp(tmp + 1, SELINUXFS" ", strlen(SELINUXFS)+1)) {
+			*tmp = '\0';
+			break;
+		}
+	}
+
+	/* If we found something, dup it */
+	if (num > 0)
+		verify_selinuxmnt(p);
+
+      out:
+	free(buf);
+	if (fp)
+		fclose(fp);
+	return;
 }
 
 void fini_selinuxmnt(void)
 {
+	free(selinux_mnt);
+	selinux_mnt = NULL;
 }
 
 hidden_def(fini_selinuxmnt)
 
 void set_selinuxmnt(const char *mnt)
 {
+	selinux_mnt = strdup(mnt);
 }
 
 hidden_def(set_selinuxmnt)
@@ -59,9 +150,15 @@ hidden_def(set_selinuxmnt)
 static void init_lib(void) __attribute__ ((constructor));
 static void init_lib(void)
 {
+	selinux_page_size = sysconf(_SC_PAGE_SIZE);
+	init_selinuxmnt();
+#ifndef ANDROID
+	has_selinux_config = (access(SELINUXCONFIG, F_OK) == 0);
+#endif
 }
 
 static void fini_lib(void) __attribute__ ((destructor));
 static void fini_lib(void)
 {
+	fini_selinuxmnt();
 }
diff --git a/libselinux/src/is_customizable_type.c b/libselinux/src/is_customizable_type.c
index be61a0f..0b33edc 100644
--- a/libselinux/src/is_customizable_type.c
+++ b/libselinux/src/is_customizable_type.c
@@ -11,6 +11,51 @@
 
 static int get_customizable_type_list(char *** retlist)
 {
+	FILE *fp;
+	char *buf;
+	unsigned int ctr = 0, i;
+	char **list = NULL;
+
+	fp = fopen(selinux_customizable_types_path(), "r");
+	if (!fp)
+		return -1;
+
+	buf = malloc(selinux_page_size);
+	if (!buf) {
+		fclose(fp);
+		return -1;
+	}
+	while (fgets_unlocked(buf, selinux_page_size, fp) && ctr < UINT_MAX) {
+		ctr++;
+	}
+	rewind(fp);
+	if (ctr) {
+		list =
+		    (char **) calloc(sizeof(char *),
+						  ctr + 1);
+		if (list) {
+			i = 0;
+			while (fgets_unlocked(buf, selinux_page_size, fp)
+			       && i < ctr) {
+				buf[strlen(buf) - 1] = 0;
+				list[i] = (char *) strdup(buf);
+				if (!list[i]) {
+					unsigned int j;
+					for (j = 0; j < i; j++)
+						free(list[j]);
+					free(list);
+					list = NULL;
+					break;
+				}
+				i++;
+			}
+		}
+	}
+	fclose(fp);
+	free(buf);
+	if (!list)
+		return -1;
+	*retlist = list;
 	return 0;
 }
 
@@ -18,5 +63,31 @@ static char **customizable_list = NULL;
 
 int is_context_customizable(const char * scontext)
 {
+	int i;
+	const char *type;
+	context_t c;
+
+	if (!customizable_list) {
+		if (get_customizable_type_list(&customizable_list) != 0)
+			return -1;
+	}
+
+	c = context_new(scontext);
+	if (!c)
+		return -1;
+
+	type = context_type_get(c);
+	if (!type) {
+		context_free(c);
+		return -1;
+	}
+
+	for (i = 0; customizable_list[i]; i++) {
+		if (strcmp(customizable_list[i], type) == 0) {
+			context_free(c);
+			return 1;
+		}
+	}
+	context_free(c);
 	return 0;
 }
diff --git a/libselinux/src/label.c b/libselinux/src/label.c
index 492643b..951031e 100644
--- a/libselinux/src/label.c
+++ b/libselinux/src/label.c
@@ -56,6 +56,15 @@ static selabel_initfunc initfuncs[] = {
 
 static void selabel_subs_fini(struct selabel_sub *ptr)
 {
+	struct selabel_sub *next;
+
+	while (ptr) {
+		next = ptr->next;
+		free(ptr->src);
+		free(ptr->dst);
+		free(ptr);
+		ptr = next;
+	}
 }
 
 static char *selabel_sub(struct selabel_sub *ptr, const char *src)
@@ -220,7 +229,18 @@ static inline int selabel_is_validate_set(const struct selinux_opt *opts,
 int selabel_validate(struct selabel_handle *rec,
 		     struct selabel_lookup_rec *contexts)
 {
-        return 0;
+	int rc = 0;
+
+	if (!rec->validating || contexts->validated)
+		goto out;
+
+	rc = selinux_validate(&contexts->ctx_raw);
+	if (rc < 0)
+		goto out;
+
+	contexts->validated = 1;
+out:
+	return rc;
 }
 
 /* Public API helpers */
@@ -362,49 +382,132 @@ out:
 int selabel_lookup(struct selabel_handle *rec, char **con,
 		   const char *key, int type)
 {
-        return 0;
+	struct selabel_lookup_rec *lr;
+
+	lr = selabel_lookup_common(rec, 1, key, type);
+	if (!lr)
+		return -1;
+
+	*con = strdup(lr->ctx_trans);
+	return *con ? 0 : -1;
 }
 
 int selabel_lookup_raw(struct selabel_handle *rec, char **con,
 		       const char *key, int type)
 {
-        return 0;
+	struct selabel_lookup_rec *lr;
+
+	lr = selabel_lookup_common(rec, 0, key, type);
+	if (!lr)
+		return -1;
+
+	*con = strdup(lr->ctx_raw);
+	return *con ? 0 : -1;
 }
 
 bool selabel_partial_match(struct selabel_handle *rec, const char *key)
 {
-        return 0;
+	char *ptr;
+	bool ret;
+
+	if (!rec->func_partial_match) {
+		/*
+		 * If the label backend does not support partial matching,
+		 * then assume a match is possible.
+		 */
+		return true;
+	}
+
+	ptr = selabel_sub_key(rec, key);
+	if (ptr) {
+		ret = rec->func_partial_match(rec, ptr);
+		free(ptr);
+	} else {
+		ret = rec->func_partial_match(rec, key);
+	}
+
+	return ret;
 }
 
 int selabel_lookup_best_match(struct selabel_handle *rec, char **con,
 			      const char *key, const char **aliases, int type)
 {
-        return 0;
+	struct selabel_lookup_rec *lr;
+
+	if (!rec->func_lookup_best_match) {
+		errno = ENOTSUP;
+		return -1;
+	}
+
+	lr = selabel_lookup_bm_common(rec, 1, key, type, aliases);
+	if (!lr)
+		return -1;
+
+	*con = strdup(lr->ctx_trans);
+	return *con ? 0 : -1;
 }
 
 int selabel_lookup_best_match_raw(struct selabel_handle *rec, char **con,
 			      const char *key, const char **aliases, int type)
 {
-        return 0;
+	struct selabel_lookup_rec *lr;
+
+	if (!rec->func_lookup_best_match) {
+		errno = ENOTSUP;
+		return -1;
+	}
+
+	lr = selabel_lookup_bm_common(rec, 0, key, type, aliases);
+	if (!lr)
+		return -1;
+
+	*con = strdup(lr->ctx_raw);
+	return *con ? 0 : -1;
 }
 
 enum selabel_cmp_result selabel_cmp(struct selabel_handle *h1,
 				    struct selabel_handle *h2)
 {
-        return 0;
+	if (!h1->func_cmp || h1->func_cmp != h2->func_cmp)
+		return SELABEL_INCOMPARABLE;
+
+	return h1->func_cmp(h1, h2);
 }
 
 int selabel_digest(struct selabel_handle *rec,
 				    unsigned char **digest, size_t *digest_len,
 				    char ***specfiles, size_t *num_specfiles)
 {
+	if (!rec->digest) {
+		errno = EINVAL;
+		return -1;
+	}
+
+	*digest = rec->digest->digest;
+	*digest_len = DIGEST_SPECFILE_SIZE;
+	*specfiles = rec->digest->specfile_list;
+	*num_specfiles = rec->digest->specfile_cnt;
 	return 0;
 }
 
 void selabel_close(struct selabel_handle *rec)
 {
+	size_t i;
+	selabel_subs_fini(rec->subs);
+	selabel_subs_fini(rec->dist_subs);
+	if (rec->spec_files) {
+		for (i = 0; i < rec->spec_files_len; i++)
+			free(rec->spec_files[i]);
+		free(rec->spec_files);
+	}
+	if (rec->digest)
+		selabel_digest_fini(rec->digest);
+	if (rec->func_close)
+		rec->func_close(rec);
+	free(rec);
 }
 
 void selabel_stats(struct selabel_handle *rec)
 {
+	rec->func_stats(rec);
 }
diff --git a/libselinux/src/label_backends_android.c b/libselinux/src/label_backends_android.c
index 74738d6..6435df8 100644
--- a/libselinux/src/label_backends_android.c
+++ b/libselinux/src/label_backends_android.c
@@ -31,7 +31,17 @@ struct saved_data {
 
 static int cmp(const void *A, const void *B)
 {
-	return 0;
+	const struct spec *sp1 = A, *sp2 = B;
+
+	if (strncmp(sp1->property_key, "*", 1) == 0)
+		return 1;
+	if (strncmp(sp2->property_key, "*", 1) == 0)
+		return -1;
+
+	size_t L1 = strlen(sp1->property_key);
+	size_t L2 = strlen(sp2->property_key);
+
+	return (L1 < L2) - (L1 > L2);
 }
 
 /*
@@ -356,11 +366,33 @@ int selabel_property_init(struct selabel_handle *rec,
 			  const struct selinux_opt *opts,
 			  unsigned nopts)
 {
-        return 0;
+	struct saved_data *data;
+
+	data = (struct saved_data *)calloc(1, sizeof(*data));
+	if (!data)
+		return -1;
+
+	rec->data = data;
+	rec->func_close = &closef;
+	rec->func_stats = &stats;
+	rec->func_lookup = &property_lookup;
+
+	return init(rec, opts, nopts);
 }
 
 int selabel_service_init(struct selabel_handle *rec,
 		const struct selinux_opt *opts, unsigned nopts)
 {
-        return 0;
+	struct saved_data *data;
+
+	data = (struct saved_data *)calloc(1, sizeof(*data));
+	if (!data)
+		return -1;
+
+	rec->data = data;
+	rec->func_close = &closef;
+	rec->func_stats = &stats;
+	rec->func_lookup = &service_lookup;
+
+	return init(rec, opts, nopts);
 }
diff --git a/libselinux/src/label_db.c b/libselinux/src/label_db.c
index f323bbb..c46d0a1 100644
--- a/libselinux/src/label_db.c
+++ b/libselinux/src/label_db.c
@@ -350,5 +350,10 @@ out_error:
 int selabel_db_init(struct selabel_handle *rec,
 		    const struct selinux_opt *opts, unsigned nopts)
 {
-        return 0;
+	rec->func_close = &db_close;
+	rec->func_lookup = &db_lookup;
+	rec->func_stats = &db_stats;
+	rec->data = db_init(opts, nopts, rec);
+
+	return !rec->data ? -1 : 0;
 }
diff --git a/libselinux/src/label_file.c b/libselinux/src/label_file.c
index 52cdc04..18e26fb 100644
--- a/libselinux/src/label_file.c
+++ b/libselinux/src/label_file.c
@@ -1003,5 +1003,20 @@ int selabel_file_init(struct selabel_handle *rec,
 				    const struct selinux_opt *opts,
 				    unsigned nopts)
 {
-        return 0;
+	struct saved_data *data;
+
+	data = (struct saved_data *)malloc(sizeof(*data));
+	if (!data)
+		return -1;
+	memset(data, 0, sizeof(*data));
+
+	rec->data = data;
+	rec->func_close = &closef;
+	rec->func_stats = &stats;
+	rec->func_lookup = &lookup;
+	rec->func_partial_match = &partial_match;
+	rec->func_lookup_best_match = &lookup_best_match;
+	rec->func_cmp = &cmp;
+
+	return init(rec, opts, nopts);
 }
diff --git a/libselinux/src/label_media.c b/libselinux/src/label_media.c
index c09a9b0..622741b 100644
--- a/libselinux/src/label_media.c
+++ b/libselinux/src/label_media.c
@@ -210,5 +210,17 @@ int selabel_media_init(struct selabel_handle *rec,
 				    const struct selinux_opt *opts,
 				    unsigned nopts)
 {
-        return 0;
+	struct saved_data *data;
+
+	data = (struct saved_data *)malloc(sizeof(*data));
+	if (!data)
+		return -1;
+	memset(data, 0, sizeof(*data));
+
+	rec->data = data;
+	rec->func_close = &close;
+	rec->func_lookup = &lookup;
+	rec->func_stats = &stats;
+
+	return init(rec, opts, nopts);
 }
diff --git a/libselinux/src/label_support.c b/libselinux/src/label_support.c
index f866c16..26f9ef1 100644
--- a/libselinux/src/label_support.c
+++ b/libselinux/src/label_support.c
@@ -65,12 +65,68 @@ static inline int read_spec_entry(char **entry, char **ptr, int *len, const char
  */
 int hidden read_spec_entries(char *line_buf, const char **errbuf, int num_args, ...)
 {
-        return 0;
+	char **spec_entry, *buf_p;
+	int len, rc, items, entry_len = 0;
+	va_list ap;
+
+	*errbuf = NULL;
+
+	len = strlen(line_buf);
+	if (line_buf[len - 1] == '\n')
+		line_buf[len - 1] = '\0';
+	else
+		/* Handle case if line not \n terminated by bumping
+		 * the len for the check below (as the line is NUL
+		 * terminated by getline(3)) */
+		len++;
+
+	buf_p = line_buf;
+	while (isspace(*buf_p))
+		buf_p++;
+
+	/* Skip comment lines and empty lines. */
+	if (*buf_p == '#' || *buf_p == '\0')
+		return 0;
+
+	/* Process the spec file entries */
+	va_start(ap, num_args);
+
+	items = 0;
+	while (items < num_args) {
+		spec_entry = va_arg(ap, char **);
+
+		if (len - 1 == buf_p - line_buf) {
+			va_end(ap);
+			return items;
+		}
+
+		rc = read_spec_entry(spec_entry, &buf_p, &entry_len, errbuf);
+		if (rc < 0) {
+			va_end(ap);
+			return rc;
+		}
+		if (entry_len)
+			items++;
+	}
+	va_end(ap);
+	return items;
 }
 
 /* Once all the specfiles are in the hash_buf, generate the hash. */
 void hidden digest_gen_hash(struct selabel_digest *digest)
 {
+	Sha1Context context;
+
+	/* If SELABEL_OPT_DIGEST not set then just return */
+	if (!digest)
+		return;
+
+	Sha1Initialise(&context);
+	Sha1Update(&context, digest->hashbuf, digest->hashbuf_size);
+	Sha1Finalise(&context, (SHA1_HASH *)digest->digest);
+	free(digest->hashbuf);
+	digest->hashbuf = NULL;
+	return;
 }
 
 /**
@@ -89,5 +145,48 @@ int hidden digest_add_specfile(struct selabel_digest *digest, FILE *fp,
 				    char *from_addr, size_t buf_len,
 				    const char *path)
 {
-        return 0;
+	unsigned char *tmp_buf;
+
+	/* If SELABEL_OPT_DIGEST not set then just return */
+	if (!digest)
+		return 0;
+
+	if (digest->hashbuf_size + buf_len < digest->hashbuf_size) {
+		errno = EOVERFLOW;
+		return -1;
+	}
+	digest->hashbuf_size += buf_len;
+
+	tmp_buf = realloc(digest->hashbuf, digest->hashbuf_size);
+	if (!tmp_buf)
+		return -1;
+
+	digest->hashbuf = tmp_buf;
+
+	if (fp) {
+		rewind(fp);
+		if (fread(digest->hashbuf + (digest->hashbuf_size - buf_len),
+					    1, buf_len, fp) != buf_len)
+			return -1;
+
+		rewind(fp);
+	} else if (from_addr) {
+		tmp_buf = memcpy(digest->hashbuf +
+				    (digest->hashbuf_size - buf_len),
+				    from_addr, buf_len);
+		if (!tmp_buf)
+			return -1;
+	}
+	/* Now add path to list */
+	digest->specfile_list[digest->specfile_cnt] = strdup(path);
+	if (!digest->specfile_list[digest->specfile_cnt])
+		return -1;
+
+	digest->specfile_cnt++;
+	if (digest->specfile_cnt > DIGEST_FILES_MAX) {
+		errno = EOVERFLOW;
+		return -1;
+	}
+
+	return 0;
 }
diff --git a/libselinux/src/label_x.c b/libselinux/src/label_x.c
index ee476bc..700def1 100644
--- a/libselinux/src/label_x.c
+++ b/libselinux/src/label_x.c
@@ -235,5 +235,17 @@ static void stats(struct selabel_handle *rec)
 int selabel_x_init(struct selabel_handle *rec, const struct selinux_opt *opts,
 		   unsigned nopts)
 {
-        return 0;
+	struct saved_data *data;
+
+	data = (struct saved_data *)malloc(sizeof(*data));
+	if (!data)
+		return -1;
+	memset(data, 0, sizeof(*data));
+
+	rec->data = data;
+	rec->func_close = &close;
+	rec->func_lookup = &lookup;
+	rec->func_stats = &stats;
+
+	return init(rec, opts, nopts);
 }
diff --git a/libselinux/src/lgetfilecon.c b/libselinux/src/lgetfilecon.c
index 9737e0f..db67bc6 100644
--- a/libselinux/src/lgetfilecon.c
+++ b/libselinux/src/lgetfilecon.c
@@ -9,12 +9,63 @@
 
 int lgetfilecon_raw(const char *path, char ** context)
 {
-        return 0;
+	char *buf;
+	ssize_t size;
+	ssize_t ret;
+
+	size = INITCONTEXTLEN + 1;
+	buf = malloc(size);
+	if (!buf)
+		return -1;
+	memset(buf, 0, size);
+
+	ret = lgetxattr(path, XATTR_NAME_SELINUX, buf, size - 1);
+	if (ret < 0 && errno == ERANGE) {
+		char *newbuf;
+
+		size = lgetxattr(path, XATTR_NAME_SELINUX, NULL, 0);
+		if (size < 0)
+			goto out;
+
+		size++;
+		newbuf = realloc(buf, size);
+		if (!newbuf)
+			goto out;
+
+		buf = newbuf;
+		memset(buf, 0, size);
+		ret = lgetxattr(path, XATTR_NAME_SELINUX, buf, size - 1);
+	}
+      out:
+	if (ret == 0) {
+		/* Re-map empty attribute values to errors. */
+		errno = ENOTSUP;
+		ret = -1;
+	}
+	if (ret < 0)
+		free(buf);
+	else
+		*context = buf;
+	return ret;
 }
 
 hidden_def(lgetfilecon_raw)
 
 int lgetfilecon(const char *path, char ** context)
 {
-        return 0;
+	int ret;
+	char * rcontext = NULL;
+
+	*context = NULL;
+
+	ret = lgetfilecon_raw(path, &rcontext);
+
+	if (ret > 0) {
+		ret = selinux_raw_to_trans_context(rcontext, context);
+		freecon(rcontext);
+	}
+
+	if (ret >= 0 && *context)
+		return strlen(*context) + 1;
+	return ret;
 }
diff --git a/libselinux/src/load_policy.c b/libselinux/src/load_policy.c
index 95f2fa5..b7e1a6f 100644
--- a/libselinux/src/load_policy.c
+++ b/libselinux/src/load_policy.c
@@ -25,7 +25,24 @@
 
 int security_load_policy(void *data, size_t len)
 {
-        return 0;
+	char path[PATH_MAX];
+	int fd, ret;
+
+	if (!selinux_mnt) {
+		errno = ENOENT;
+		return -1;
+	}
+
+	snprintf(path, sizeof path, "%s/load", selinux_mnt);
+	fd = open(path, O_RDWR);
+	if (fd < 0)
+		return -1;
+
+	ret = write(fd, data, len);
+	close(fd);
+	if (ret < 0)
+		return -1;
+	return 0;
 }
 
 hidden_def(security_load_policy)
@@ -37,8 +54,254 @@ int load_setlocaldefs hidden = 1;
 #define max(a, b) (((a) > (b)) ? (a) : (b))
 
 int selinux_mkload_policy(int preservebools)
-{
-        return 0;
+{	
+	int kernvers = security_policyvers();
+	int maxvers = kernvers, minvers = DEFAULT_POLICY_VERSION, vers;
+	int setlocaldefs = load_setlocaldefs;
+	char path[PATH_MAX];
+	struct stat sb;
+	struct utsname uts;
+	size_t size;
+	void *map, *data;
+	int fd, rc = -1, prot;
+	sepol_policydb_t *policydb;
+	sepol_policy_file_t *pf;
+	int usesepol = 0;
+	int (*vers_max)(void) = NULL;
+	int (*vers_min)(void) = NULL;
+	int (*policy_file_create)(sepol_policy_file_t **) = NULL;
+	void (*policy_file_free)(sepol_policy_file_t *) = NULL;
+	void (*policy_file_set_mem)(sepol_policy_file_t *, char*, size_t) = NULL;
+	int (*policydb_create)(sepol_policydb_t **) = NULL;
+	void (*policydb_free)(sepol_policydb_t *) = NULL;
+	int (*policydb_read)(sepol_policydb_t *, sepol_policy_file_t *) = NULL;
+	int (*policydb_set_vers)(sepol_policydb_t *, unsigned int) = NULL;
+	int (*policydb_to_image)(sepol_handle_t *, sepol_policydb_t *, void **, size_t *) = NULL;
+	int (*genbools_array)(void *data, size_t len, char **names, int *values, int nel) = NULL;
+	int (*genusers)(void *data, size_t len, const char *usersdir, void **newdata, size_t * newlen) = NULL;
+	int (*genbools)(void *data, size_t len, char *boolpath) = NULL;
+
+#ifdef SHARED
+	char *errormsg = NULL;
+	void *libsepolh = NULL;
+	libsepolh = dlopen("libsepol.so.1", RTLD_NOW);
+	if (libsepolh) {
+		usesepol = 1;
+		dlerror();
+#define DLERR() if ((errormsg = dlerror())) goto dlclose;
+		vers_max = dlsym(libsepolh, "sepol_policy_kern_vers_max");
+		DLERR();
+		vers_min = dlsym(libsepolh, "sepol_policy_kern_vers_min");
+		DLERR();
+
+		policy_file_create = dlsym(libsepolh, "sepol_policy_file_create");
+		DLERR();
+		policy_file_free = dlsym(libsepolh, "sepol_policy_file_free");
+		DLERR();
+		policy_file_set_mem = dlsym(libsepolh, "sepol_policy_file_set_mem");
+		DLERR();
+		policydb_create = dlsym(libsepolh, "sepol_policydb_create");
+		DLERR();
+		policydb_free = dlsym(libsepolh, "sepol_policydb_free");
+		DLERR();
+		policydb_read = dlsym(libsepolh, "sepol_policydb_read");
+		DLERR();
+		policydb_set_vers = dlsym(libsepolh, "sepol_policydb_set_vers");
+		DLERR();
+		policydb_to_image = dlsym(libsepolh, "sepol_policydb_to_image");
+		DLERR();
+		genbools_array = dlsym(libsepolh, "sepol_genbools_array");
+		DLERR();
+		genusers = dlsym(libsepolh, "sepol_genusers");
+		DLERR();
+		genbools = dlsym(libsepolh, "sepol_genbools");
+		DLERR();
+
+#undef DLERR
+	}
+#else
+	usesepol = 1;
+	vers_max = sepol_policy_kern_vers_max;
+	vers_min = sepol_policy_kern_vers_min;
+	policy_file_create = sepol_policy_file_create;
+	policy_file_free = sepol_policy_file_free;
+	policy_file_set_mem = sepol_policy_file_set_mem;
+	policydb_create = sepol_policydb_create;
+	policydb_free = sepol_policydb_free;
+	policydb_read = sepol_policydb_read;
+	policydb_set_vers = sepol_policydb_set_vers;
+	policydb_to_image = sepol_policydb_to_image;
+	genbools_array = sepol_genbools_array;
+	genusers = sepol_genusers;
+	genbools = sepol_genbools;
+
+#endif
+
+	/*
+	 * Check whether we need to support local boolean and user definitions.
+	 */
+	if (setlocaldefs) {
+		if (access(selinux_booleans_path(), F_OK) == 0)
+			goto checkbool;
+		snprintf(path, sizeof path, "%s.local", selinux_booleans_path());
+		if (access(path, F_OK) == 0)
+			goto checkbool;
+		snprintf(path, sizeof path, "%s/local.users", selinux_users_path());
+		if (access(path, F_OK) == 0)
+			goto checkbool;
+		/* No local definition files, so disable setlocaldefs. */
+		setlocaldefs = 0;
+	}
+
+checkbool:
+	/* 
+	 * As of Linux 2.6.22, the kernel preserves boolean
+	 * values across a reload, so we do not need to 
+	 * preserve them in userspace.
+	 */
+	if (preservebools && uname(&uts) == 0 && strverscmp(uts.release, "2.6.22") >= 0)
+		preservebools = 0;
+
+	if (usesepol) {
+		maxvers = vers_max();
+		minvers = vers_min();
+		if (!setlocaldefs && !preservebools)
+			maxvers = max(kernvers, maxvers);
+	}
+
+	vers = maxvers;
+      search:
+	snprintf(path, sizeof(path), "%s.%d",
+		 selinux_binary_policy_path(), vers);
+	fd = open(path, O_RDONLY);
+	while (fd < 0 && errno == ENOENT
+	       && --vers >= minvers) {
+		/* Check prior versions to see if old policy is available */
+		snprintf(path, sizeof(path), "%s.%d",
+			 selinux_binary_policy_path(), vers);
+		fd = open(path, O_RDONLY);
+	}
+	if (fd < 0) {
+		fprintf(stderr,
+			"SELinux:  Could not open policy file <= %s.%d:  %s\n",
+			selinux_binary_policy_path(), maxvers, strerror(errno));
+		goto dlclose;
+	}
+
+	if (fstat(fd, &sb) < 0) {
+		fprintf(stderr,
+			"SELinux:  Could not stat policy file %s:  %s\n",
+			path, strerror(errno));
+		goto close;
+	}
+
+	prot = PROT_READ;
+	if (setlocaldefs || preservebools)
+		prot |= PROT_WRITE;
+
+	size = sb.st_size;
+	data = map = mmap(NULL, size, prot, MAP_PRIVATE, fd, 0);
+	if (map == MAP_FAILED) {
+		fprintf(stderr,
+			"SELinux:  Could not map policy file %s:  %s\n",
+			path, strerror(errno));
+		goto close;
+	}
+
+	if (vers > kernvers && usesepol) {
+		/* Need to downgrade to kernel-supported version. */
+		if (policy_file_create(&pf))
+			goto unmap;
+		if (policydb_create(&policydb)) {
+			policy_file_free(pf);
+			goto unmap;
+		}
+		policy_file_set_mem(pf, data, size);
+		if (policydb_read(policydb, pf)) {
+			policy_file_free(pf);
+			policydb_free(policydb);
+			goto unmap;
+		}
+		if (policydb_set_vers(policydb, kernvers) ||
+		    policydb_to_image(NULL, policydb, &data, &size)) {
+			/* Downgrade failed, keep searching. */
+			fprintf(stderr,
+				"SELinux:  Could not downgrade policy file %s, searching for an older version.\n",
+				path);
+			policy_file_free(pf);
+			policydb_free(policydb);
+			munmap(map, sb.st_size);
+			close(fd);
+			vers--;
+			goto search;
+		}
+		policy_file_free(pf);
+		policydb_free(policydb);
+	}
+
+	if (usesepol) {
+		if (setlocaldefs) {
+			void *olddata = data;
+			size_t oldsize = size;
+			rc = genusers(olddata, oldsize, selinux_users_path(),
+				      &data, &size);
+			if (rc < 0) {
+				/* Fall back to the prior image if genusers failed. */
+				data = olddata;
+				size = oldsize;
+				rc = 0;
+			} else {
+				if (olddata != map)
+					free(olddata);
+			}
+		}
+		
+		if (preservebools) {
+			int *values, len, i;
+			char **names;
+			rc = security_get_boolean_names(&names, &len);
+			if (!rc) {
+				values = malloc(sizeof(int) * len);
+				if (!values)
+					goto unmap;
+				for (i = 0; i < len; i++)
+					values[i] =
+						security_get_boolean_active(names[i]);
+				(void)genbools_array(data, size, names, values,
+						     len);
+				free(values);
+				for (i = 0; i < len; i++)
+					free(names[i]);
+				free(names);
+			}
+		} else if (setlocaldefs) {
+			(void)genbools(data, size,
+				       (char *)selinux_booleans_path());
+		}
+	}
+
+
+	rc = security_load_policy(data, size);
+	
+	if (rc)
+		fprintf(stderr,
+			"SELinux:  Could not load policy file %s:  %s\n",
+			path, strerror(errno));
+
+      unmap:
+	if (data != map)
+		free(data);
+	munmap(map, sb.st_size);
+      close:
+	close(fd);
+      dlclose:
+#ifdef SHARED
+	if (errormsg)
+		fprintf(stderr, "libselinux:  %s\n", errormsg);
+	if (libsepolh)
+		dlclose(libsepolh);
+#endif
+	return rc;
 }
 
 hidden_def(selinux_mkload_policy)
@@ -53,6 +316,154 @@ hidden_def(selinux_mkload_policy)
  */
 int selinux_init_load_policy(int *enforce)
 {
-        return 0;
+	int rc = 0, orig_enforce = 0, seconfig = -2, secmdline = -1;
+	FILE *cfg;
+	char *buf;
+
+	/*
+	 * Reread the selinux configuration in case it has changed.
+	 * Example:  Caller has chroot'd and is now loading policy from
+	 * chroot'd environment.
+	 */
+	selinux_reset_config();
+
+	/*
+	 * Get desired mode (disabled, permissive, enforcing) from 
+	 * /etc/selinux/config. 
+	 */
+	selinux_getenforcemode(&seconfig);
+
+	/* Check for an override of the mode via the kernel command line. */
+	rc = mount("proc", "/proc", "proc", 0, 0);
+	cfg = fopen("/proc/cmdline", "r");
+	if (cfg) {
+		char *tmp;
+		buf = malloc(selinux_page_size);
+		if (!buf) {
+			fclose(cfg);
+			return -1;
+		}
+		if (fgets(buf, selinux_page_size, cfg) &&
+		    (tmp = strstr(buf, "enforcing="))) {
+			if (tmp == buf || isspace(*(tmp - 1))) {
+				secmdline =
+				    atoi(tmp + sizeof("enforcing=") - 1);
+			}
+		}
+		fclose(cfg);
+		free(buf);
+	}
+
+	/* 
+	 * Determine the final desired mode.
+	 * Command line argument takes precedence, then config file. 
+	 */
+	if (secmdline >= 0)
+		*enforce = secmdline;
+	else if (seconfig >= 0)
+		*enforce = seconfig;
+	else
+		*enforce = 0;	/* unspecified or disabled */
+
+	/*
+	 * Check for the existence of SELinux via selinuxfs, and 
+	 * mount it if present for use in the calls below.  
+	 */
+	const char *mntpoint = NULL;
+	/* First make sure /sys is mounted */
+	if (mount("sysfs", "/sys", "sysfs", 0, 0) == 0 || errno == EBUSY) {
+		if (mount(SELINUXFS, SELINUXMNT, SELINUXFS, 0, 0) == 0 || errno == EBUSY) {
+			mntpoint = SELINUXMNT;
+		} else {
+			/* check old mountpoint */
+			if (mount(SELINUXFS, OLDSELINUXMNT, SELINUXFS, 0, 0) == 0 || errno == EBUSY) {
+				mntpoint = OLDSELINUXMNT;
+			}
+		}
+	} else {
+		/* check old mountpoint */
+		if (mount(SELINUXFS, OLDSELINUXMNT, SELINUXFS, 0, 0) == 0 || errno == EBUSY) {
+			mntpoint = OLDSELINUXMNT;
+		}
+	}
+
+	if (! mntpoint ) {
+		if (errno == ENODEV || !selinuxfs_exists()) {
+			/*
+			 * SELinux was disabled in the kernel, either
+			 * omitted entirely or disabled at boot via selinux=0.
+			 * This takes precedence over any config or
+			 * commandline enforcing setting.
+			 */
+			*enforce = 0;
+		} else {
+			/* Only emit this error if selinux was not disabled */
+			fprintf(stderr, "Mount failed for selinuxfs on %s:  %s\n", SELINUXMNT, strerror(errno));
+		}
+
+		if (rc == 0)
+			umount2("/proc", MNT_DETACH);
+                
+		goto noload;
+	}
+	set_selinuxmnt(mntpoint);
+
+	if (rc == 0)
+		umount2("/proc", MNT_DETACH);
+
+	/*
+	 * Note:  The following code depends on having selinuxfs 
+	 * already mounted and selinuxmnt set above.
+	 */
+
+	if (seconfig == -1) {
+		/* Runtime disable of SELinux. */
+		rc = security_disable();
+		if (rc == 0) {
+			/* Successfully disabled, so umount selinuxfs too. */
+			umount(selinux_mnt);
+			fini_selinuxmnt();
+			goto noload;
+		} else {
+			/*
+			 * It's possible that this failed because policy has
+			 * already been loaded. We can't disable SELinux now,
+			 * so the best we can do is force it to be permissive.
+			 */
+			*enforce = 0;
+		}
+	}
+
+	/*
+	 * If necessary, change the kernel enforcing status to match 
+	 * the desired mode. 
+	 */
+	orig_enforce = rc = security_getenforce();
+	if (rc < 0)
+		goto noload;
+	if (orig_enforce != *enforce) {
+		rc = security_setenforce(*enforce);
+		if (rc < 0) {
+			fprintf(stderr, "SELinux:  Unable to switch to %s mode:  %s\n", (*enforce ? "enforcing" : "permissive"), strerror(errno));
+			if (*enforce)
+				goto noload;
+		}
+	}
+
+	if (seconfig == -1)
+		goto noload;
+
+	/* Load the policy. */
+	return selinux_mkload_policy(0);
+
+      noload:
+	/*
+	 * Only return 0 on a successful completion of policy load.
+	 * In any other case, we want to return an error so that init
+	 * knows not to proceed with the re-exec for the domain transition.
+	 * Depending on the *enforce setting, init will halt (> 0) or proceed
+	 * normally (otherwise).
+	 */
+	return -1;
 }
 #endif
diff --git a/libselinux/src/lsetfilecon.c b/libselinux/src/lsetfilecon.c
index 9aabb0f..1d3b28a 100644
--- a/libselinux/src/lsetfilecon.c
+++ b/libselinux/src/lsetfilecon.c
@@ -9,12 +9,35 @@
 
 int lsetfilecon_raw(const char *path, const char * context)
 {
-        return 0;
+	int rc = lsetxattr(path, XATTR_NAME_SELINUX, context, strlen(context) + 1,
+			 0);
+	if (rc < 0 && errno == ENOTSUP) {
+		char * ccontext = NULL;
+		int err = errno;
+		if ((lgetfilecon_raw(path, &ccontext) >= 0) &&
+		    (strcmp(context,ccontext) == 0)) {
+			rc = 0;
+		} else {
+			errno = err;
+		}
+		freecon(ccontext);
+	}
+	return rc;
 }
 
 hidden_def(lsetfilecon_raw)
 
 int lsetfilecon(const char *path, const char *context)
 {
-        return 0;
+	int ret;
+	char * rcontext;
+
+	if (selinux_trans_to_raw_context(context, &rcontext))
+		return -1;
+
+	ret = lsetfilecon_raw(path, rcontext);
+
+	freecon(rcontext);
+
+	return ret;
 }
diff --git a/libselinux/src/mapping.c b/libselinux/src/mapping.c
index 861fc32..f205804 100644
--- a/libselinux/src/mapping.c
+++ b/libselinux/src/mapping.c
@@ -30,7 +30,66 @@ static security_class_t current_mapping_size = 0;
 int
 selinux_set_mapping(struct security_class_mapping *map)
 {
+	size_t size = sizeof(struct selinux_mapping);
+	security_class_t i, j;
+	unsigned k;
+
+	free(current_mapping);
+	current_mapping = NULL;
+	current_mapping_size = 0;
+
+	if (avc_reset() < 0)
+		goto err;
+
+	/* Find number of classes in the input mapping */
+	if (!map) {
+		errno = EINVAL;
+		goto err;
+	}
+	i = 0;
+	while (map[i].name)
+		i++;
+
+	/* Allocate space for the class records, plus one for class zero */
+	current_mapping = (struct selinux_mapping *)calloc(++i, size);
+	if (!current_mapping)
+		goto err;
+
+	/* Store the raw class and permission values */
+	j = 0;
+	while (map[j].name) {
+		struct security_class_mapping *p_in = map + (j++);
+		struct selinux_mapping *p_out = current_mapping + j;
+
+		p_out->value = string_to_security_class(p_in->name);
+		if (!p_out->value)
+			goto err2;
+
+		k = 0;
+		while (p_in->perms[k]) {
+			/* An empty permission string skips ahead */
+			if (!*p_in->perms[k]) {
+				k++;
+				continue;
+			}
+			p_out->perms[k] = string_to_av_perm(p_out->value,
+							    p_in->perms[k]);
+			if (!p_out->perms[k])
+				goto err2;
+			k++;
+		}
+		p_out->num_perms = k;
+	}
+
+	/* Set the mapping size here so the above lookups are "raw" */
+	current_mapping_size = i;
 	return 0;
+err2:
+	free(current_mapping);
+	current_mapping = NULL;
+	current_mapping_size = 0;
+err:
+	return -1;
 }
 
 /*
@@ -40,13 +99,40 @@ selinux_set_mapping(struct security_class_mapping *map)
 security_class_t
 unmap_class(security_class_t tclass)
 {
-	return 0;
+	if (tclass < current_mapping_size)
+		return current_mapping[tclass].value;
+
+	/* If here no mapping set or the class requested is not valid. */
+	if (current_mapping_size != 0) {
+		errno = EINVAL;
+		return 0;
+	}
+	else
+		return tclass;
 }
 
 access_vector_t
 unmap_perm(security_class_t tclass, access_vector_t tperm)
 {
-        return 0;
+	if (tclass < current_mapping_size) {
+		unsigned i;
+		access_vector_t kperm = 0;
+
+		for (i=0; i<current_mapping[tclass].num_perms; i++)
+			if (tperm & (1<<i)) {
+				kperm |= current_mapping[tclass].perms[i];
+				tperm &= ~(1<<i);
+			}
+		return kperm;
+	}
+
+	/* If here no mapping set or the perm requested is not valid. */
+	if (current_mapping_size != 0) {
+		errno = EINVAL;
+		return 0;
+	}
+	else
+		return tperm;
 }
 
 /*
@@ -56,16 +142,69 @@ unmap_perm(security_class_t tclass, access_vector_t tperm)
 security_class_t
 map_class(security_class_t kclass)
 {
-	return 0;
+	security_class_t i;
+
+	for (i=0; i<current_mapping_size; i++)
+		if (current_mapping[i].value == kclass)
+			return i;
+
+/* If here no mapping set or the class requested is not valid. */
+	if (current_mapping_size != 0) {
+		errno = EINVAL;
+		return 0;
+	}
+	else
+		return kclass;
 }
 
 access_vector_t
 map_perm(security_class_t tclass, access_vector_t kperm)
 {
-        return 0;
+	if (tclass < current_mapping_size) {
+		unsigned i;
+		access_vector_t tperm = 0;
+
+		for (i=0; i<current_mapping[tclass].num_perms; i++)
+			if (kperm & current_mapping[tclass].perms[i]) {
+				tperm |= 1<<i;
+				kperm &= ~current_mapping[tclass].perms[i];
+			}
+
+		if (tperm == 0) {
+			errno = EINVAL;
+			return 0;
+		}
+		else
+			return tperm;
+	}
+	return kperm;
 }
 
 void
 map_decision(security_class_t tclass, struct av_decision *avd)
 {
+	if (tclass < current_mapping_size) {
+		unsigned i;
+		access_vector_t result;
+
+		for (i=0, result=0; i<current_mapping[tclass].num_perms; i++)
+			if (avd->allowed & current_mapping[tclass].perms[i])
+				result |= 1<<i;
+		avd->allowed = result;
+
+		for (i=0, result=0; i<current_mapping[tclass].num_perms; i++)
+			if (avd->decided & current_mapping[tclass].perms[i])
+				result |= 1<<i;
+		avd->decided = result;
+
+		for (i=0, result=0; i<current_mapping[tclass].num_perms; i++)
+			if (avd->auditallow & current_mapping[tclass].perms[i])
+				result |= 1<<i;
+		avd->auditallow = result;
+
+		for (i=0, result=0; i<current_mapping[tclass].num_perms; i++)
+			if (avd->auditdeny & current_mapping[tclass].perms[i])
+				result |= 1<<i;
+		avd->auditdeny = result;
+	}
 }
diff --git a/libselinux/src/matchmediacon.c b/libselinux/src/matchmediacon.c
index 76bf08b..46cba46 100644
--- a/libselinux/src/matchmediacon.c
+++ b/libselinux/src/matchmediacon.c
@@ -13,5 +13,55 @@
 
 int matchmediacon(const char *media, char ** con)
 {
-        return 0;
+	const char *path = selinux_media_context_path();
+	FILE *infile;
+	char *ptr, *ptr2 = NULL;
+	int found = 0;
+	char current_line[PATH_MAX];
+	if ((infile = fopen(path, "r")) == NULL)
+		return -1;
+	while (!feof_unlocked(infile)) {
+		if (!fgets_unlocked(current_line, sizeof(current_line), infile)) {
+			return -1;
+		}
+		if (current_line[strlen(current_line) - 1])
+			current_line[strlen(current_line) - 1] = 0;
+		/* Skip leading whitespace before the partial context. */
+		ptr = current_line;
+		while (*ptr && isspace(*ptr))
+			ptr++;
+
+		if (!(*ptr))
+			continue;
+
+		/* Find the end of the media context. */
+		ptr2 = ptr;
+		while (*ptr2 && !isspace(*ptr2))
+			ptr2++;
+		if (!(*ptr2))
+			continue;
+
+		*ptr2++ = 0;
+		if (strcmp(media, ptr) == 0) {
+			found = 1;
+			break;
+		}
+	}
+	fclose(infile);
+	if (!found)
+		return -1;
+
+	/* Skip whitespace. */
+	while (*ptr2 && isspace(*ptr2))
+		ptr2++;
+	if (!(*ptr2)) {
+		return -1;
+	}
+
+	if (selinux_raw_to_trans_context(ptr2, con)) {
+		*con = NULL;
+		return -1;
+	}
+
+	return 0;
 }
diff --git a/libselinux/src/matchpathcon.c b/libselinux/src/matchpathcon.c
index 44f7560..58b4144 100644
--- a/libselinux/src/matchpathcon.c
+++ b/libselinux/src/matchpathcon.c
@@ -31,13 +31,36 @@ int myprintf_compat = 0;
 
 void set_matchpathcon_printf(void (*f) (const char *fmt, ...))
 {
+	myprintf = f ? f : &default_printf;
+	myprintf_compat = 1;
 }
 
 int compat_validate(struct selabel_handle *rec,
 		    struct selabel_lookup_rec *contexts,
 		    const char *path, unsigned lineno)
 {
-        return 0;
+	int rc;
+	char **ctx = &contexts->ctx_raw;
+
+	if (myinvalidcon)
+		rc = myinvalidcon(path, lineno, *ctx);
+	else if (mycanoncon)
+		rc = mycanoncon(path, lineno, ctx);
+	else {
+		rc = selabel_validate(rec, contexts);
+		if (rc < 0) {
+			if (lineno) {
+				COMPAT_LOG(SELINUX_WARNING,
+					    "%s: line %u has invalid context %s\n",
+						path, lineno, *ctx);
+			} else {
+				COMPAT_LOG(SELINUX_WARNING,
+					    "%s: has invalid context %s\n", path, *ctx);
+			}
+		}
+	}
+
+	return rc ? -1 : 0;
 }
 
 #ifndef BUILD_HOST
@@ -91,6 +114,7 @@ static void free_array_elts(void)
 
 void set_matchpathcon_invalidcon(int (*f) (const char *p, unsigned l, char *c))
 {
+	myinvalidcon = f;
 }
 
 static int default_canoncon(const char *path, unsigned lineno, char **context)
@@ -113,6 +137,10 @@ static int default_canoncon(const char *path, unsigned lineno, char **context)
 
 void set_matchpathcon_canoncon(int (*f) (const char *p, unsigned l, char **c))
 {
+	if (f)
+		mycanoncon = f;
+	else
+		mycanoncon = &default_canoncon;
 }
 
 static __thread struct selinux_opt options[SELABEL_NOPT];
@@ -120,6 +148,15 @@ static __thread int notrans;
 
 void set_matchpathcon_flags(unsigned int flags)
 {
+	int i;
+	memset(options, 0, sizeof(options));
+	i = SELABEL_OPT_BASEONLY;
+	options[i].type = i;
+	options[i].value = (flags & MATCHPATHCON_BASEONLY) ? (char*)1 : NULL;
+	i = SELABEL_OPT_VALIDATE;
+	options[i].type = i;
+	options[i].value = (flags & MATCHPATHCON_VALIDATE) ? (char*)1 : NULL;
+	notrans = flags & MATCHPATHCON_NOTRANS;
 }
 
 /*
@@ -153,7 +190,71 @@ static file_spec_t *fl_head;
  */
 int matchpathcon_filespec_add(ino_t ino, int specind, const char *file)
 {
-        return 0;
+	file_spec_t *prevfl, *fl;
+	int h, ret;
+	struct stat sb;
+
+	if (!fl_head) {
+		fl_head = malloc(sizeof(file_spec_t) * HASH_BUCKETS);
+		if (!fl_head)
+			goto oom;
+		memset(fl_head, 0, sizeof(file_spec_t) * HASH_BUCKETS);
+	}
+
+	h = (ino + (ino >> HASH_BITS)) & HASH_MASK;
+	for (prevfl = &fl_head[h], fl = fl_head[h].next; fl;
+	     prevfl = fl, fl = fl->next) {
+		if (ino == fl->ino) {
+			ret = lstat(fl->file, &sb);
+			if (ret < 0 || sb.st_ino != ino) {
+				fl->specind = specind;
+				free(fl->file);
+				fl->file = malloc(strlen(file) + 1);
+				if (!fl->file)
+					goto oom;
+				strcpy(fl->file, file);
+				return fl->specind;
+
+			}
+
+			if (!strcmp(con_array[fl->specind],
+				    con_array[specind]))
+				return fl->specind;
+
+			myprintf
+			    ("%s:  conflicting specifications for %s and %s, using %s.\n",
+			     __FUNCTION__, file, fl->file,
+			     con_array[fl->specind]);
+			free(fl->file);
+			fl->file = malloc(strlen(file) + 1);
+			if (!fl->file)
+				goto oom;
+			strcpy(fl->file, file);
+			return fl->specind;
+		}
+
+		if (ino > fl->ino)
+			break;
+	}
+
+	fl = malloc(sizeof(file_spec_t));
+	if (!fl)
+		goto oom;
+	fl->ino = ino;
+	fl->specind = specind;
+	fl->file = malloc(strlen(file) + 1);
+	if (!fl->file)
+		goto oom_freefl;
+	strcpy(fl->file, file);
+	fl->next = prevfl->next;
+	prevfl->next = fl;
+	return fl->specind;
+      oom_freefl:
+	free(fl);
+      oom:
+	myprintf("%s:  insufficient memory for file label entry for %s\n",
+		 __FUNCTION__, file);
+	return -1;
 }
 
 /*
@@ -161,6 +262,30 @@ int matchpathcon_filespec_add(ino_t ino, int specind, const char *file)
  */
 void matchpathcon_filespec_eval(void)
 {
+	file_spec_t *fl;
+	int h, used, nel, len, longest;
+
+	if (!fl_head)
+		return;
+
+	used = 0;
+	longest = 0;
+	nel = 0;
+	for (h = 0; h < HASH_BUCKETS; h++) {
+		len = 0;
+		for (fl = fl_head[h].next; fl; fl = fl->next) {
+			len++;
+		}
+		if (len)
+			used++;
+		if (len > longest)
+			longest = len;
+		nel += len;
+	}
+
+	myprintf
+	    ("%s:  hash table stats: %d elements, %d/%d buckets used, longest chain length %d\n",
+	     __FUNCTION__, nel, used, HASH_BUCKETS, longest);
 }
 
 /*
@@ -168,6 +293,26 @@ void matchpathcon_filespec_eval(void)
  */
 void matchpathcon_filespec_destroy(void)
 {
+	file_spec_t *fl, *tmp;
+	int h;
+
+	free_array_elts();
+
+	if (!fl_head)
+		return;
+
+	for (h = 0; h < HASH_BUCKETS; h++) {
+		fl = fl_head[h].next;
+		while (fl) {
+			tmp = fl;
+			fl = fl->next;
+			free(tmp->file);
+			free(tmp);
+		}
+		fl_head[h].next = NULL;
+	}
+	free(fl_head);
+	fl_head = NULL;
 }
 
 static void matchpathcon_thread_destructor(void __attribute__((unused)) *ptr)
@@ -179,6 +324,8 @@ void __attribute__((destructor)) matchpathcon_lib_destructor(void);
 
 void hidden __attribute__((destructor)) matchpathcon_lib_destructor(void)
 {
+	if (destructor_key_initialized)
+		__selinux_key_delete(destructor_key);
 }
 
 static void matchpathcon_init_once(void)
@@ -189,18 +336,36 @@ static void matchpathcon_init_once(void)
 
 int matchpathcon_init_prefix(const char *path, const char *subset)
 {
-        return 0;
+	if (!mycanoncon)
+		mycanoncon = default_canoncon;
+
+	__selinux_once(once, matchpathcon_init_once);
+	__selinux_setspecific(destructor_key, (void *)1);
+
+	options[SELABEL_OPT_SUBSET].type = SELABEL_OPT_SUBSET;
+	options[SELABEL_OPT_SUBSET].value = subset;
+	options[SELABEL_OPT_PATH].type = SELABEL_OPT_PATH;
+	options[SELABEL_OPT_PATH].value = path;
+
+	hnd = selabel_open(SELABEL_CTX_FILE, options, SELABEL_NOPT);
+	return hnd ? 0 : -1;
 }
 
 hidden_def(matchpathcon_init_prefix)
 
 int matchpathcon_init(const char *path)
 {
-        return 0;
+	return matchpathcon_init_prefix(path, NULL);
 }
 
 void matchpathcon_fini(void)
 {
+	free_array_elts();
+
+	if (hnd) {
+		selabel_close(hnd);
+		hnd = NULL;
+	}
 }
 
 /*
@@ -211,21 +376,92 @@ void matchpathcon_fini(void)
  */
 int realpath_not_final(const char *name, char *resolved_path)
 {
-        return 0;
+	char *last_component;
+	char *tmp_path, *p;
+	size_t len = 0;
+	int rc = 0;
+
+	tmp_path = strdup(name);
+	if (!tmp_path) {
+		myprintf("symlink_realpath(%s) strdup() failed: %s\n",
+			name, strerror(errno));
+		rc = -1;
+		goto out;
+	}
+
+	last_component = strrchr(tmp_path, '/');
+
+	if (last_component == tmp_path) {
+		last_component++;
+		p = strcpy(resolved_path, "");
+	} else if (last_component) {
+		*last_component = '\0';
+		last_component++;
+		p = realpath(tmp_path, resolved_path);
+	} else {
+		last_component = tmp_path;
+		p = realpath("./", resolved_path);
+	}
+
+	if (!p) {
+		myprintf("symlink_realpath(%s) realpath() failed: %s\n",
+			name, strerror(errno));
+		rc = -1;
+		goto out;
+	}
+
+	len = strlen(p);
+	if (len + strlen(last_component) + 2 > PATH_MAX) {
+		myprintf("symlink_realpath(%s) failed: Filename too long \n",
+			name);
+		errno=ENAMETOOLONG;
+		rc = -1;
+		goto out;
+	}
+
+	resolved_path += len;
+	strcpy(resolved_path, "/");
+	resolved_path += 1;
+	strcpy(resolved_path, last_component);
+out:
+	free(tmp_path);
+	return rc;
 }
 
 int matchpathcon(const char *path, mode_t mode, char ** con)
 {
-        return 0;
+	char stackpath[PATH_MAX + 1];
+	char *p = NULL;
+	if (!hnd && (matchpathcon_init_prefix(NULL, NULL) < 0))
+			return -1;
+
+	if (S_ISLNK(mode)) {
+		if (!realpath_not_final(path, stackpath))
+			path = stackpath;
+	} else {
+		p = realpath(path, stackpath);
+		if (p)
+			path = p;
+	}
+
+	return notrans ?
+		selabel_lookup_raw(hnd, con, path, mode) :
+		selabel_lookup(hnd, con, path, mode);
 }
 
 int matchpathcon_index(const char *name, mode_t mode, char ** con)
 {
-        return 0;
+	int i = matchpathcon(name, mode, con);
+
+	if (i < 0)
+		return -1;
+
+	return add_array_elt(*con);
 }
 
 void matchpathcon_checkmatches(char *str __attribute__((unused)))
 {
+	selabel_stats(hnd);
 }
 
 /* Compare two contexts to see if their differences are "significant",
@@ -233,17 +469,93 @@ void matchpathcon_checkmatches(char *str __attribute__((unused)))
 int selinux_file_context_cmp(const char * a,
 			     const char * b)
 {
-        return 0;
+	char *rest_a, *rest_b;	/* Rest of the context after the user */
+	if (!a && !b)
+		return 0;
+	if (!a)
+		return -1;
+	if (!b)
+		return 1;
+	rest_a = strchr((char *)a, ':');
+	rest_b = strchr((char *)b, ':');
+	if (!rest_a && !rest_b)
+		return 0;
+	if (!rest_a)
+		return -1;
+	if (!rest_b)
+		return 1;
+	return strcmp(rest_a, rest_b);
 }
 
 int selinux_file_context_verify(const char *path, mode_t mode)
 {
-        return 0;
+	char * con = NULL;
+	char * fcontext = NULL;
+	int rc = 0;
+	char stackpath[PATH_MAX + 1];
+	char *p = NULL;
+
+	if (S_ISLNK(mode)) {
+		if (!realpath_not_final(path, stackpath))
+			path = stackpath;
+	} else {
+		p = realpath(path, stackpath);
+		if (p)
+			path = p;
+	}
+
+	rc = lgetfilecon_raw(path, &con);
+	if (rc == -1) {
+		if (errno != ENOTSUP)
+			return -1;
+		else
+			return 0;
+	}
+	
+	if (!hnd && (matchpathcon_init_prefix(NULL, NULL) < 0))
+			return -1;
+
+	if (selabel_lookup_raw(hnd, &fcontext, path, mode) != 0) {
+		if (errno != ENOENT)
+			rc = -1;
+		else
+			rc = 0;
+	} else {
+		/*
+		 * Need to set errno to 0 as it can be set to ENOENT if the
+		 * file_contexts.subs file does not exist (see selabel_open in
+		 * label.c), thus causing confusion if errno is checked on return.
+		 */
+		errno = 0;
+		rc = (selinux_file_context_cmp(fcontext, con) == 0);
+	}
+
+	freecon(con);
+	freecon(fcontext);
+	return rc;
 }
 
 int selinux_lsetfilecon_default(const char *path)
 {
-        return 0;
+	struct stat st;
+	int rc = -1;
+	char * scontext = NULL;
+	if (lstat(path, &st) != 0)
+		return rc;
+
+	if (!hnd && (matchpathcon_init_prefix(NULL, NULL) < 0))
+			return -1;
+
+	/* If there's an error determining the context, or it has none, 
+	   return to allow default context */
+	if (selabel_lookup_raw(hnd, &scontext, path, st.st_mode)) {
+		if (errno == ENOENT)
+			rc = 0;
+	} else {
+		rc = lsetfilecon_raw(path, scontext);
+		freecon(scontext);
+	}
+	return rc;
 }
 
 #endif
diff --git a/libselinux/src/policyvers.c b/libselinux/src/policyvers.c
index a58d192..284a7f7 100644
--- a/libselinux/src/policyvers.c
+++ b/libselinux/src/policyvers.c
@@ -12,7 +12,34 @@
 
 int security_policyvers(void)
 {
-        return 0;
+	int fd, ret;
+	char path[PATH_MAX];
+	char buf[20];
+	unsigned vers = DEFAULT_POLICY_VERSION;
+
+	if (!selinux_mnt) {
+		errno = ENOENT;
+		return -1;
+	}
+
+	snprintf(path, sizeof path, "%s/policyvers", selinux_mnt);
+	fd = open(path, O_RDONLY);
+	if (fd < 0) {
+		if (errno == ENOENT)
+			return vers;
+		else
+			return -1;
+	}
+	memset(buf, 0, sizeof buf);
+	ret = read(fd, buf, sizeof buf - 1);
+	close(fd);
+	if (ret < 0)
+		return -1;
+
+	if (sscanf(buf, "%u", &vers) != 1)
+		return -1;
+
+	return vers;
 }
 
 hidden_def(security_policyvers)
diff --git a/libselinux/src/procattr.c b/libselinux/src/procattr.c
index 0262421..8cd59af 100644
--- a/libselinux/src/procattr.c
+++ b/libselinux/src/procattr.c
@@ -32,69 +32,274 @@ static pid_t gettid(void)
 
 static void procattr_thread_destructor(void __attribute__((unused)) *unused)
 {
+	if (prev_current != UNSET)
+		free(prev_current);
+	if (prev_exec != UNSET)
+		free(prev_exec);
+	if (prev_fscreate != UNSET)
+		free(prev_fscreate);
+	if (prev_keycreate != UNSET)
+		free(prev_keycreate);
+	if (prev_sockcreate != UNSET)
+		free(prev_sockcreate);
 }
 
 void __attribute__((destructor)) procattr_destructor(void);
 
 void hidden __attribute__((destructor)) procattr_destructor(void)
 {
+	if (destructor_key_initialized)
+		__selinux_key_delete(destructor_key);
 }
 
 static inline void init_thread_destructor(void)
 {
+	if (destructor_initialized == 0) {
+		__selinux_setspecific(destructor_key, (void *)1);
+		destructor_initialized = 1;
+	}
 }
 
 static void init_procattr(void)
 {
+	if (__selinux_key_create(&destructor_key, procattr_thread_destructor) == 0) {
+		destructor_key_initialized = 1;
+	}
 }
 
 static int openattr(pid_t pid, const char *attr, int flags)
 {
-        return 0;
+	int fd, rc;
+	char *path;
+	pid_t tid;
+
+	if (pid > 0) {
+		rc = asprintf(&path, "/proc/%d/attr/%s", pid, attr);
+	} else if (pid == 0) {
+		rc = asprintf(&path, "/proc/thread-self/attr/%s", attr);
+		if (rc < 0)
+			return -1;
+		fd = open(path, flags | O_CLOEXEC);
+		if (fd >= 0 || errno != ENOENT)
+			goto out;
+		free(path);
+		tid = gettid();
+		rc = asprintf(&path, "/proc/self/task/%d/attr/%s", tid, attr);
+	} else {
+		errno = EINVAL;
+		return -1;
+	}
+	if (rc < 0)
+		return -1;
+
+	fd = open(path, flags | O_CLOEXEC);
+out:
+	free(path);
+	return fd;
 }
 
 static int getprocattrcon_raw(char ** context,
 			      pid_t pid, const char *attr)
 {
-        return 0;
+	char *buf;
+	size_t size;
+	int fd;
+	ssize_t ret;
+	int errno_hold;
+	char * prev_context;
+
+	__selinux_once(once, init_procattr);
+	init_thread_destructor();
+
+	switch (attr[0]) {
+		case 'c':
+			prev_context = prev_current;
+			break;
+		case 'e':
+			prev_context = prev_exec;
+			break;
+		case 'f':
+			prev_context = prev_fscreate;
+			break;
+		case 'k':
+			prev_context = prev_keycreate;
+			break;
+		case 's':
+			prev_context = prev_sockcreate;
+			break;
+		case 'p':
+			prev_context = NULL;
+			break;
+		default:
+			errno = ENOENT;
+			return -1;
+	};
+
+	if (prev_context && prev_context != UNSET) {
+		*context = strdup(prev_context);
+		if (!(*context)) {
+			return -1;
+		}
+		return 0;
+	}
+
+	fd = openattr(pid, attr, O_RDONLY);
+	if (fd < 0)
+		return -1;
+
+	size = selinux_page_size;
+	buf = malloc(size);
+	if (!buf) {
+		ret = -1;
+		goto out;
+	}
+	memset(buf, 0, size);
+
+	do {
+		ret = read(fd, buf, size - 1);
+	} while (ret < 0 && errno == EINTR);
+	if (ret < 0)
+		goto out2;
+
+	if (ret == 0) {
+		*context = NULL;
+		goto out2;
+	}
+
+	*context = strdup(buf);
+	if (!(*context)) {
+		ret = -1;
+		goto out2;
+	}
+	ret = 0;
+      out2:
+	free(buf);
+      out:
+	errno_hold = errno;
+	close(fd);
+	errno = errno_hold;
+	return ret;
 }
 
 static int getprocattrcon(char ** context,
 			  pid_t pid, const char *attr)
 {
-        return 0;
+	int ret;
+	char * rcontext;
+
+	ret = getprocattrcon_raw(&rcontext, pid, attr);
+
+	if (!ret) {
+		ret = selinux_raw_to_trans_context(rcontext, context);
+		freecon(rcontext);
+	}
+
+	return ret;
 }
 
 static int setprocattrcon_raw(const char * context,
 			      pid_t pid, const char *attr)
 {
-        return 0;
+	int fd;
+	ssize_t ret;
+	int errno_hold;
+	char **prev_context, *context2 = NULL;
+
+	__selinux_once(once, init_procattr);
+	init_thread_destructor();
+
+	switch (attr[0]) {
+		case 'c':
+			prev_context = &prev_current;
+			break;
+		case 'e':
+			prev_context = &prev_exec;
+			break;
+		case 'f':
+			prev_context = &prev_fscreate;
+			break;
+		case 'k':
+			prev_context = &prev_keycreate;
+			break;
+		case 's':
+			prev_context = &prev_sockcreate;
+			break;
+		default:
+			errno = ENOENT;
+			return -1;
+	};
+
+	if (!context && !*prev_context)
+		return 0;
+	if (context && *prev_context && *prev_context != UNSET
+	    && !strcmp(context, *prev_context))
+		return 0;
+
+	fd = openattr(pid, attr, O_RDWR);
+	if (fd < 0)
+		return -1;
+	if (context) {
+		ret = -1;
+		context2 = strdup(context);
+		if (!context2)
+			goto out;
+		do {
+			ret = write(fd, context2, strlen(context2) + 1);
+		} while (ret < 0 && errno == EINTR);
+	} else {
+		do {
+			ret = write(fd, NULL, 0);	/* clear */
+		} while (ret < 0 && errno == EINTR);
+	}
+out:
+	errno_hold = errno;
+	close(fd);
+	errno = errno_hold;
+	if (ret < 0) {
+		free(context2);
+		return -1;
+	} else {
+		if (*prev_context != UNSET)
+			free(*prev_context);
+		*prev_context = context2;
+		return 0;
+	}
 }
 
 static int setprocattrcon(const char * context,
 			  pid_t pid, const char *attr)
 {
-        return 0;
+	int ret;
+	char * rcontext;
+
+	if (selinux_trans_to_raw_context(context, &rcontext))
+		return -1;
+
+	ret = setprocattrcon_raw(rcontext, pid, attr);
+
+	freecon(rcontext);
+
+	return ret;
 }
 
 #define getselfattr_def(fn, attr) \
 	int get##fn##_raw(char **c) \
 	{ \
-		return 0; \
+		return getprocattrcon_raw(c, 0, #attr); \
 	} \
 	int get##fn(char **c) \
 	{ \
-		return 0; \
+		return getprocattrcon(c, 0, #attr); \
 	}
 
 #define setselfattr_def(fn, attr) \
 	int set##fn##_raw(const char * c) \
 	{ \
-		return 0; \
+		return setprocattrcon_raw(c, 0, #attr); \
 	} \
 	int set##fn(const char * c) \
 	{ \
-		return 0; \
+		return setprocattrcon(c, 0, #attr); \
 	}
 
 #define all_selfattr_def(fn, attr) \
@@ -104,11 +309,21 @@ static int setprocattrcon(const char * context,
 #define getpidattr_def(fn, attr) \
 	int get##fn##_raw(pid_t pid, char **c)	\
 	{ \
-		return 0; \
+		if (pid <= 0) { \
+			errno = EINVAL; \
+			return -1; \
+		} else { \
+			return getprocattrcon_raw(c, pid, #attr); \
+		} \
 	} \
 	int get##fn(pid_t pid, char **c)	\
 	{ \
-		return 0; \
+		if (pid <= 0) { \
+			errno = EINVAL; \
+			return -1; \
+		} else { \
+			return getprocattrcon(c, pid, #attr); \
+		} \
 	}
 
 all_selfattr_def(con, current)
diff --git a/libselinux/src/query_user_context.c b/libselinux/src/query_user_context.c
index 7c97e1f..b8125c9 100644
--- a/libselinux/src/query_user_context.c
+++ b/libselinux/src/query_user_context.c
@@ -11,7 +11,24 @@
  */
 static int context_menu(char ** list)
 {
-        return 0;
+	int i;			/* array index                        */
+	int choice = 0;		/* index of the user's choice         */
+	char response[10];	/* string to hold the user's response */
+
+	printf("\n\n");
+	for (i = 0; list[i]; i++)
+		printf("[%d] %s\n", i + 1, list[i]);
+
+	while ((choice < 1) || (choice > i)) {
+		printf("Enter number of choice: ");
+		fflush(stdin);
+		if (fgets(response, sizeof(response), stdin) == NULL)
+			continue;
+		fflush(stdin);
+		choice = strtol(response, NULL, 10);
+	}
+
+	return (choice - 1);
 }
 
 /* query_user_context - given a list of context, allow the user to choose one.  The 
@@ -20,6 +37,38 @@ static int context_menu(char ** list)
  */
 int query_user_context(char ** list, char ** usercon)
 {
+	char response[10];	/* The user's response                        */
+	int choice;		/* The index in the list of the sid chosen by
+				   the user                                   */
+
+	if (!list[0])
+		return -1;
+
+	printf("\nYour default context is %s.\n", list[0]);
+	if (list[1]) {
+		printf("Do you want to choose a different one? [n]");
+		fflush(stdin);
+		if (fgets(response, sizeof(response), stdin) == NULL)
+			return -1;
+		fflush(stdin);
+
+		if ((response[0] == 'y') || (response[0] == 'Y')) {
+			choice = context_menu(list);
+			*usercon = strdup(list[choice]);
+			if (!(*usercon))
+				return -1;
+			return 0;
+		}
+
+		*usercon = strdup(list[0]);
+		if (!(*usercon))
+			return -1;
+	} else {
+		*usercon = strdup(list[0]);
+		if (!(*usercon))
+			return -1;
+	}
+
 	return 0;
 }
 
@@ -56,5 +105,76 @@ static void get_field(const char *fieldstr, char *newfield, int newfieldlen)
  */
 int manual_user_enter_context(const char *user, char ** newcon)
 {
+	char response[10];	/* Used to get yes or no answers from user */
+	char role[100];		/* The role requested by the user          */
+	int rolelen = 100;
+	char type[100];		/* The type requested by the user          */
+	int typelen = 100;
+	char level[100];	/* The level requested by the user         */
+	int levellen = 100;
+	int mls_enabled = is_selinux_mls_enabled();
+
+	context_t new_context;	/* The new context chosen by the user     */
+	char *user_context = NULL;	/* String value of the user's context     */
+	int done = 0;		/* true if a valid sid has been obtained  */
+
+	/* Initialize the context.  How this is done depends on whether
+	   or not MLS is enabled                                        */
+	if (mls_enabled)
+		new_context = context_new("user:role:type:level");
+	else
+		new_context = context_new("user:role:type");
+
+	if (!new_context)
+		return -1;
+
+	while (!done) {
+		printf("Would you like to enter a security context? [y]");
+		if (fgets(response, sizeof(response), stdin) == NULL
+		    || (response[0] == 'n') || (response[0] == 'N')) {
+			context_free(new_context);
+			return -1;
+		}
+
+		/* Allow the user to enter each field of the context individually */
+		if (context_user_set(new_context, user)) {
+			context_free(new_context);
+			return -1;
+		}
+		get_field("role", role, rolelen);
+		if (context_role_set(new_context, role)) {
+			context_free(new_context);
+			return -1;
+		}
+		get_field("type", type, typelen);
+		if (context_type_set(new_context, type)) {
+			context_free(new_context);
+			return -1;
+		}
+
+		if (mls_enabled) {
+			get_field("level", level, levellen);
+			if (context_range_set(new_context, level)) {
+				context_free(new_context);
+				return -1;
+			}
+		}
+
+		/* Get the string value of the context and see if it is valid. */
+		user_context = context_str(new_context);
+		if (!user_context) {
+			context_free(new_context);
+			return -1;
+		}
+		if (!security_check_context(user_context))
+			done = 1;
+		else
+			printf("Not a valid security context\n");
+	}
+
+	*newcon = strdup(user_context);
+	context_free(new_context);
+	if (!(*newcon))
+		return -1;
 	return 0;
 }
diff --git a/libselinux/src/regex.c b/libselinux/src/regex.c
index 5aa4bd6..0c5ad27 100644
--- a/libselinux/src/regex.c
+++ b/libselinux/src/regex.c
@@ -68,7 +68,30 @@ struct regex_data {
 int regex_prepare_data(struct regex_data **regex, char const *pattern_string,
 		       struct regex_error_data *errordata)
 {
+	memset(errordata, 0, sizeof(struct regex_error_data));
+
+	*regex = regex_data_create();
+	if (!(*regex))
+		return -1;
+
+	(*regex)->regex = pcre2_compile(
+	    (PCRE2_SPTR)pattern_string, PCRE2_ZERO_TERMINATED, PCRE2_DOTALL,
+	    &errordata->error_code, &errordata->error_offset, NULL);
+	if (!(*regex)->regex) {
+		goto err;
+	}
+
+	(*regex)->match_data =
+	    pcre2_match_data_create_from_pattern((*regex)->regex, NULL);
+	if (!(*regex)->match_data) {
+		goto err;
+	}
 	return 0;
+
+err:
+	regex_data_free(*regex);
+	*regex = NULL;
+	return -1;
 }
 
 char const *regex_version(void)
@@ -85,21 +108,117 @@ char const *regex_version(void)
 int regex_load_mmap(struct mmap_area *mmap_area, struct regex_data **regex,
 		    int do_load_precompregex)
 {
-        return 0;
+	int rc;
+	uint32_t entry_len;
+
+	rc = next_entry(&entry_len, mmap_area, sizeof(uint32_t));
+	if (rc < 0)
+		return -1;
+
+	if (entry_len && do_load_precompregex) {
+		/*
+		 * this should yield exactly one because we store one pattern at
+		 * a time
+		 */
+		rc = pcre2_serialize_get_number_of_codes(mmap_area->next_addr);
+		if (rc != 1)
+			return -1;
+
+		*regex = regex_data_create();
+		if (!*regex)
+			return -1;
+
+		rc = pcre2_serialize_decode(&(*regex)->regex, 1,
+					    (PCRE2_SPTR)mmap_area->next_addr,
+					    NULL);
+		if (rc != 1)
+			goto err;
+
+		(*regex)->match_data =
+		    pcre2_match_data_create_from_pattern((*regex)->regex, NULL);
+		if (!(*regex)->match_data)
+			goto err;
+	}
+
+	/* and skip the decoded bit */
+	rc = next_entry(NULL, mmap_area, entry_len);
+	if (rc < 0)
+		goto err;
+
+	return 0;
+err:
+	regex_data_free(*regex);
+	*regex = NULL;
+	return -1;
 }
 
 int regex_writef(struct regex_data *regex, FILE *fp, int do_write_precompregex)
 {
-        return 0;
+	int rc = 0;
+	size_t len;
+	PCRE2_SIZE serialized_size;
+	uint32_t to_write = 0;
+	PCRE2_UCHAR *bytes = NULL;
+
+	if (do_write_precompregex) {
+		/* encode the patter for serialization */
+		rc = pcre2_serialize_encode((const pcre2_code **)&regex->regex,
+					    1, &bytes, &serialized_size, NULL);
+		if (rc != 1) {
+			rc = -1;
+			goto out;
+		}
+		to_write = serialized_size;
+	}
+
+	/* write serialized pattern's size */
+	len = fwrite(&to_write, sizeof(uint32_t), 1, fp);
+	if (len != 1) {
+		rc = -1;
+		goto out;
+	}
+
+	if (do_write_precompregex) {
+		/* write serialized pattern */
+		len = fwrite(bytes, 1, to_write, fp);
+		if (len != to_write)
+			rc = -1;
+	}
+
+out:
+	if (bytes)
+		pcre2_serialize_free(bytes);
+
+	return rc;
 }
 
 void regex_data_free(struct regex_data *regex)
 {
+	if (regex) {
+		if (regex->regex)
+			pcre2_code_free(regex->regex);
+		if (regex->match_data)
+			pcre2_match_data_free(regex->match_data);
+		free(regex);
+	}
 }
 
 int regex_match(struct regex_data *regex, char const *subject, int partial)
 {
-        return 0;
+	int rc;
+	rc = pcre2_match(
+	    regex->regex, (PCRE2_SPTR)subject, PCRE2_ZERO_TERMINATED, 0,
+	    partial ? PCRE2_PARTIAL_SOFT : 0, regex->match_data, NULL);
+	if (rc > 0)
+		return REGEX_MATCH;
+	switch (rc) {
+	case PCRE2_ERROR_PARTIAL:
+		return REGEX_MATCH_PARTIAL;
+	case PCRE2_ERROR_NOMATCH:
+		return REGEX_NO_MATCH;
+	default:
+		return REGEX_ERROR;
+	}
 }
 
 /*
@@ -113,7 +232,16 @@ int regex_match(struct regex_data *regex, char const *subject, int partial)
  */
 int regex_cmp(struct regex_data *regex1, struct regex_data *regex2)
 {
-        return 0;
+	int rc;
+	size_t len1, len2;
+	rc = pcre2_pattern_info(regex1->regex, PCRE2_INFO_SIZE, &len1);
+	assert(rc == 0);
+	rc = pcre2_pattern_info(regex2->regex, PCRE2_INFO_SIZE, &len2);
+	assert(rc == 0);
+	if (len1 != len2 || memcmp(regex1->regex, regex2->regex, len1))
+		return SELABEL_INCOMPARABLE;
+
+	return SELABEL_EQUAL;
 }
 
 #else // !USE_PCRE2
@@ -142,7 +270,30 @@ struct regex_data {
 int regex_prepare_data(struct regex_data **regex, char const *pattern_string,
 		       struct regex_error_data *errordata)
 {
-        return 0;
+	memset(errordata, 0, sizeof(struct regex_error_data));
+
+	*regex = regex_data_create();
+	if (!(*regex))
+		return -1;
+
+	(*regex)->regex =
+	    pcre_compile(pattern_string, PCRE_DOTALL, &errordata->error_buffer,
+			 &errordata->error_offset, NULL);
+	if (!(*regex)->regex)
+		goto err;
+
+	(*regex)->owned = 1;
+
+	(*regex)->sd = pcre_study((*regex)->regex, 0, &errordata->error_buffer);
+	if (!(*regex)->sd && errordata->error_buffer)
+		goto err;
+
+	return 0;
+
+err:
+	regex_data_free(*regex);
+	*regex = NULL;
+	return -1;
 }
 
 char const *regex_version(void)
@@ -153,7 +304,55 @@ char const *regex_version(void)
 int regex_load_mmap(struct mmap_area *mmap_area, struct regex_data **regex,
 		    int unused __attribute__((unused)))
 {
-        return 0;
+	int rc;
+	uint32_t entry_len;
+	size_t info_len;
+
+	rc = next_entry(&entry_len, mmap_area, sizeof(uint32_t));
+	if (rc < 0 || !entry_len)
+		return -1;
+
+	*regex = regex_data_create();
+	if (!(*regex))
+		return -1;
+
+	(*regex)->owned = 0;
+	(*regex)->regex = (pcre *)mmap_area->next_addr;
+	rc = next_entry(NULL, mmap_area, entry_len);
+	if (rc < 0)
+		goto err;
+
+	/*
+	 * Check that regex lengths match. pcre_fullinfo()
+	 * also validates its magic number.
+	 */
+	rc = pcre_fullinfo((*regex)->regex, NULL, PCRE_INFO_SIZE, &info_len);
+	if (rc < 0 || info_len != entry_len)
+		goto err;
+
+	rc = next_entry(&entry_len, mmap_area, sizeof(uint32_t));
+	if (rc < 0 || !entry_len)
+		goto err;
+
+	if (entry_len) {
+		(*regex)->lsd.study_data = (void *)mmap_area->next_addr;
+		(*regex)->lsd.flags |= PCRE_EXTRA_STUDY_DATA;
+		rc = next_entry(NULL, mmap_area, entry_len);
+		if (rc < 0)
+			goto err;
+
+		/* Check that study data lengths match. */
+		rc = pcre_fullinfo((*regex)->regex, &(*regex)->lsd,
+				   PCRE_INFO_STUDYSIZE, &info_len);
+		if (rc < 0 || info_len != entry_len)
+			goto err;
+	}
+	return 0;
+
+err:
+	regex_data_free(*regex);
+	*regex = NULL;
+	return -1;
 }
 
 static inline pcre_extra *get_pcre_extra(struct regex_data *regex)
@@ -171,16 +370,83 @@ static inline pcre_extra *get_pcre_extra(struct regex_data *regex)
 int regex_writef(struct regex_data *regex, FILE *fp,
 		 int unused __attribute__((unused)))
 {
-        return 0;
+	int rc;
+	size_t len;
+	uint32_t to_write;
+	size_t size;
+	pcre_extra *sd = get_pcre_extra(regex);
+
+	/* determine the size of the pcre data in bytes */
+	rc = pcre_fullinfo(regex->regex, NULL, PCRE_INFO_SIZE, &size);
+	if (rc < 0)
+		return -1;
+
+	/* write the number of bytes in the pcre data */
+	to_write = size;
+	len = fwrite(&to_write, sizeof(uint32_t), 1, fp);
+	if (len != 1)
+		return -1;
+
+	/* write the actual pcre data as a char array */
+	len = fwrite(regex->regex, 1, to_write, fp);
+	if (len != to_write)
+		return -1;
+
+	if (sd) {
+		/* determine the size of the pcre study info */
+		rc =
+		    pcre_fullinfo(regex->regex, sd, PCRE_INFO_STUDYSIZE, &size);
+		if (rc < 0)
+			return -1;
+	} else
+		size = 0;
+
+	/* write the number of bytes in the pcre study data */
+	to_write = size;
+	len = fwrite(&to_write, sizeof(uint32_t), 1, fp);
+	if (len != 1)
+		return -1;
+
+	if (sd) {
+		/* write the actual pcre study data as a char array */
+		len = fwrite(sd->study_data, 1, to_write, fp);
+		if (len != to_write)
+			return -1;
+	}
+
+	return 0;
 }
 
 void regex_data_free(struct regex_data *regex)
 {
+	if (regex) {
+		if (regex->owned) {
+			if (regex->regex)
+				pcre_free(regex->regex);
+			if (regex->sd)
+				pcre_free_study(regex->sd);
+		}
+		free(regex);
+	}
 }
 
 int regex_match(struct regex_data *regex, char const *subject, int partial)
 {
-        return 0;
+	int rc;
+
+	rc = pcre_exec(regex->regex, get_pcre_extra(regex),
+		       subject, strlen(subject), 0,
+		       partial ? PCRE_PARTIAL_SOFT : 0, NULL, 0);
+	switch (rc) {
+	case 0:
+		return REGEX_MATCH;
+	case PCRE_ERROR_PARTIAL:
+		return REGEX_MATCH_PARTIAL;
+	case PCRE_ERROR_NOMATCH:
+		return REGEX_NO_MATCH;
+	default:
+		return REGEX_ERROR;
+	}
 }
 
 /*
@@ -194,7 +460,16 @@ int regex_match(struct regex_data *regex, char const *subject, int partial)
  */
 int regex_cmp(struct regex_data *regex1, struct regex_data *regex2)
 {
-        return 0;
+	int rc;
+	size_t len1, len2;
+	rc = pcre_fullinfo(regex1->regex, NULL, PCRE_INFO_SIZE, &len1);
+	assert(rc == 0);
+	rc = pcre_fullinfo(regex2->regex, NULL, PCRE_INFO_SIZE, &len2);
+	assert(rc == 0);
+	if (len1 != len2 || memcmp(regex1->regex, regex2->regex, len1))
+		return SELABEL_INCOMPARABLE;
+
+	return SELABEL_EQUAL;
 }
 
 #endif
@@ -207,4 +482,71 @@ struct regex_data *regex_data_create(void)
 void regex_format_error(struct regex_error_data const *error_data, char *buffer,
 			size_t buf_size)
 {
+	unsigned the_end_length = buf_size > 4 ? 4 : buf_size;
+	char *ptr = &buffer[buf_size - the_end_length];
+	int rc = 0;
+	size_t pos = 0;
+	if (!buffer || !buf_size)
+		return;
+	rc = snprintf(buffer, buf_size, "REGEX back-end error: ");
+	if (rc < 0)
+		/*
+		 * If snprintf fails it constitutes a logical error that needs
+		 * fixing.
+		 */
+		abort();
+
+	pos += rc;
+	if (pos >= buf_size)
+		goto truncated;
+
+	if (error_data->error_offset > 0) {
+#ifdef USE_PCRE2
+		rc = snprintf(buffer + pos, buf_size - pos, "At offset %zu: ",
+			      error_data->error_offset);
+#else
+		rc = snprintf(buffer + pos, buf_size - pos, "At offset %d: ",
+			      error_data->error_offset);
+#endif
+		if (rc < 0)
+			abort();
+	}
+	pos += rc;
+	if (pos >= buf_size)
+		goto truncated;
+
+#ifdef USE_PCRE2
+	rc = pcre2_get_error_message(error_data->error_code,
+				     (PCRE2_UCHAR *)(buffer + pos),
+				     buf_size - pos);
+	if (rc == PCRE2_ERROR_NOMEMORY)
+		goto truncated;
+#else
+	rc = snprintf(buffer + pos, buf_size - pos, "%s",
+		      error_data->error_buffer);
+	if (rc < 0)
+		abort();
+
+	if ((size_t)rc < strlen(error_data->error_buffer))
+		goto truncated;
+#endif
+
+	return;
+
+truncated:
+	/* replace end of string with "..." to indicate that it was truncated */
+	switch (the_end_length) {
+	/* no break statements, fall-through is intended */
+	case 4:
+		*ptr++ = '.';
+	case 3:
+		*ptr++ = '.';
+	case 2:
+		*ptr++ = '.';
+	case 1:
+		*ptr++ = '\0';
+	default:
+		break;
+	}
+	return;
 }
diff --git a/libselinux/src/selinux_check_securetty_context.c b/libselinux/src/selinux_check_securetty_context.c
index 67f4ddd..24e5e2c 100644
--- a/libselinux/src/selinux_check_securetty_context.c
+++ b/libselinux/src/selinux_check_securetty_context.c
@@ -8,7 +8,46 @@
 
 int selinux_check_securetty_context(const char * tty_context)
 {
-        return 0;
+	char *line = NULL;
+	char *start, *end = NULL;
+	size_t line_len = 0;
+	ssize_t len;
+	int found = -1;
+	FILE *fp;
+	fp = fopen(selinux_securetty_types_path(), "r");
+	if (fp) {
+		context_t con = context_new(tty_context);
+		if (con) {
+			const char *type = context_type_get(con);
+			while ((len = getline(&line, &line_len, fp)) != -1) {
+
+				if (line[len - 1] == '\n')
+					line[len - 1] = 0;
+
+				/* Skip leading whitespace. */
+				start = line;
+				while (*start && isspace(*start))
+					start++;
+				if (!(*start))
+					continue;
+
+				end = start;
+				while (*end && !isspace(*end))
+					end++;
+				if (*end)
+					*end++ = 0;
+				if (!strcmp(type, start)) {
+					found = 0;
+					break;
+				}
+			}
+			free(line);
+			context_free(con);
+		}
+		fclose(fp);
+	}
+
+	return found;
 }
 
 hidden_def(selinux_check_securetty_context)
diff --git a/libselinux/src/selinux_config.c b/libselinux/src/selinux_config.c
index c8e51d1..88bcc85 100644
--- a/libselinux/src/selinux_config.c
+++ b/libselinux/src/selinux_config.c
@@ -87,7 +87,44 @@ static const uint16_t file_path_suffixes_idx[NEL] = {
 
 int selinux_getenforcemode(int *enforce)
 {
-        return 0;
+	int ret = -1;
+	FILE *cfg = fopen(SELINUXCONFIG, "r");
+	if (cfg) {
+		char *buf;
+		int len = sizeof(SELINUXTAG) - 1;
+		buf = malloc(selinux_page_size);
+		if (!buf) {
+			fclose(cfg);
+			return -1;
+		}
+		while (fgets_unlocked(buf, selinux_page_size, cfg)) {
+			if (strncmp(buf, SELINUXTAG, len))
+				continue;
+			if (!strncasecmp
+			    (buf + len, "enforcing", sizeof("enforcing") - 1)) {
+				*enforce = 1;
+				ret = 0;
+				break;
+			} else
+			    if (!strncasecmp
+				(buf + len, "permissive",
+				 sizeof("permissive") - 1)) {
+				*enforce = 0;
+				ret = 0;
+				break;
+			} else
+			    if (!strncasecmp
+				(buf + len, "disabled",
+				 sizeof("disabled") - 1)) {
+				*enforce = -1;
+				ret = 0;
+				break;
+			}
+		}
+		fclose(cfg);
+		free(buf);
+	}
+	return ret;
 }
 
 hidden_def(selinux_getenforcemode)
@@ -96,14 +133,20 @@ static char *selinux_policytype;
 
 int selinux_getpolicytype(char **type)
 {
-        return 0;
+	__selinux_once(once, init_selinux_config);
+	if (!selinux_policytype)
+		return -1;
+	*type = strdup(selinux_policytype);
+	return *type ? 0 : -1;
 }
 
 hidden_def(selinux_getpolicytype)
 
 static int setpolicytype(const char *type)
 {
-        return 0;
+	free(selinux_policytype);
+	selinux_policytype = strdup(type);
+	return selinux_policytype ? 0 : -1;
 }
 
 static char *selinux_policyroot = NULL;
@@ -204,6 +247,8 @@ static void fini_selinux_policyroot(void)
 
 void selinux_reset_config(void)
 {
+	fini_selinux_policyroot();
+	init_selinux_config();
 }
 
 hidden_def(selinux_reset_config)
@@ -229,231 +274,275 @@ const char *selinux_policy_root(void)
 
 int selinux_set_policy_root(const char *path)
 {
-        return 0;
+	int i;
+	char *policy_type = strrchr(path, '/');
+	if (!policy_type) {
+		errno = EINVAL;
+		return -1;
+	}
+	policy_type++;
+
+	fini_selinuxmnt();
+	fini_selinux_policyroot();
+
+	selinux_policyroot = strdup(path);
+	if (! selinux_policyroot)
+		return -1;
+
+	if (setpolicytype(policy_type) != 0)
+		return -1;
+
+	for (i = 0; i < NEL; i++)
+		if (asprintf(&file_paths[i], "%s%s",
+			     selinux_policyroot,
+			     file_path_suffixes_data.str +
+			     file_path_suffixes_idx[i])
+		    == -1)
+			return -1;
+
+	return 0;
 }
 
 const char *selinux_path(void)
 {
-	return NULL;
+	return selinux_rootpath;
 }
 
 hidden_def(selinux_path)
 
 const char *selinux_default_context_path(void)
 {
-	return NULL;
+	return get_path(DEFAULT_CONTEXTS);
 }
 
 hidden_def(selinux_default_context_path)
 
 const char *selinux_securetty_types_path(void)
 {
-	return NULL;
+	return get_path(SECURETTY_TYPES);
 }
 
 hidden_def(selinux_securetty_types_path)
 
 const char *selinux_failsafe_context_path(void)
 {
-        return NULL;
+	return get_path(FAILSAFE_CONTEXT);
 }
 
 hidden_def(selinux_failsafe_context_path)
 
 const char *selinux_removable_context_path(void)
 {
-        return NULL;
+	return get_path(REMOVABLE_CONTEXT);
 }
 
 hidden_def(selinux_removable_context_path)
 
 const char *selinux_binary_policy_path(void)
 {
-        return NULL;
+	return get_path(BINPOLICY);
 }
 
 hidden_def(selinux_binary_policy_path)
 
 const char *selinux_current_policy_path(void)
 {
-        return NULL;
+	int rc = 0;
+	int vers = 0;
+	static char policy_path[PATH_MAX];
+
+	if (selinux_mnt) {
+		snprintf(policy_path, sizeof(policy_path), "%s/policy", selinux_mnt);
+		if (access(policy_path, F_OK) == 0 ) {
+			return policy_path;
+		}
+	}
+	vers = security_policyvers();
+	do {
+		/* Check prior versions to see if old policy is available */
+		snprintf(policy_path, sizeof(policy_path), "%s.%d",
+			 selinux_binary_policy_path(), vers);
+	} while ((rc = access(policy_path, F_OK)) && --vers > 0);
+
+	if (rc) return NULL;
+	return policy_path;
 }
 
 hidden_def(selinux_current_policy_path)
 
 const char *selinux_file_context_path(void)
 {
-        return NULL;
+	return get_path(FILE_CONTEXTS);
 }
 
 hidden_def(selinux_file_context_path)
 
 const char *selinux_homedir_context_path(void)
 {
-        return NULL;
+	return get_path(HOMEDIR_CONTEXTS);
 }
 
 hidden_def(selinux_homedir_context_path)
 
 const char *selinux_media_context_path(void)
 {
-        return NULL;
+	return get_path(MEDIA_CONTEXTS);
 }
 
 hidden_def(selinux_media_context_path)
 
 const char *selinux_customizable_types_path(void)
 {
-        return NULL;
+	return get_path(CUSTOMIZABLE_TYPES);
 }
 
 hidden_def(selinux_customizable_types_path)
 
 const char *selinux_contexts_path(void)
 {
-        return NULL;
+	return get_path(CONTEXTS_DIR);
 }
 
 const char *selinux_user_contexts_path(void)
 {
-        return NULL;
+	return get_path(USER_CONTEXTS);
 }
 
 hidden_def(selinux_user_contexts_path)
 
 const char *selinux_booleans_path(void)
 {
-        return NULL;
+	return get_path(BOOLEANS);
 }
 
 hidden_def(selinux_booleans_path)
 
 const char *selinux_users_path(void)
 {
-        return NULL;
+	return get_path(USERS_DIR);
 }
 
 hidden_def(selinux_users_path)
 
 const char *selinux_usersconf_path(void)
 {
-        return NULL;
+	return get_path(SEUSERS);
 }
 
 hidden_def(selinux_usersconf_path)
 
 const char *selinux_translations_path(void)
 {
-        return NULL;
+	return get_path(TRANSLATIONS);
 }
 
 hidden_def(selinux_translations_path)
 
 const char *selinux_colors_path(void)
 {
-        return NULL;
+	return get_path(COLORS);
 }
 
 hidden_def(selinux_colors_path)
 
 const char *selinux_netfilter_context_path(void)
 {
-        return NULL;
+	return get_path(NETFILTER_CONTEXTS);
 }
 
 hidden_def(selinux_netfilter_context_path)
 
 const char *selinux_file_context_homedir_path(void)
 {
-        return NULL;
+	return get_path(FILE_CONTEXTS_HOMEDIR);
 }
 
 hidden_def(selinux_file_context_homedir_path)
 
 const char *selinux_file_context_local_path(void)
 {
-        return NULL;
+	return get_path(FILE_CONTEXTS_LOCAL);
 }
 
 hidden_def(selinux_file_context_local_path)
 
 const char *selinux_x_context_path(void)
 {
-        return NULL;
+	return get_path(X_CONTEXTS);
 }
 
 hidden_def(selinux_x_context_path)
 
 const char *selinux_virtual_domain_context_path(void)
 {
-        return NULL;
+	return get_path(VIRTUAL_DOMAIN);
 }
 
 hidden_def(selinux_virtual_domain_context_path)
 
 const char *selinux_virtual_image_context_path(void)
 {
-        return NULL;
+	return get_path(VIRTUAL_IMAGE);
 }
 
 hidden_def(selinux_virtual_image_context_path)
 
 const char *selinux_lxc_contexts_path(void)
 {
-        return NULL;
+	return get_path(LXC_CONTEXTS);
 }
 
 hidden_def(selinux_lxc_contexts_path)
 
 const char *selinux_openrc_contexts_path(void)
 {
-        return NULL;
+    return get_path(OPENRC_CONTEXTS);
 }
 
 hidden_def(selinux_openrc_contexts_path)
 
 const char *selinux_openssh_contexts_path(void)
 {
-        return NULL;
+    return get_path(OPENSSH_CONTEXTS);
 }
 
 hidden_def(selinux_openssh_contexts_path)
 
 const char *selinux_snapperd_contexts_path(void)
 {
-        return NULL;
+    return get_path(SNAPPERD_CONTEXTS);
 }
 
 hidden_def(selinux_snapperd_contexts_path)
 
 const char *selinux_systemd_contexts_path(void)
 {
-        return NULL;
+	return get_path(SYSTEMD_CONTEXTS);
 }
 
 hidden_def(selinux_systemd_contexts_path)
 
 const char * selinux_booleans_subs_path(void) {
-        return NULL;
+	return get_path(BOOLEAN_SUBS);
 }
 
 hidden_def(selinux_booleans_subs_path)
 
 const char * selinux_file_context_subs_path(void) {
-        return NULL;
+	return get_path(FILE_CONTEXT_SUBS);
 }
 
 hidden_def(selinux_file_context_subs_path)
 
 const char * selinux_file_context_subs_dist_path(void) {
-        return NULL;
+	return get_path(FILE_CONTEXT_SUBS_DIST);
 }
 
 hidden_def(selinux_file_context_subs_dist_path)
 
 const char *selinux_sepgsql_context_path(void)
 {
-        return NULL;
+	return get_path(SEPGSQL_CONTEXTS);
 }
 
 hidden_def(selinux_sepgsql_context_path)
diff --git a/libselinux/src/selinux_restorecon.c b/libselinux/src/selinux_restorecon.c
index 6417fb4..9fdafea 100644
--- a/libselinux/src/selinux_restorecon.c
+++ b/libselinux/src/selinux_restorecon.c
@@ -734,12 +734,323 @@ err:
 int selinux_restorecon(const char *pathname_orig,
 				    unsigned int restorecon_flags)
 {
-        return 0;
+	struct rest_flags flags;
+
+	flags.ignore_digest = (restorecon_flags &
+		    SELINUX_RESTORECON_IGNORE_DIGEST) ? true : false;
+	flags.nochange = (restorecon_flags &
+		    SELINUX_RESTORECON_NOCHANGE) ? true : false;
+	flags.verbose = (restorecon_flags &
+		    SELINUX_RESTORECON_VERBOSE) ? true : false;
+	flags.progress = (restorecon_flags &
+		    SELINUX_RESTORECON_PROGRESS) ? true : false;
+	flags.mass_relabel = (restorecon_flags &
+		    SELINUX_RESTORECON_MASS_RELABEL) ? true : false;
+	flags.recurse = (restorecon_flags &
+		    SELINUX_RESTORECON_RECURSE) ? true : false;
+	flags.set_specctx = (restorecon_flags &
+		    SELINUX_RESTORECON_SET_SPECFILE_CTX) ? true : false;
+	flags.userealpath = (restorecon_flags &
+		   SELINUX_RESTORECON_REALPATH) ? true : false;
+	flags.set_xdev = (restorecon_flags &
+		   SELINUX_RESTORECON_XDEV) ? true : false;
+	flags.add_assoc = (restorecon_flags &
+		   SELINUX_RESTORECON_ADD_ASSOC) ? true : false;
+	flags.abort_on_error = (restorecon_flags &
+		   SELINUX_RESTORECON_ABORT_ON_ERROR) ? true : false;
+	flags.syslog_changes = (restorecon_flags &
+		   SELINUX_RESTORECON_SYSLOG_CHANGES) ? true : false;
+	flags.log_matches = (restorecon_flags &
+		   SELINUX_RESTORECON_LOG_MATCHES) ? true : false;
+	flags.ignore_noent = (restorecon_flags &
+		   SELINUX_RESTORECON_IGNORE_NOENTRY) ? true : false;
+	flags.warnonnomatch = true;
+	ignore_mounts = (restorecon_flags &
+		   SELINUX_RESTORECON_IGNORE_MOUNTS) ? true : false;
+
+	bool issys;
+	bool setrestoreconlast = true; /* TRUE = set xattr RESTORECON_LAST
+					* FALSE = don't use xattr */
+	struct stat sb;
+	struct statfs sfsb;
+	FTS *fts;
+	FTSENT *ftsent;
+	char *pathname = NULL, *pathdnamer = NULL, *pathdname, *pathbname;
+	char *paths[2] = { NULL, NULL };
+	int fts_flags, error, sverrno;
+	char *xattr_value = NULL;
+	ssize_t size;
+	dev_t dev_num = 0;
+
+	if (flags.verbose && flags.progress)
+		flags.verbose = false;
+
+	__selinux_once(fc_once, restorecon_init);
+
+	if (!fc_sehandle)
+		return -1;
+
+	if (fc_digest_len) {
+		xattr_value = malloc(fc_digest_len);
+		if (!xattr_value)
+			return -1;
+	}
+
+	/*
+	 * Convert passed-in pathname to canonical pathname by resolving
+	 * realpath of containing dir, then appending last component name.
+	 */
+	if (flags.userealpath) {
+		char *basename_cpy = strdup(pathname_orig);
+		if (!basename_cpy)
+			goto realpatherr;
+		pathbname = basename(basename_cpy);
+		if (!strcmp(pathbname, "/") || !strcmp(pathbname, ".") ||
+					    !strcmp(pathbname, "..")) {
+			pathname = realpath(pathname_orig, NULL);
+			if (!pathname) {
+				free(basename_cpy);
+				goto realpatherr;
+			}
+		} else {
+			char *dirname_cpy = strdup(pathname_orig);
+			if (!dirname_cpy) {
+				free(basename_cpy);
+				goto realpatherr;
+			}
+			pathdname = dirname(dirname_cpy);
+			pathdnamer = realpath(pathdname, NULL);
+			free(dirname_cpy);
+			if (!pathdnamer) {
+				free(basename_cpy);
+				goto realpatherr;
+			}
+			if (!strcmp(pathdnamer, "/"))
+				error = asprintf(&pathname, "/%s", pathbname);
+			else
+				error = asprintf(&pathname, "%s/%s",
+						    pathdnamer, pathbname);
+			if (error < 0) {
+				free(basename_cpy);
+				goto oom;
+			}
+		}
+		free(basename_cpy);
+	} else {
+		pathname = strdup(pathname_orig);
+		if (!pathname)
+			goto oom;
+	}
+
+	paths[0] = pathname;
+	issys = (!strcmp(pathname, SYS_PATH) ||
+			    !strncmp(pathname, SYS_PREFIX,
+			    sizeof(SYS_PREFIX) - 1)) ? true : false;
+
+	if (lstat(pathname, &sb) < 0) {
+		if (flags.ignore_noent && errno == ENOENT) {
+			free(pathdnamer);
+			free(pathname);
+			return 0;
+		} else {
+			selinux_log(SELINUX_ERROR,
+				    "lstat(%s) failed: %s\n",
+				    pathname, strerror(errno));
+			error = -1;
+			goto cleanup;
+		}
+	}
+
+	/* Ignore restoreconlast if not a directory */
+	if ((sb.st_mode & S_IFDIR) != S_IFDIR)
+		setrestoreconlast = false;
+
+	if (!flags.recurse) {
+		if (check_excluded(pathname)) {
+			error = 0;
+			goto cleanup;
+		}
+
+		error = restorecon_sb(pathname, &sb, &flags);
+		goto cleanup;
+	}
+
+	/* Ignore restoreconlast on /sys */
+	if (issys)
+		setrestoreconlast = false;
+
+	/* Ignore restoreconlast on in-memory filesystems */
+	if (statfs(pathname, &sfsb) == 0) {
+		if (sfsb.f_type == RAMFS_MAGIC || sfsb.f_type == TMPFS_MAGIC)
+			setrestoreconlast = false;
+	}
+
+	if (setrestoreconlast) {
+		size = getxattr(pathname, RESTORECON_LAST, xattr_value,
+							    fc_digest_len);
+
+		if (!flags.ignore_digest && (size_t)size == fc_digest_len &&
+			    memcmp(fc_digest, xattr_value, fc_digest_len)
+								    == 0) {
+			selinux_log(SELINUX_INFO,
+			    "Skipping restorecon as matching digest on: %s\n",
+				    pathname);
+			error = 0;
+			goto cleanup;
+		}
+	}
+
+	if (flags.set_xdev)
+		fts_flags = FTS_PHYSICAL | FTS_NOCHDIR | FTS_XDEV;
+	else
+		fts_flags = FTS_PHYSICAL | FTS_NOCHDIR;
+
+	fts = fts_open(paths, fts_flags, NULL);
+	if (!fts)
+		goto fts_err;
+
+	ftsent = fts_read(fts);
+	if (!ftsent)
+		goto fts_err;
+
+	/*
+	 * Keep the inode of the first device. This is because the FTS_XDEV
+	 * flag tells fts not to descend into directories with different
+	 * device numbers, but fts will still give back the actual directory.
+	 * By saving the device number of the directory that was passed to
+	 * selinux_restorecon() and then skipping all actions on any
+	 * directories with a different device number when the FTS_XDEV flag
+	 * is set (from http://marc.info/?l=selinux&m=124688830500777&w=2).
+	 */
+	dev_num = ftsent->fts_statp->st_dev;
+
+	error = 0;
+	do {
+		/* If the FTS_XDEV flag is set and the device is different */
+		if (flags.set_xdev && ftsent->fts_statp->st_dev != dev_num)
+			continue;
+
+		switch (ftsent->fts_info) {
+		case FTS_DC:
+			selinux_log(SELINUX_ERROR,
+				    "Directory cycle on %s.\n",
+				    ftsent->fts_path);
+			errno = ELOOP;
+			error = -1;
+			goto out;
+		case FTS_DP:
+			continue;
+		case FTS_DNR:
+			selinux_log(SELINUX_ERROR,
+				    "Could not read %s: %s.\n",
+				    ftsent->fts_path,
+						  strerror(ftsent->fts_errno));
+			fts_set(fts, ftsent, FTS_SKIP);
+			continue;
+		case FTS_NS:
+			selinux_log(SELINUX_ERROR,
+				    "Could not stat %s: %s.\n",
+				    ftsent->fts_path,
+						  strerror(ftsent->fts_errno));
+			fts_set(fts, ftsent, FTS_SKIP);
+			continue;
+		case FTS_ERR:
+			selinux_log(SELINUX_ERROR,
+				    "Error on %s: %s.\n",
+				    ftsent->fts_path,
+						  strerror(ftsent->fts_errno));
+			fts_set(fts, ftsent, FTS_SKIP);
+			continue;
+		case FTS_D:
+			if (issys && !selabel_partial_match(fc_sehandle,
+					    ftsent->fts_path)) {
+				fts_set(fts, ftsent, FTS_SKIP);
+				continue;
+			}
+
+			if (check_excluded(ftsent->fts_path)) {
+				fts_set(fts, ftsent, FTS_SKIP);
+				continue;
+			}
+			/* fall through */
+		default:
+			error |= restorecon_sb(ftsent->fts_path,
+					       ftsent->fts_statp, &flags);
+			if (flags.warnonnomatch)
+				flags.warnonnomatch = false;
+			if (error && flags.abort_on_error)
+				goto out;
+			break;
+		}
+	} while ((ftsent = fts_read(fts)) != NULL);
+
+	/* Labeling successful. Mark the top level directory as completed. */
+	if (setrestoreconlast && !flags.nochange && !error && fc_digest) {
+		error = setxattr(pathname, RESTORECON_LAST, fc_digest,
+						    fc_digest_len, 0);
+		if (!error && flags.verbose)
+			selinux_log(SELINUX_INFO,
+				   "Updated digest for: %s\n", pathname);
+	}
+
+out:
+	if (flags.progress && flags.mass_relabel)
+		fprintf(stdout, "\r%s 100.0%%\n", pathname);
+
+	sverrno = errno;
+	(void) fts_close(fts);
+	errno = sverrno;
+cleanup:
+	if (flags.add_assoc) {
+		if (flags.verbose)
+			filespec_eval();
+		filespec_destroy();
+	}
+	free(pathdnamer);
+	free(pathname);
+	free(xattr_value);
+	return error;
+
+oom:
+	sverrno = errno;
+	selinux_log(SELINUX_ERROR, "%s:  Out of memory\n", __func__);
+	errno = sverrno;
+	error = -1;
+	goto cleanup;
+
+realpatherr:
+	sverrno = errno;
+	selinux_log(SELINUX_ERROR,
+		    "SELinux: Could not get canonical path for %s restorecon: %s.\n",
+		    pathname_orig, strerror(errno));
+	errno = sverrno;
+	error = -1;
+	goto cleanup;
+
+fts_err:
+	selinux_log(SELINUX_ERROR,
+		    "fts error while labeling %s: %s\n",
+		    paths[0], strerror(errno));
+	error = -1;
+	goto cleanup;
 }
 
 /* selinux_restorecon_set_sehandle(3) is called to set the global fc handle */
 void selinux_restorecon_set_sehandle(struct selabel_handle *hndl)
 {
+	char **specfiles;
+	size_t num_specfiles;
+
+	fc_sehandle = (struct selabel_handle *) hndl;
+
+	/*
+	 * Read digest if requested in selabel_open(3) and set global params.
+	 */
+	if (selabel_digest(fc_sehandle, &fc_digest, &fc_digest_len,
+				   &specfiles, &num_specfiles) < 0) {
+		fc_digest = NULL;
+		fc_digest_len = 0;
+	}
 }
 
 /*
@@ -748,7 +1059,22 @@ void selinux_restorecon_set_sehandle(struct selabel_handle *hndl)
  */
 struct selabel_handle *selinux_restorecon_default_handle(void)
 {
-	return NULL;
+	struct selabel_handle *sehandle;
+
+	struct selinux_opt fc_opts[] = {
+		{ SELABEL_OPT_DIGEST, (char *)1 }
+	};
+
+	sehandle = selabel_open(SELABEL_CTX_FILE, fc_opts, 1);
+
+	if (!sehandle) {
+		selinux_log(SELINUX_ERROR,
+			    "Error obtaining file context handle: %s\n",
+						    strerror(errno));
+		return NULL;
+	}
+
+	return sehandle;
 }
 
 /*
@@ -757,17 +1083,161 @@ struct selabel_handle *selinux_restorecon_default_handle(void)
  */
 void selinux_restorecon_set_exclude_list(const char **exclude_list)
 {
+	int i;
+	struct stat sb;
+
+	for (i = 0; exclude_list[i]; i++) {
+		if (lstat(exclude_list[i], &sb) < 0 && errno != EACCES) {
+			selinux_log(SELINUX_ERROR,
+				    "lstat error on exclude path \"%s\", %s - ignoring.\n",
+				    exclude_list[i], strerror(errno));
+			break;
+		}
+		if (add_exclude(exclude_list[i], CALLER_EXCLUDED) &&
+		    errno == ENOMEM)
+			assert(0);
+	}
 }
 
 /* selinux_restorecon_set_alt_rootpath(3) sets an alternate rootpath. */
 int selinux_restorecon_set_alt_rootpath(const char *alt_rootpath)
 {
-        return 0;
+	int len;
+
+	/* This should be NULL on first use */
+	if (rootpath)
+		free(rootpath);
+
+	rootpath = strdup(alt_rootpath);
+	if (!rootpath) {
+		selinux_log(SELINUX_ERROR, "%s:  Out of memory\n", __func__);
+		return -1;
+	}
+
+	/* trim trailing /, if present */
+	len = strlen(rootpath);
+	while (len && (rootpath[len - 1] == '/'))
+		rootpath[--len] = '\0';
+	rootpathlen = len;
+
+	return 0;
 }
 
 /* selinux_restorecon_xattr(3) - Find RESTORECON_LAST entries. */
 int selinux_restorecon_xattr(const char *pathname, unsigned int xattr_flags,
 					    struct dir_xattr ***xattr_list)
 {
-        return 0;
+	bool recurse = (xattr_flags &
+	    SELINUX_RESTORECON_XATTR_RECURSE) ? true : false;
+	bool delete_nonmatch = (xattr_flags &
+	    SELINUX_RESTORECON_XATTR_DELETE_NONMATCH_DIGESTS) ? true : false;
+	bool delete_all = (xattr_flags &
+	    SELINUX_RESTORECON_XATTR_DELETE_ALL_DIGESTS) ? true : false;
+	ignore_mounts = (xattr_flags &
+	   SELINUX_RESTORECON_XATTR_IGNORE_MOUNTS) ? true : false;
+
+	int rc, fts_flags;
+	struct stat sb;
+	struct statfs sfsb;
+	struct dir_xattr *current, *next;
+	FTS *fts;
+	FTSENT *ftsent;
+	char *paths[2] = { NULL, NULL };
+
+	__selinux_once(fc_once, restorecon_init);
+
+	if (!fc_sehandle || !fc_digest_len)
+		return -1;
+
+	if (lstat(pathname, &sb) < 0) {
+		if (errno == ENOENT)
+			return 0;
+
+		selinux_log(SELINUX_ERROR,
+			    "lstat(%s) failed: %s\n",
+			    pathname, strerror(errno));
+		return -1;
+	}
+
+	if (!recurse) {
+		if (statfs(pathname, &sfsb) == 0) {
+			if (sfsb.f_type == RAMFS_MAGIC ||
+			    sfsb.f_type == TMPFS_MAGIC)
+				return 0;
+		}
+
+		if (check_excluded(pathname))
+			return 0;
+
+		rc = add_xattr_entry(pathname, delete_nonmatch, delete_all);
+
+		if (!rc && dir_xattr_list)
+			*xattr_list = &dir_xattr_list;
+		else if (rc == -1)
+			return rc;
+
+		return 0;
+	}
+
+	paths[0] = (char *)pathname;
+	fts_flags = FTS_PHYSICAL | FTS_NOCHDIR;
+
+	fts = fts_open(paths, fts_flags, NULL);
+	if (!fts) {
+		selinux_log(SELINUX_ERROR,
+			    "fts error on %s: %s\n",
+			    paths[0], strerror(errno));
+		return -1;
+	}
+
+	while ((ftsent = fts_read(fts)) != NULL) {
+		switch (ftsent->fts_info) {
+		case FTS_DP:
+			continue;
+		case FTS_D:
+			if (statfs(ftsent->fts_path, &sfsb) == 0) {
+				if (sfsb.f_type == RAMFS_MAGIC ||
+				    sfsb.f_type == TMPFS_MAGIC)
+					continue;
+			}
+			if (check_excluded(ftsent->fts_path)) {
+				fts_set(fts, ftsent, FTS_SKIP);
+				continue;
+			}
+
+			rc = add_xattr_entry(ftsent->fts_path,
+					     delete_nonmatch, delete_all);
+			if (rc == 1)
+				continue;
+			else if (rc == -1)
+				goto cleanup;
+			break;
+		default:
+			break;
+		}
+	}
+
+	if (dir_xattr_list)
+		*xattr_list = &dir_xattr_list;
+
+	(void) fts_close(fts);
+	return 0;
+
+cleanup:
+	rc = errno;
+	(void) fts_close(fts);
+	errno = rc;
+
+	if (dir_xattr_list) {
+		/* Free any used memory */
+		current = dir_xattr_list;
+		while (current) {
+			next = current->next;
+			free(current->directory);
+			free(current->digest);
+			free(current);
+			current = next;
+		}
+	}
+	return -1;
 }
diff --git a/libselinux/src/sestatus.c b/libselinux/src/sestatus.c
index 07a7199..ed29dc5 100644
--- a/libselinux/src/sestatus.c
+++ b/libselinux/src/sestatus.c
@@ -87,7 +87,39 @@ static inline uint32_t read_sequence(struct selinux_status_t *status)
  */
 int selinux_status_updated(void)
 {
-        return 0;
+	uint32_t	curr_seqno;
+	int		result = 0;
+
+	if (selinux_status == NULL) {
+		errno = EINVAL;
+		return -1;
+	}
+
+	if (selinux_status == MAP_FAILED) {
+		if (avc_netlink_check_nb() < 0)
+			return -1;
+
+		curr_seqno = fallback_sequence;
+	} else {
+		curr_seqno = read_sequence(selinux_status);
+	}
+
+	/*
+	 * `curr_seqno' is always even-number, so it does not match with
+	 * `last_seqno' being initialized to odd-number in the first call.
+	 * We never return 'something was updated' in the first call,
+	 * because this function focuses on status-updating since the last
+	 * invocation.
+	 */
+	if (last_seqno & 0x0001)
+		last_seqno = curr_seqno;
+
+	if (last_seqno != curr_seqno)
+	{
+		last_seqno = curr_seqno;
+		result = 1;
+	}
+	return result;
 }
 
 /*
@@ -98,7 +130,30 @@ int selinux_status_updated(void)
  */
 int selinux_status_getenforce(void)
 {
-        return 0;
+	uint32_t	seqno;
+	uint32_t	enforcing;
+
+	if (selinux_status == NULL) {
+		errno = EINVAL;
+		return -1;
+	}
+
+	if (selinux_status == MAP_FAILED) {
+		if (avc_netlink_check_nb() < 0)
+			return -1;
+
+		return fallback_enforcing;
+	}
+
+	/* sequence must not be changed during references */
+	do {
+		seqno = read_sequence(selinux_status);
+
+		enforcing = selinux_status->enforcing;
+
+	} while (seqno != read_sequence(selinux_status));
+
+	return enforcing ? 1 : 0;
 }
 
 /*
@@ -112,7 +167,30 @@ int selinux_status_getenforce(void)
  */
 int selinux_status_policyload(void)
 {
-        return 0;
+	uint32_t	seqno;
+	uint32_t	policyload;
+
+	if (selinux_status == NULL) {
+		errno = EINVAL;
+		return -1;
+	}
+
+	if (selinux_status == MAP_FAILED) {
+		if (avc_netlink_check_nb() < 0)
+			return -1;
+
+		return fallback_policyload;
+	}
+
+	/* sequence must not be changed during references */
+	do {
+		seqno = read_sequence(selinux_status);
+
+		policyload = selinux_status->policyload;
+
+	} while (seqno != read_sequence(selinux_status));
+
+	return policyload;
 }
 
 /*
@@ -124,7 +202,26 @@ int selinux_status_policyload(void)
  */
 int selinux_status_deny_unknown(void)
 {
-        return 0;
+	uint32_t	seqno;
+	uint32_t	deny_unknown;
+
+	if (selinux_status == NULL) {
+		errno = EINVAL;
+		return -1;
+	}
+
+	if (selinux_status == MAP_FAILED)
+		return security_deny_unknown();
+
+	/* sequence must not be changed during references */
+	do {
+		seqno = read_sequence(selinux_status);
+
+		deny_unknown = selinux_status->deny_unknown;
+
+	} while (seqno != read_sequence(selinux_status));
+
+	return deny_unknown ? 1 : 0;
 }
 
 /*
@@ -157,7 +254,64 @@ static int fallback_cb_policyload(int policyload)
  */
 int selinux_status_open(int fallback)
 {
-        return 0;
+	int	fd;
+	char	path[PATH_MAX];
+	long	pagesize;
+
+	if (!selinux_mnt) {
+		errno = ENOENT;
+		return -1;
+	}
+
+	pagesize = sysconf(_SC_PAGESIZE);
+	if (pagesize < 0)
+		return -1;
+
+	snprintf(path, sizeof(path), "%s/status", selinux_mnt);
+	fd = open(path, O_RDONLY | O_CLOEXEC);
+	if (fd < 0)
+		goto error;
+
+	selinux_status = mmap(NULL, pagesize, PROT_READ, MAP_SHARED, fd, 0);
+	if (selinux_status == MAP_FAILED) {
+		close(fd);
+		goto error;
+	}
+	selinux_status_fd = fd;
+	last_seqno = (uint32_t)(-1);
+
+	return 0;
+
+error:
+	/*
+	 * If caller wants fallback routine, we try to provide
+	 * an equivalent functionality using existing netlink
+	 * socket, although it needs system call invocation to
+	 * receive event notification.
+	 */
+	if (fallback && avc_netlink_open(0) == 0) {
+		union selinux_callback	cb;
+
+		/* register my callbacks */
+		cb.func_setenforce = fallback_cb_setenforce;
+		selinux_set_callback(SELINUX_CB_SETENFORCE, cb);
+		cb.func_policyload = fallback_cb_policyload;
+		selinux_set_callback(SELINUX_CB_POLICYLOAD, cb);
+
+		/* mark as fallback mode */
+		selinux_status = MAP_FAILED;
+		selinux_status_fd = avc_netlink_acquire_fd();
+		last_seqno = (uint32_t)(-1);
+
+		fallback_sequence = 0;
+		fallback_enforcing = security_getenforce();
+		fallback_policyload = 0;
+
+		return 1;
+	}
+	selinux_status = NULL;
+
+	return -1;
 }
 
 /*
@@ -168,4 +322,28 @@ int selinux_status_open(int fallback)
  */
 void selinux_status_close(void)
 {
+	long pagesize;
+
+	/* not opened */
+	if (selinux_status == NULL)
+		return;
+
+	/* fallback-mode */
+	if (selinux_status == MAP_FAILED)
+	{
+		avc_netlink_release_fd();
+		avc_netlink_close();
+		selinux_status = NULL;
+		return;
+	}
+
+	pagesize = sysconf(_SC_PAGESIZE);
+	/* not much we can do other than leak memory */
+	if (pagesize > 0)
+		munmap(selinux_status, pagesize);
+	selinux_status = NULL;
+
+	close(selinux_status_fd);
+	selinux_status_fd = -1;
+	last_seqno = (uint32_t)(-1);
 }
diff --git a/libselinux/src/setenforce.c b/libselinux/src/setenforce.c
index 5e5470b..e5e7612 100644
--- a/libselinux/src/setenforce.c
+++ b/libselinux/src/setenforce.c
@@ -11,7 +11,27 @@
 
 int security_setenforce(int value)
 {
-        return 0;
+	int fd, ret;
+	char path[PATH_MAX];
+	char buf[20];
+
+	if (!selinux_mnt) {
+		errno = ENOENT;
+		return -1;
+	}
+
+	snprintf(path, sizeof path, "%s/enforce", selinux_mnt);
+	fd = open(path, O_RDWR);
+	if (fd < 0)
+		return -1;
+
+	snprintf(buf, sizeof buf, "%d", value);
+	ret = write(fd, buf, strlen(buf));
+	close(fd);
+	if (ret < 0)
+		return -1;
+
+	return 0;
 }
 
 hidden_def(security_setenforce)
diff --git a/libselinux/src/setexecfilecon.c b/libselinux/src/setexecfilecon.c
index b5a2c23..e72ba0d 100644
--- a/libselinux/src/setexecfilecon.c
+++ b/libselinux/src/setexecfilecon.c
@@ -6,13 +6,65 @@
 
 int setexecfilecon(const char *filename, const char *fallback_type)
 {
-        return 0;
+	char * mycon = NULL, *fcon = NULL, *newcon = NULL;
+	context_t con = NULL;
+	int rc = 0;
+
+	if (is_selinux_enabled() < 1)
+		return 0;
+
+	rc = getcon(&mycon);
+	if (rc < 0)
+		goto out;
+
+	rc = getfilecon(filename, &fcon);
+	if (rc < 0)
+		goto out;
+
+	rc = security_compute_create(mycon, fcon, string_to_security_class("process"), &newcon);
+	if (rc < 0)
+		goto out;
+
+	if (!strcmp(mycon, newcon)) {
+		/* No default transition, use fallback_type for now. */
+		rc = -1;
+		con = context_new(mycon);
+		if (!con)
+			goto out;
+		if (context_type_set(con, fallback_type))
+			goto out;
+		freecon(newcon);
+		newcon = strdup(context_str(con));
+		if (!newcon)
+			goto out;
+		rc = 0;
+	}
+
+	rc = setexeccon(newcon);
+	if (rc < 0)
+		goto out;
+      out:
+
+	if (rc < 0 && security_getenforce() == 0)
+		rc = 0;
+
+	context_free(con);
+	freecon(newcon);
+	freecon(fcon);
+	freecon(mycon);
+	return rc < 0 ? rc : 0;
 }
 
 #ifndef DISABLE_RPM
 int rpm_execcon(unsigned int verified __attribute__ ((unused)),
 		const char *filename, char *const argv[], char *const envp[])
 {
-        return 0;
+	int rc;
+
+	rc = setexecfilecon(filename, "rpm_script_t");
+	if (rc < 0)
+		return rc;
+
+	return execve(filename, argv, envp);
 }
 #endif
diff --git a/libselinux/src/setfilecon.c b/libselinux/src/setfilecon.c
index 26f7e83..d05969c 100644
--- a/libselinux/src/setfilecon.c
+++ b/libselinux/src/setfilecon.c
@@ -9,12 +9,35 @@
 
 int setfilecon_raw(const char *path, const char * context)
 {
-        return 0;
+	int rc = setxattr(path, XATTR_NAME_SELINUX, context, strlen(context) + 1,
+			0);
+	if (rc < 0 && errno == ENOTSUP) {
+		char * ccontext = NULL;
+		int err = errno;
+		if ((getfilecon_raw(path, &ccontext) >= 0) &&
+		    (strcmp(context,ccontext) == 0)) {
+			rc = 0;
+		} else {
+			errno = err;
+		}
+		freecon(ccontext);
+	}
+	return rc;
 }
 
 hidden_def(setfilecon_raw)
 
 int setfilecon(const char *path, const char *context)
 {
-        return 0;
+	int ret;
+	char * rcontext;
+
+	if (selinux_trans_to_raw_context(context, &rcontext))
+		return -1;
+
+	ret = setfilecon_raw(path, rcontext);
+
+	freecon(rcontext);
+
+	return ret;
 }
diff --git a/libselinux/src/setrans_client.c b/libselinux/src/setrans_client.c
index 14c7d80..fa188a8 100644
--- a/libselinux/src/setrans_client.c
+++ b/libselinux/src/setrans_client.c
@@ -262,6 +262,10 @@ void __attribute__((destructor)) setrans_lib_destructor(void);
 
 void hidden __attribute__((destructor)) setrans_lib_destructor(void)
 {
+	if (!has_setrans)
+		return;
+	if (destructor_key_initialized)
+		__selinux_key_delete(destructor_key);
 }
 
 static inline void init_thread_destructor(void)
@@ -286,7 +290,41 @@ static void init_context_translations(void)
 int selinux_trans_to_raw_context(const char * trans,
 				 char ** rawp)
 {
-        return 0;
+	if (!trans) {
+		*rawp = NULL;
+		return 0;
+	}
+
+	__selinux_once(once, init_context_translations);
+	init_thread_destructor();
+
+	if (!has_setrans) {
+		*rawp = strdup(trans);
+		goto out;
+	}
+
+	if (prev_t2r_trans && strcmp(prev_t2r_trans, trans) == 0) {
+		*rawp = strdup(prev_t2r_raw);
+	} else {
+		free(prev_t2r_trans);
+		prev_t2r_trans = NULL;
+		free(prev_t2r_raw);
+		prev_t2r_raw = NULL;
+		if (trans_to_raw_context(trans, rawp))
+			*rawp = strdup(trans);
+		if (*rawp) {
+			prev_t2r_trans = strdup(trans);
+			if (!prev_t2r_trans)
+				goto out;
+			prev_t2r_raw = strdup(*rawp);
+			if (!prev_t2r_raw) {
+				free(prev_t2r_trans);
+				prev_t2r_trans = NULL;
+			}
+		}
+	}
+      out:
+	return *rawp ? 0 : -1;
 }
 
 hidden_def(selinux_trans_to_raw_context)
@@ -294,14 +332,82 @@ hidden_def(selinux_trans_to_raw_context)
 int selinux_raw_to_trans_context(const char * raw,
 				 char ** transp)
 {
-        return 0;
+	if (!raw) {
+		*transp = NULL;
+		return 0;
+	}
+
+	__selinux_once(once, init_context_translations);
+	init_thread_destructor();
+
+	if (!has_setrans)  {
+		*transp = strdup(raw);
+		goto out;
+	}
+
+	if (prev_r2t_raw && strcmp(prev_r2t_raw, raw) == 0) {
+		*transp = strdup(prev_r2t_trans);
+	} else {
+		free(prev_r2t_raw);
+		prev_r2t_raw = NULL;
+		free(prev_r2t_trans);
+		prev_r2t_trans = NULL;
+		if (raw_to_trans_context(raw, transp))
+			*transp = strdup(raw);
+		if (*transp) {
+			prev_r2t_raw = strdup(raw);
+			if (!prev_r2t_raw)
+				goto out;
+			prev_r2t_trans = strdup(*transp);
+			if (!prev_r2t_trans) {
+				free(prev_r2t_raw);
+				prev_r2t_raw = NULL;
+			}
+		}
+	}
+      out:
+	return *transp ? 0 : -1;
 }
 
 hidden_def(selinux_raw_to_trans_context)
 
 int selinux_raw_context_to_color(const char * raw, char **transp)
 {
-        return 0;
+	if (!raw) {
+		*transp = NULL;
+		return -1;
+	}
+
+	__selinux_once(once, init_context_translations);
+	init_thread_destructor();
+
+	if (!has_setrans) {
+		*transp = strdup(raw);
+		goto out;
+	}
+
+	if (prev_r2c_raw && strcmp(prev_r2c_raw, raw) == 0) {
+		*transp = strdup(prev_r2c_trans);
+	} else {
+		free(prev_r2c_raw);
+		prev_r2c_raw = NULL;
+		free(prev_r2c_trans);
+		prev_r2c_trans = NULL;
+		if (raw_context_to_color(raw, transp))
+			return -1;
+		if (*transp) {
+			prev_r2c_raw = strdup(raw);
+			if (!prev_r2c_raw)
+				goto out;
+			prev_r2c_trans = strdup(*transp);
+			if (!prev_r2c_trans) {
+				free(prev_r2c_raw);
+				prev_r2c_raw = NULL;
+			}
+		}
+	}
+      out:
+	return *transp ? 0 : -1;
 }
 
 hidden_def(selinux_raw_context_to_color)
@@ -310,7 +416,14 @@ hidden_def(selinux_raw_context_to_color)
 int selinux_trans_to_raw_context(const char * trans,
 				 char ** rawp)
 {
-        return 0;
+	if (!trans) {
+		*rawp = NULL;
+		return 0;
+	}
+
+	*rawp = strdup(trans);
+	
+	return *rawp ? 0 : -1;
 }
 
 hidden_def(selinux_trans_to_raw_context)
@@ -318,7 +431,13 @@ hidden_def(selinux_trans_to_raw_context)
 int selinux_raw_to_trans_context(const char * raw,
 				 char ** transp)
 {
-	return 0;
+	if (!raw) {
+		*transp = NULL;
+		return 0;
+	}
+	*transp = strdup(raw);
+	
+	return *transp ? 0 : -1;
 }
 
 hidden_def(selinux_raw_to_trans_context)
diff --git a/libselinux/src/seusers.c b/libselinux/src/seusers.c
index 9b42618..09e704b 100644
--- a/libselinux/src/seusers.c
+++ b/libselinux/src/seusers.c
@@ -168,10 +168,164 @@ static int check_group(const char *group, const char *name, const gid_t gid) {
 
 int getseuserbyname(const char *name, char **r_seuser, char **r_level)
 {
+	FILE *cfg = NULL;
+	size_t size = 0;
+	char *buffer = NULL;
+	int rc;
+	unsigned long lineno = 0;
+	int mls_enabled = is_selinux_mls_enabled();
+
+	char *username = NULL;
+	char *seuser = NULL;
+	char *level = NULL;
+	char *groupseuser = NULL;
+	char *grouplevel = NULL;
+	char *defaultseuser = NULL;
+	char *defaultlevel = NULL;
+
+	gid_t gid = get_default_gid(name);
+
+	cfg = fopen(selinux_usersconf_path(), "r");
+	if (!cfg)
+		goto nomatch;
+
+	__fsetlocking(cfg, FSETLOCKING_BYCALLER);
+	while (getline(&buffer, &size, cfg) > 0) {
+		++lineno;
+		rc = process_seusers(buffer, &username, &seuser, &level,
+				     mls_enabled);
+		if (rc == -1)
+			continue;	/* comment, skip */
+		if (rc == -2) {
+			fprintf(stderr, "%s:  error on line %lu, skipping...\n",
+				selinux_usersconf_path(), lineno);
+			continue;
+		}
+
+		if (!strcmp(username, name))
+			break;
+
+		if (username[0] == '%' && 
+		    !groupseuser && 
+		    check_group(&username[1], name, gid)) {
+				groupseuser = seuser;
+				grouplevel = level;
+		} else {
+			if (!defaultseuser && 
+			    !strcmp(username, "__default__")) {
+				defaultseuser = seuser;
+				defaultlevel = level;
+			} else {
+				free(seuser);
+				free(level);
+			}
+		}
+		free(username);
+		username = NULL;
+		seuser = NULL;
+	}
+
+	free(buffer);
+	fclose(cfg);
+
+	if (seuser) {
+		free(username);
+		free(defaultseuser);
+		free(defaultlevel);
+		free(groupseuser);
+		free(grouplevel);
+		*r_seuser = seuser;
+		*r_level = level;
+		return 0;
+	}
+
+	if (groupseuser) {
+		free(defaultseuser);
+		free(defaultlevel);
+		*r_seuser = groupseuser;
+		*r_level = grouplevel;
+		return 0;
+	}
+
+	if (defaultseuser) {
+		*r_seuser = defaultseuser;
+		*r_level = defaultlevel;
+		return 0;
+	}
+
+      nomatch:
+	if (require_seusers)
+		return -1;
+
+	/* Fall back to the Linux username and no level. */
+	*r_seuser = strdup(name);
+	if (!(*r_seuser))
+		return -1;
+	*r_level = NULL;
 	return 0;
 }
 
 int getseuser(const char *username, const char *service, 
 	      char **r_seuser, char **r_level) {
-	return 0;
+	int ret = -1;
+	int len = 0;
+	char *seuser = NULL;
+	char *level = NULL;
+	char *buffer = NULL;
+	size_t size = 0;
+	char *rec = NULL;
+	char *path=NULL;
+	FILE *fp = NULL;
+	if (asprintf(&path,"%s/logins/%s", selinux_policy_root(), username) <  0)
+		goto err;
+	fp = fopen(path, "r");
+	free(path);
+	if (fp == NULL) goto err;
+	__fsetlocking(fp, FSETLOCKING_BYCALLER);
+	while (getline(&buffer, &size, fp) > 0) {
+		if (strncmp(buffer, "*:", 2) == 0) {
+			free(rec);
+			rec = strdup(buffer);
+			continue;
+		}
+		if (!service)
+			continue;
+		len = strlen(service);
+		if ((strncmp(buffer, service, len) == 0) &&
+		    (buffer[len] == ':')) {
+			free(rec);
+			rec = strdup(buffer);
+			break;
+		}
+	}
+
+	if (! rec)  goto err;
+	seuser = strchr(rec, ':');
+	if (! seuser) goto err;
+
+	seuser++;
+	level = strchr(seuser, ':');
+	if (! level) goto err;
+	*level = 0;
+	level++;
+	*r_seuser = strdup(seuser);
+	if (! *r_seuser) goto err;
+
+	len = strlen(level);
+	if (len && level[len-1] == '\n')
+		level[len-1] = 0;
+
+	*r_level = strdup(level);
+	if (! *r_level) {
+		free(*r_seuser);
+		goto err;
+	}
+	ret = 0;
+
+	err:
+	free(buffer);
+	if (fp) fclose(fp);
+	free(rec);
+
+	return (ret ? getseuserbyname(username, r_seuser, r_level) : ret);
 }
diff --git a/libselinux/src/sha1.c b/libselinux/src/sha1.c
index 47f2e9e..9bcbb6e 100644
--- a/libselinux/src/sha1.c
+++ b/libselinux/src/sha1.c
@@ -132,6 +132,14 @@ void hidden
         Sha1Context*                Context
     )
 {
+    // SHA1 initialization constants
+    Context->State[0] = 0x67452301;
+    Context->State[1] = 0xEFCDAB89;
+    Context->State[2] = 0x98BADCFE;
+    Context->State[3] = 0x10325476;
+    Context->State[4] = 0xC3D2E1F0;
+    Context->Count[0] = 0;
+    Context->Count[1] = 0;
 }
 
 ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
@@ -148,6 +156,33 @@ void hidden
         uint32_t            BufferSize
     )
 {
+    uint32_t    i;
+    uint32_t    j;
+
+    j = (Context->Count[0] >> 3) & 63;
+    if( (Context->Count[0] += BufferSize << 3) < (BufferSize << 3) )
+    {
+        Context->Count[1]++;
+    }
+
+    Context->Count[1] += (BufferSize >> 29);
+    if( (j + BufferSize) > 63 )
+    {
+        i = 64 - j;
+        memcpy( &Context->Buffer[j], Buffer, i );
+        TransformFunction(Context->State, Context->Buffer);
+        for( ; i + 63 < BufferSize; i += 64 )
+        {
+            TransformFunction(Context->State, (uint8_t*)Buffer + i);
+        }
+        j = 0;
+    }
+    else
+    {
+        i = 0;
+    }
+
+    memcpy( &Context->Buffer[j], &((uint8_t*)Buffer)[i], BufferSize - i );
 }
 
 ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
@@ -163,4 +198,23 @@ void hidden
         SHA1_HASH*                  Digest
     )
 {
+    uint32_t    i;
+    uint8_t     finalcount[8];
+
+    for( i=0; i<8; i++ )
+    {
+        finalcount[i] = (unsigned char)((Context->Count[(i >= 4 ? 0 : 1)]
+         >> ((3-(i & 3)) * 8) ) & 255);  // Endian independent
+    }
+    Sha1Update( Context, (uint8_t*)"\x80", 1 );
+    while( (Context->Count[0] & 504) != 448 )
+    {
+        Sha1Update( Context, (uint8_t*)"\0", 1 );
+    }
+
+    Sha1Update( Context, finalcount, 8 );  // Should cause a Sha1TransformFunction()
+    for( i=0; i<SHA1_HASH_SIZE; i++ )
+    {
+        Digest->bytes[i] = (uint8_t)((Context->State[i>>2] >> ((3-(i & 3)) * 8) ) & 255);
+    }
 }
diff --git a/libselinux/src/stringrep.c b/libselinux/src/stringrep.c
index 53ed4e2..2dbec2b 100644
--- a/libselinux/src/stringrep.c
+++ b/libselinux/src/stringrep.c
@@ -160,39 +160,190 @@ err1:
 
 hidden void flush_class_cache(void)
 {
+	struct discover_class_node *cur = discover_class_cache, *prev = NULL;
+	size_t i;
+
+	while (cur != NULL) {
+		free(cur->name);
+
+		for (i = 0; i < MAXVECTORS; i++)
+			free(cur->perms[i]);
+
+		free(cur->perms);
+
+		prev = cur;
+		cur = cur->next;
+
+		free(prev);
+	}
+
+	discover_class_cache = NULL;
 }
 
 security_class_t string_to_security_class(const char *s)
 {
-	return 0;
+	struct discover_class_node *node;
+
+	node = get_class_cache_entry_name(s);
+	if (node == NULL) {
+		node = discover_class(s);
+
+		if (node == NULL) {
+			errno = EINVAL;
+			return 0;
+		}
+	}
+
+	return map_class(node->value);
 }
 
 security_class_t mode_to_security_class(mode_t m) {
 
+	if (S_ISREG(m))
+		return string_to_security_class("file");
+	if (S_ISDIR(m))
+		return string_to_security_class("dir");
+	if (S_ISCHR(m))
+		return string_to_security_class("chr_file");
+	if (S_ISBLK(m))
+		return string_to_security_class("blk_file");
+	if (S_ISFIFO(m))
+		return string_to_security_class("fifo_file");
+	if (S_ISLNK(m))
+		return string_to_security_class("lnk_file");
+	if (S_ISSOCK(m))
+		return string_to_security_class("sock_file");
+
+	errno=EINVAL;
 	return 0;
 }
 
 access_vector_t string_to_av_perm(security_class_t tclass, const char *s)
 {
+	struct discover_class_node *node;
+	security_class_t kclass = unmap_class(tclass);
+
+	node = get_class_cache_entry_value(kclass);
+	if (node != NULL) {
+		size_t i;
+		for (i=0; i<MAXVECTORS && node->perms[i] != NULL; i++)
+			if (strcmp(node->perms[i],s) == 0)
+				return map_perm(tclass, 1<<i);
+	}
+
+	errno = EINVAL;
 	return 0;
 }
 
 const char *security_class_to_string(security_class_t tclass)
 {
+	struct discover_class_node *node;
+
+	tclass = unmap_class(tclass);
+
+	node = get_class_cache_entry_value(tclass);
+	if (node == NULL)
 		return NULL;
+	else
+		return node->name;
 }
 
 const char *security_av_perm_to_string(security_class_t tclass,
 				       access_vector_t av)
 {
+	struct discover_class_node *node;
+	size_t i;
+
+	av = unmap_perm(tclass, av);
+	tclass = unmap_class(tclass);
+
+	node = get_class_cache_entry_value(tclass);
+	if (av && node)
+		for (i = 0; i<MAXVECTORS; i++)
+			if ((1<<i) & av)
+				return node->perms[i];
+
 	return NULL;
 }
 
 int security_av_string(security_class_t tclass, access_vector_t av, char **res)
 {
-        return 0;
+	unsigned int i = 0;
+	size_t len = 5;
+	access_vector_t tmp = av;
+	int rc = 0;
+	const char *str;
+	char *ptr;
+
+	/* first pass computes the required length */
+	while (tmp) {
+		if (tmp & 1) {
+			str = security_av_perm_to_string(tclass, av & (1<<i));
+			if (str)
+				len += strlen(str) + 1;
+			else {
+				rc = -1;
+				errno = EINVAL;
+				goto out;
+			}
+		}
+		tmp >>= 1;
+		i++;
+	}
+
+	*res = malloc(len);
+	if (!*res) {
+		rc = -1;
+		goto out;
+	}
+
+	/* second pass constructs the string */
+	i = 0;
+	tmp = av;
+	ptr = *res;
+
+	if (!av) {
+		sprintf(ptr, "null");
+		goto out;
+	}
+
+	ptr += sprintf(ptr, "{ ");
+	while (tmp) {
+		if (tmp & 1)
+			ptr += sprintf(ptr, "%s ", security_av_perm_to_string(
+					       tclass, av & (1<<i)));
+		tmp >>= 1;
+		i++;
+	}
+	sprintf(ptr, "}");
+out:
+	return rc;
 }
 
 void print_access_vector(security_class_t tclass, access_vector_t av)
 {
+	const char *permstr;
+	access_vector_t bit = 1;
+
+	if (av == 0) {
+		printf(" null");
+		return;
+	}
+
+	printf(" {");
+
+	while (av) {
+		if (av & bit) {
+			permstr = security_av_perm_to_string(tclass, bit);
+			if (!permstr)
+				break;
+			printf(" %s", permstr);
+			av &= ~bit;
+		}
+		bit <<= 1;
+	}
+
+	if (av)
+		printf(" 0x%x", av);
+	printf(" }");
 }
-- 
2.7.4

