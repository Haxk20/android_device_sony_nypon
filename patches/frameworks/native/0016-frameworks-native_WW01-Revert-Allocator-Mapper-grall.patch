From 8bf48031071b142868a5749520ebb9f76fda49ee Mon Sep 17 00:00:00 2001
From: Shilin Victor <chrono.monochrome@gmail.com>
Date: Mon, 26 Dec 2016 19:45:41 +0700
Subject: [PATCH 16/27] 
 frameworks-native_WW01-Revert-Allocator-Mapper-gralloc1.patch

Change-Id: I1a176898b8f03979052c181d470d957a9a4f7c3b
---
 include/ui/GraphicBuffer.h            |   4 +-
 include/ui/GraphicBufferAllocator.h   |  46 ++--
 include/ui/GraphicBufferMapper.h      |  25 +--
 libs/gui/GLConsumer.cpp               |   3 +-
 libs/gui/GraphicBufferAlloc.cpp       |  54 +++++
 libs/nativewindow/AHardwareBuffer.cpp |   2 +-
 libs/ui/Android.bp                    |   4 -
 libs/ui/GraphicBuffer.cpp             |  40 ++--
 libs/ui/GraphicBufferAllocator.cpp    | 155 ++++----------
 libs/ui/GraphicBufferMapper.cpp       | 390 ++++++++++------------------------
 10 files changed, 256 insertions(+), 467 deletions(-)
 create mode 100644 libs/gui/GraphicBufferAlloc.cpp

diff --git a/include/ui/GraphicBuffer.h b/include/ui/GraphicBuffer.h
index 4b82cff..27d289d 100644
--- a/include/ui/GraphicBuffer.h
+++ b/include/ui/GraphicBuffer.h
@@ -171,8 +171,10 @@ public:
     status_t lockAsync(uint32_t inUsage, void** vaddr, int fenceFd);
     status_t lockAsync(uint32_t inUsage, const Rect& rect, void** vaddr,
             int fenceFd);
+/*
     status_t lockAsync(uint64_t inProducerUsage, uint64_t inConsumerUsage,
             const Rect& rect, void** vaddr, int fenceFd);
+*/
     status_t lockAsyncYCbCr(uint32_t inUsage, android_ycbcr *ycbcr,
             int fenceFd);
     status_t lockAsyncYCbCr(uint32_t inUsage, const Rect& rect,
@@ -218,7 +220,7 @@ private:
 
     status_t initWithSize(uint32_t inWidth, uint32_t inHeight,
             PixelFormat inFormat, uint32_t inLayerCount,
-            uint64_t inUsage, std::string requestorName);
+            uint32_t inUsage);
 
     status_t initWithHandle(const native_handle_t* handle,
             HandleWrapMethod method, uint32_t width, uint32_t height,
diff --git a/include/ui/GraphicBufferAllocator.h b/include/ui/GraphicBufferAllocator.h
index e4c3aab..3826579 100644
--- a/include/ui/GraphicBufferAllocator.h
+++ b/include/ui/GraphicBufferAllocator.h
@@ -30,14 +30,13 @@
 #include <utils/Mutex.h>
 #include <utils/Singleton.h>
 
-#include <ui/Gralloc1.h>
 #include <ui/PixelFormat.h>
 
-namespace android {
+#include <hardware/gralloc.h>
 
-namespace Gralloc2 {
-class Allocator;
-}
+
+namespace android {
+// ---------------------------------------------------------------------------
 
 class GraphicBufferMapper;
 class String8;
@@ -46,30 +45,28 @@ class GraphicBufferAllocator : public Singleton<GraphicBufferAllocator>
 {
 public:
     enum {
-        USAGE_SW_READ_NEVER     = GRALLOC1_CONSUMER_USAGE_CPU_READ_NEVER,
-        USAGE_SW_READ_RARELY    = GRALLOC1_CONSUMER_USAGE_CPU_READ,
-        USAGE_SW_READ_OFTEN     = GRALLOC1_CONSUMER_USAGE_CPU_READ_OFTEN,
-        USAGE_SW_READ_MASK      = GRALLOC1_CONSUMER_USAGE_CPU_READ_OFTEN,
+        USAGE_SW_READ_NEVER     = GRALLOC_USAGE_SW_READ_NEVER,
+        USAGE_SW_READ_RARELY    = GRALLOC_USAGE_SW_READ_RARELY,
+        USAGE_SW_READ_OFTEN     = GRALLOC_USAGE_SW_READ_OFTEN,
+        USAGE_SW_READ_MASK      = GRALLOC_USAGE_SW_READ_MASK,
 
-        USAGE_SW_WRITE_NEVER    = GRALLOC1_PRODUCER_USAGE_CPU_WRITE_NEVER,
-        USAGE_SW_WRITE_RARELY   = GRALLOC1_PRODUCER_USAGE_CPU_WRITE,
-        USAGE_SW_WRITE_OFTEN    = GRALLOC1_PRODUCER_USAGE_CPU_WRITE_OFTEN,
-        USAGE_SW_WRITE_MASK     = GRALLOC1_PRODUCER_USAGE_CPU_WRITE_OFTEN,
+        USAGE_SW_WRITE_NEVER    = GRALLOC_USAGE_SW_WRITE_NEVER,
+        USAGE_SW_WRITE_RARELY   = GRALLOC_USAGE_SW_WRITE_RARELY,
+        USAGE_SW_WRITE_OFTEN    = GRALLOC_USAGE_SW_WRITE_OFTEN,
+        USAGE_SW_WRITE_MASK     = GRALLOC_USAGE_SW_WRITE_MASK,
 
         USAGE_SOFTWARE_MASK     = USAGE_SW_READ_MASK|USAGE_SW_WRITE_MASK,
 
-        USAGE_HW_TEXTURE        = GRALLOC1_CONSUMER_USAGE_GPU_TEXTURE,
-        USAGE_HW_RENDER         = GRALLOC1_PRODUCER_USAGE_GPU_RENDER_TARGET,
-        USAGE_HW_2D             = 0x00000400, // Deprecated
-        USAGE_HW_MASK           = 0x00071F00, // Deprecated
+        USAGE_HW_TEXTURE        = GRALLOC_USAGE_HW_TEXTURE,
+        USAGE_HW_RENDER         = GRALLOC_USAGE_HW_RENDER,
+        USAGE_HW_2D             = GRALLOC_USAGE_HW_2D,
+        USAGE_HW_MASK           = GRALLOC_USAGE_HW_MASK
     };
 
     static inline GraphicBufferAllocator& get() { return getInstance(); }
 
-    status_t allocate(uint32_t w, uint32_t h, PixelFormat format,
-            uint32_t layerCount, uint64_t usage,
-            buffer_handle_t* handle, uint32_t* stride, uint64_t graphicBufferId,
-            std::string requestorName);
+    status_t alloc(uint32_t w, uint32_t h, PixelFormat format, uint32_t usage,
+            buffer_handle_t* handle, uint32_t* stride);
 
     status_t free(buffer_handle_t handle);
 
@@ -85,7 +82,6 @@ private:
         uint32_t layerCount;
         uint64_t usage;
         size_t size;
-        std::string requestorName;
     };
 
     static Mutex sLock;
@@ -95,11 +91,7 @@ private:
     GraphicBufferAllocator();
     ~GraphicBufferAllocator();
 
-    GraphicBufferMapper& mMapper;
-    const std::unique_ptr<const Gralloc2::Allocator> mAllocator;
-
-    std::unique_ptr<Gralloc1::Loader> mLoader;
-    std::unique_ptr<Gralloc1::Device> mDevice;
+    alloc_device_t  *mAllocDev;
 };
 
 // ---------------------------------------------------------------------------
diff --git a/include/ui/GraphicBufferMapper.h b/include/ui/GraphicBufferMapper.h
index d69f8fc..78eb9c6 100644
--- a/include/ui/GraphicBufferMapper.h
+++ b/include/ui/GraphicBufferMapper.h
@@ -22,8 +22,6 @@
 
 #include <memory>
 
-#include <ui/Gralloc1.h>
-
 #include <utils/Singleton.h>
 
 
@@ -31,15 +29,12 @@
 // when/if we get rid of gralloc, we should provide aliases or fix call sites.
 #include <hardware/gralloc.h>
 
+struct gralloc_module_t;
 
 namespace android {
 
 // ---------------------------------------------------------------------------
 
-namespace Gralloc2 {
-class Mapper;
-}
-
 class Rect;
 
 class GraphicBufferMapper : public Singleton<GraphicBufferMapper>
@@ -49,11 +44,9 @@ public:
 
     // The imported outHandle must be freed with freeBuffer when no longer
     // needed. rawHandle is owned by the caller.
-    status_t importBuffer(buffer_handle_t rawHandle,
-            buffer_handle_t* outHandle);
+    status_t importBuffer(buffer_handle_t handle);
 
-    // This is temporary and will be removed soon
-    status_t importBuffer(const GraphicBuffer* buffer);
+    status_t unregisterBuffer(buffer_handle_t handle);
 
     status_t freeBuffer(buffer_handle_t handle);
 
@@ -78,20 +71,10 @@ public:
 
     status_t unlockAsync(buffer_handle_t handle, int *fenceFd);
 
-    const Gralloc2::Mapper& getGrallocMapper() const
-    {
-        return *mMapper;
-    }
-
 private:
     friend class Singleton<GraphicBufferMapper>;
-
     GraphicBufferMapper();
-
-    const std::unique_ptr<const Gralloc2::Mapper> mMapper;
-
-    std::unique_ptr<Gralloc1::Loader> mLoader;
-    std::unique_ptr<Gralloc1::Device> mDevice;
+    gralloc_module_t const *mAllocMod;
 };
 
 // ---------------------------------------------------------------------------
diff --git a/libs/gui/GLConsumer.cpp b/libs/gui/GLConsumer.cpp
index c654f08..02a7f79 100644
--- a/libs/gui/GLConsumer.cpp
+++ b/libs/gui/GLConsumer.cpp
@@ -348,8 +348,7 @@ sp<GraphicBuffer> GLConsumer::getDebugTexImageBuffer() {
         // continues to use it.
         sp<GraphicBuffer> buffer = new GraphicBuffer(
                 kDebugData.width, kDebugData.height, PIXEL_FORMAT_RGBA_8888,
-                GraphicBuffer::USAGE_SW_WRITE_RARELY,
-                "[GLConsumer debug texture]");
+                GraphicBuffer::USAGE_SW_WRITE_RARELY);
         uint32_t* bits;
         buffer->lock(GraphicBuffer::USAGE_SW_WRITE_RARELY, reinterpret_cast<void**>(&bits));
         uint32_t stride = buffer->getStride();
diff --git a/libs/gui/GraphicBufferAlloc.cpp b/libs/gui/GraphicBufferAlloc.cpp
new file mode 100644
index 0000000..9643402
--- /dev/null
+++ b/libs/gui/GraphicBufferAlloc.cpp
@@ -0,0 +1,54 @@
+/*
+ **
+ ** Copyright 2012 The Android Open Source Project
+ **
+ ** Licensed under the Apache License Version 2.0(the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing software
+ ** distributed under the License is distributed on an "AS IS" BASIS
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+#include <cutils/log.h>
+
+#include <ui/GraphicBuffer.h>
+
+#include <gui/GraphicBufferAlloc.h>
+
+// ----------------------------------------------------------------------------
+namespace android {
+// ----------------------------------------------------------------------------
+
+GraphicBufferAlloc::GraphicBufferAlloc() {
+}
+
+GraphicBufferAlloc::~GraphicBufferAlloc() {
+}
+
+sp<GraphicBuffer> GraphicBufferAlloc::createGraphicBuffer(uint32_t width,
+        uint32_t height, PixelFormat format, uint32_t usage, status_t* error) {
+    sp<GraphicBuffer> graphicBuffer(
+            new GraphicBuffer(width, height, format, usage));
+    status_t err = graphicBuffer->initCheck();
+    *error = err;
+    if (err != 0 || graphicBuffer->handle == 0) {
+        if (err == NO_MEMORY) {
+            GraphicBuffer::dumpAllocationsToSystemLog();
+        }
+        ALOGE("GraphicBufferAlloc::createGraphicBuffer(w=%d, h=%d) "
+             "failed (%s), handle=%p",
+                width, height, strerror(-err), graphicBuffer->handle);
+        return 0;
+    }
+    return graphicBuffer;
+}
+
+// ----------------------------------------------------------------------------
+}; // namespace android
+// ----------------------------------------------------------------------------
diff --git a/libs/nativewindow/AHardwareBuffer.cpp b/libs/nativewindow/AHardwareBuffer.cpp
index ed292e7..91f50ac 100644
--- a/libs/nativewindow/AHardwareBuffer.cpp
+++ b/libs/nativewindow/AHardwareBuffer.cpp
@@ -127,7 +127,7 @@ int AHardwareBuffer_lock(AHardwareBuffer* buffer, uint64_t usage,
     } else {
         bounds.set(Rect(rect->left, rect->top, rect->right, rect->bottom));
     }
-    return gBuffer->lockAsync(usage, usage, bounds, outVirtualAddress, fence);
+    return gBuffer->lockAsync(usage, bounds, outVirtualAddress, fence);
 }
 
 int AHardwareBuffer_unlock(AHardwareBuffer* buffer, int32_t* fence) {
diff --git a/libs/ui/Android.bp b/libs/ui/Android.bp
index 19da14b..0a334e0 100644
--- a/libs/ui/Android.bp
+++ b/libs/ui/Android.bp
@@ -19,7 +19,6 @@ cc_library_shared {
     clang: true,
     cppflags: [
         "-Weverything",
-        "-Werror",
 
         // The static constructors and destructors in this library have not been noted to
         // introduce significant overheads
@@ -51,9 +50,6 @@ cc_library_shared {
         "FenceTime.cpp",
         "FrameStats.cpp",
         "FramebufferNativeWindow.cpp",
-        "Gralloc1.cpp",
-        "Gralloc1On0Adapter.cpp", 
-        "Gralloc2.cpp",
         "GraphicBuffer.cpp",
         "GraphicBufferAllocator.cpp",
         "GraphicBufferMapper.cpp",
diff --git a/libs/ui/GraphicBuffer.cpp b/libs/ui/GraphicBuffer.cpp
index cfedf10..248b996 100644
--- a/libs/ui/GraphicBuffer.cpp
+++ b/libs/ui/GraphicBuffer.cpp
@@ -70,7 +70,7 @@ GraphicBuffer::GraphicBuffer(uint32_t inWidth, uint32_t inHeight,
     : GraphicBuffer()
 {
     mInitCheck = initWithSize(inWidth, inHeight, inFormat, inLayerCount,
-            usage, std::move(requestorName));
+            usage);
 }
 
 // deprecated
@@ -103,13 +103,18 @@ GraphicBuffer::~GraphicBuffer()
 
 void GraphicBuffer::free_handle()
 {
-    if (mOwner == ownHandle) {
-        mBufferMapper.freeBuffer(handle);
-    } else if (mOwner == ownData) {
-        GraphicBufferAllocator& allocator(GraphicBufferAllocator::get());
-        allocator.free(handle);
-    }
+     if (mOwner == ownHandle) {
+         mBufferMapper.unregisterBuffer(handle);
+         native_handle_close(handle);
+         native_handle_delete(const_cast<native_handle*>(handle));
+     } else if (mOwner == ownData) {
+         GraphicBufferAllocator& allocator(GraphicBufferAllocator::get());
+         allocator.free(handle);
+     }
+
+#ifndef EGL_NEEDS_HANDLE
     handle = NULL;
+#endif
 }
 
 status_t GraphicBuffer::initCheck() const {
@@ -148,7 +153,7 @@ status_t GraphicBuffer::reallocate(uint32_t inWidth, uint32_t inHeight,
         handle = 0;
     }
     return initWithSize(inWidth, inHeight, inFormat, inLayerCount,
-            inUsage, "[Reallocation]");
+            inUsage);
 }
 
 bool GraphicBuffer::needsReallocation(uint32_t inWidth, uint32_t inHeight,
@@ -163,14 +168,11 @@ bool GraphicBuffer::needsReallocation(uint32_t inWidth, uint32_t inHeight,
 }
 
 status_t GraphicBuffer::initWithSize(uint32_t inWidth, uint32_t inHeight,
-        PixelFormat inFormat, uint32_t inLayerCount, uint64_t inUsage,
-        std::string requestorName)
+        PixelFormat inFormat, uint32_t inLayerCount, uint32_t inUsage)
 {
     GraphicBufferAllocator& allocator = GraphicBufferAllocator::get();
     uint32_t outStride = 0;
-    status_t err = allocator.allocate(inWidth, inHeight, inFormat, inLayerCount,
-            inUsage, &handle, &outStride, mId,
-            std::move(requestorName));
+    status_t err = allocator.alloc(inWidth, inHeight, inFormat, inUsage, &handle, &outStride);
     if (err == NO_ERROR) {
         width = static_cast<int>(inWidth);
         height = static_cast<int>(inHeight);
@@ -211,7 +213,7 @@ status_t GraphicBuffer::initWithHandle(const native_handle_t* handle,
     mOwner = (method == WRAP_HANDLE) ? ownNone : ownHandle;
 
     if (method == TAKE_UNREGISTERED_HANDLE) {
-        status_t err = mBufferMapper.importBuffer(this);
+        status_t err = mBufferMapper.importBuffer(handle);
         if (err != NO_ERROR) {
             // clean up cloned handle
             if (clone) {
@@ -282,14 +284,15 @@ status_t GraphicBuffer::lockAsync(uint32_t inUsage, void** vaddr, int fenceFd)
     return res;
 }
 
+/*
 status_t GraphicBuffer::lockAsync(uint32_t inUsage, const Rect& rect,
         void** vaddr, int fenceFd)
 {
     return lockAsync(inUsage, inUsage, rect, vaddr, fenceFd);
 }
+*/
 
-status_t GraphicBuffer::lockAsync(uint64_t inProducerUsage,
-        uint64_t inConsumerUsage, const Rect& rect, void** vaddr, int fenceFd)
+status_t GraphicBuffer::lockAsync(uint32_t inUsage, const Rect& rect, void** vaddr, int fenceFd)
 {
     if (rect.left < 0 || rect.right  > width ||
         rect.top  < 0 || rect.bottom > height) {
@@ -298,8 +301,7 @@ status_t GraphicBuffer::lockAsync(uint64_t inProducerUsage,
                 width, height);
         return BAD_VALUE;
     }
-    status_t res = getBufferMapper().lockAsync(handle, inProducerUsage,
-            inConsumerUsage, rect, vaddr, fenceFd);
+    status_t res = getBufferMapper().lockAsync(handle, inUsage, rect, vaddr, fenceFd);
     return res;
 }
 
@@ -445,7 +447,7 @@ status_t GraphicBuffer::unflatten(
     mOwner = ownHandle;
 
     if (handle != 0) {
-        status_t err = mBufferMapper.importBuffer(this);
+        status_t err = mBufferMapper.importBuffer(handle);
         if (err != NO_ERROR) {
             width = height = stride = format = layerCount = usage = 0;
             handle = NULL;
diff --git a/libs/ui/GraphicBufferAllocator.cpp b/libs/ui/GraphicBufferAllocator.cpp
index 32eee0d..e685462 100644
--- a/libs/ui/GraphicBufferAllocator.cpp
+++ b/libs/ui/GraphicBufferAllocator.cpp
@@ -29,7 +29,6 @@
 #include <utils/String8.h>
 #include <utils/Trace.h>
 
-#include <ui/Gralloc2.h>
 #include <ui/GraphicBufferMapper.h>
 
 namespace android {
@@ -42,17 +41,20 @@ KeyedVector<buffer_handle_t,
     GraphicBufferAllocator::alloc_rec_t> GraphicBufferAllocator::sAllocList;
 
 GraphicBufferAllocator::GraphicBufferAllocator()
-  : mMapper(GraphicBufferMapper::getInstance()),
-    mAllocator(std::make_unique<Gralloc2::Allocator>(
-                mMapper.getGrallocMapper()))
+    : mAllocDev(0)
 {
-    if (!mAllocator->valid()) {
-        mLoader = std::make_unique<Gralloc1::Loader>();
-        mDevice = mLoader->getDevice();
+    hw_module_t const* module;
+    int err = hw_get_module(GRALLOC_HARDWARE_MODULE_ID, &module);
+    ALOGE_IF(err, "FATAL: can't find the %s module", GRALLOC_HARDWARE_MODULE_ID);
+    if (err == 0) {
+        gralloc_open(module, &mAllocDev);
     }
 }
 
-GraphicBufferAllocator::~GraphicBufferAllocator() {}
+GraphicBufferAllocator::~GraphicBufferAllocator()
+{
+    gralloc_close(mAllocDev);
+}
 
 void GraphicBufferAllocator::dump(String8& result) const
 {
@@ -68,31 +70,26 @@ void GraphicBufferAllocator::dump(String8& result) const
         const alloc_rec_t& rec(list.valueAt(i));
         if (rec.size) {
             snprintf(buffer, SIZE, "%10p: %7.2f KiB | %4u (%4u) x %4u | %4u | %8X | 0x%" PRIx64
-                    " | %s\n",
+                    "\n",
                     list.keyAt(i), rec.size/1024.0,
                     rec.width, rec.stride, rec.height, rec.layerCount, rec.format,
-                    rec.usage, rec.requestorName.c_str());
+                    rec.usage);
         } else {
             snprintf(buffer, SIZE, "%10p: unknown     | %4u (%4u) x %4u | %4u | %8X | 0x%" PRIx64
-                    " | %s\n",
+                    "\n",
                     list.keyAt(i),
                     rec.width, rec.stride, rec.height, rec.layerCount, rec.format,
-                    rec.usage, rec.requestorName.c_str());
+                    rec.usage);
         }
         result.append(buffer);
         total += rec.size;
     }
     snprintf(buffer, SIZE, "Total allocated (estimate): %.2f KB\n", total/1024.0);
     result.append(buffer);
-
-    std::string deviceDump;
-    if (mAllocator->valid()) {
-        deviceDump = mAllocator->dumpDebugInfo();
-    } else {
-        deviceDump = mDevice->dump();
+    if (mAllocDev->common.version >= 1 && mAllocDev->dump) {
+        mAllocDev->dump(mAllocDev, buffer, SIZE);
+        result.append(buffer);
     }
-
-    result.append(deviceDump.c_str(), deviceDump.size());
 }
 
 void GraphicBufferAllocator::dumpToSystemLog()
@@ -102,10 +99,9 @@ void GraphicBufferAllocator::dumpToSystemLog()
     ALOGD("%s", s.string());
 }
 
-status_t GraphicBufferAllocator::allocate(uint32_t width, uint32_t height,
-        PixelFormat format, uint32_t layerCount, uint64_t usage,
-        buffer_handle_t* handle, uint32_t* stride,
-        uint64_t graphicBufferId, std::string requestorName)
+status_t GraphicBufferAllocator::alloc(uint32_t width, uint32_t height,
+        PixelFormat format, uint32_t usage, buffer_handle_t* handle,
+        uint32_t* stride)
 {
     ATRACE_CALL();
 
@@ -114,82 +110,22 @@ status_t GraphicBufferAllocator::allocate(uint32_t width, uint32_t height,
     if (!width || !height)
         width = height = 1;
 
-    // Ensure that layerCount is valid.
-    if (layerCount < 1)
-        layerCount = 1;
-
-    gralloc1_error_t error;
-    if (mAllocator->valid()) {
-        Gralloc2::IMapper::BufferDescriptorInfo info = {};
-        info.width = width;
-        info.height = height;
-        info.layerCount = layerCount;
-        info.format = static_cast<Gralloc2::PixelFormat>(format);
-        info.usage = usage;
-        error = static_cast<gralloc1_error_t>(mAllocator->allocate(info,
-                    stride, handle));
-        if (error != GRALLOC1_ERROR_NONE) {
-            return NO_MEMORY;
-        }
-    } else {
-        uint64_t producerUsage, consumerUsage;
-        android_convertGralloc0To1Usage(static_cast<int32_t>(usage), &producerUsage, &consumerUsage);
-
-        auto descriptor = mDevice->createDescriptor();
-        error = descriptor->setDimensions(width, height);
-        if (error != GRALLOC1_ERROR_NONE) {
-            ALOGE("Failed to set dimensions to (%u, %u): %d",
-                    width, height, error);
-            return BAD_VALUE;
-        }
-        error = descriptor->setFormat(
-                static_cast<android_pixel_format_t>(format));
-        if (error != GRALLOC1_ERROR_NONE) {
-            ALOGE("Failed to set format to %d: %d", format, error);
-            return BAD_VALUE;
-        }
-        if (mDevice->hasCapability(GRALLOC1_CAPABILITY_LAYERED_BUFFERS)) {
-            error = descriptor->setLayerCount(layerCount);
-            if (error != GRALLOC1_ERROR_NONE) {
-                ALOGE("Failed to set layer count to %u: %d", layerCount, error);
-                return BAD_VALUE;
-            }
-        } else if (layerCount > 1) {
-            ALOGE("Failed to set layer count to %u: capability unsupported",
-                    layerCount);
-            return BAD_VALUE;
-        }
-        error = descriptor->setProducerUsage(
-                static_cast<gralloc1_producer_usage_t>(producerUsage));
-        if (error != GRALLOC1_ERROR_NONE) {
-            ALOGE("Failed to set producer usage to %" PRIx64 ": %d",
-                    producerUsage, error);
-            return BAD_VALUE;
-        }
-        error = descriptor->setConsumerUsage(
-                static_cast<gralloc1_consumer_usage_t>(consumerUsage));
-        if (error != GRALLOC1_ERROR_NONE) {
-            ALOGE("Failed to set consumer usage to %" PRIx64 ": %d",
-                    consumerUsage, error);
-            return BAD_VALUE;
-        }
+    // we have a h/w allocator and h/w buffer is requested
+    status_t err;
 
-        error = mDevice->allocate(descriptor, graphicBufferId, handle);
-        if (error != GRALLOC1_ERROR_NONE) {
-            ALOGE("Failed to allocate (%u x %u) layerCount %u format %d "
-                    "producerUsage %" PRIx64 " consumerUsage %" PRIx64 ": %d",
-                    width, height, layerCount, format, producerUsage,
-                    consumerUsage, error);
-            return NO_MEMORY;
-        }
+    // Filter out any usage bits that should not be passed to the gralloc module
+    usage &= GRALLOC_USAGE_ALLOC_MASK;
 
-        error = mDevice->getStride(*handle, stride);
-        if (error != GRALLOC1_ERROR_NONE) {
-            ALOGW("Failed to get stride from buffer: %d", error);
-        }
-    }
+    int outStride = 0;
+    err = mAllocDev->alloc(mAllocDev, static_cast<int>(width),
+            static_cast<int>(height), format, static_cast<int>(usage), handle,
+            &outStride);
+    *stride = static_cast<uint32_t>(outStride);
 
-    if (error == NO_ERROR) {
+    ALOGW_IF(err, "alloc(%u, %u, %d, %08x, ...) failed %d (%s)",
+            width, height, format, usage, err, strerror(-err));
+
+    if (err == NO_ERROR) {
         Mutex::Autolock _l(sLock);
         KeyedVector<buffer_handle_t, alloc_rec_t>& list(sAllocList);
         uint32_t bpp = bytesPerPixel(format);
@@ -198,36 +134,29 @@ status_t GraphicBufferAllocator::allocate(uint32_t width, uint32_t height,
         rec.height = height;
         rec.stride = *stride;
         rec.format = format;
-        rec.layerCount = layerCount;
         rec.usage = usage;
         rec.size = static_cast<size_t>(height * (*stride) * bpp);
-        rec.requestorName = std::move(requestorName);
         list.add(*handle, rec);
     }
 
-    return NO_ERROR;
+    return err;
 }
 
 status_t GraphicBufferAllocator::free(buffer_handle_t handle)
 {
     ATRACE_CALL();
+    status_t err;
 
-    gralloc1_error_t error;
-    if (mAllocator->valid()) {
-        error = static_cast<gralloc1_error_t>(mMapper.freeBuffer(handle));
-    } else {
-        error = mDevice->release(handle);
-    }
+    err = mAllocDev->free(mAllocDev, handle);
 
-    if (error != GRALLOC1_ERROR_NONE) {
-        ALOGE("Failed to free buffer: %d", error);
+    ALOGW_IF(err, "free(...) failed %d (%s)", err, strerror(-err));
+    if (err == NO_ERROR) {
+        Mutex::Autolock _l(sLock);
+        KeyedVector<buffer_handle_t, alloc_rec_t>& list(sAllocList);
+        list.removeItem(handle);
     }
 
-    Mutex::Autolock _l(sLock);
-    KeyedVector<buffer_handle_t, alloc_rec_t>& list(sAllocList);
-    list.removeItem(handle);
-
-    return NO_ERROR;
+    return err;
 }
 
 // ---------------------------------------------------------------------------
diff --git a/libs/ui/GraphicBufferMapper.cpp b/libs/ui/GraphicBufferMapper.cpp
index 87519bf..0f458a6 100644
--- a/libs/ui/GraphicBufferMapper.cpp
+++ b/libs/ui/GraphicBufferMapper.cpp
@@ -16,7 +16,6 @@
 
 #define LOG_TAG "GraphicBufferMapper"
 #define ATRACE_TAG ATRACE_TAG_GRAPHICS
-//#define LOG_NDEBUG 0
 
 #include <ui/GraphicBufferMapper.h>
 
@@ -32,10 +31,16 @@
 #include <utils/Log.h>
 #include <utils/Trace.h>
 
-#include <ui/Gralloc2.h>
 #include <ui/GraphicBuffer.h>
+#include <ui/GraphicBufferMapper.h>
+#include <ui/Rect.h>
+
+//#include <system/graphics.h>
+//#include <ui/Gralloc2.h>
+
+
+#include <hardware/gralloc.h>
 
-#include <system/graphics.h>
 
 namespace android {
 // ---------------------------------------------------------------------------
@@ -43,79 +48,32 @@ namespace android {
 ANDROID_SINGLETON_STATIC_INSTANCE( GraphicBufferMapper )
 
 GraphicBufferMapper::GraphicBufferMapper()
-  : mMapper(std::make_unique<const Gralloc2::Mapper>())
+    : mAllocMod(0)
 {
-    if (!mMapper->valid()) {
-        mLoader = std::make_unique<Gralloc1::Loader>();
-        mDevice = mLoader->getDevice();
+    hw_module_t const* module;
+    int err = hw_get_module(GRALLOC_HARDWARE_MODULE_ID, &module);
+    ALOGE_IF(err, "FATAL: can't find the %s module", GRALLOC_HARDWARE_MODULE_ID);
+    if (err == 0) {
+        mAllocMod = reinterpret_cast<gralloc_module_t const *>(module);
     }
 }
 
-status_t GraphicBufferMapper::importBuffer(buffer_handle_t rawHandle,
-        buffer_handle_t* outHandle)
-{
-    ATRACE_CALL();
-
-    Gralloc2::Error error;
-    if (mMapper->valid()) {
-        error = mMapper->importBuffer(hardware::hidl_handle(rawHandle),
-                outHandle);
-    } else {
-        error = Gralloc2::Error::UNSUPPORTED;
-    }
-
-    ALOGW_IF(error != Gralloc2::Error::NONE, "importBuffer(%p) failed: %d",
-            rawHandle, error);
-
-    return static_cast<status_t>(error);
-}
-
-status_t GraphicBufferMapper::importBuffer(const GraphicBuffer* buffer)
+status_t GraphicBufferMapper::importBuffer(buffer_handle_t handle)
 {
     ATRACE_CALL();
+    status_t err;
 
-    ANativeWindowBuffer* nativeBuffer = buffer->getNativeBuffer();
-    buffer_handle_t rawHandle = nativeBuffer->handle;
+    err = mAllocMod->registerBuffer(mAllocMod, handle);
 
-    gralloc1_error_t error;
-    if (mMapper->valid()) {
-        buffer_handle_t importedHandle;
-        error = static_cast<gralloc1_error_t>(mMapper->importBuffer(
-                    hardware::hidl_handle(rawHandle), &importedHandle));
-        if (error == GRALLOC1_ERROR_NONE) {
-            nativeBuffer->handle = importedHandle;
-        }
-    } else {
-        native_handle_t* clonedHandle = native_handle_clone(rawHandle);
-        if (clonedHandle) {
-            nativeBuffer->handle = clonedHandle;
-            error = mDevice->retain(buffer);
-            if (error != GRALLOC1_ERROR_NONE) {
-                nativeBuffer->handle = rawHandle;
-                native_handle_close(clonedHandle);
-                native_handle_delete(clonedHandle);
-            }
-        } else {
-            error = GRALLOC1_ERROR_NO_RESOURCES;
-        }
-    }
-
-    // the raw handle is owned by GraphicBuffer and is now replaced
-    if (error == GRALLOC1_ERROR_NONE) {
-        native_handle_close(rawHandle);
-        native_handle_delete(const_cast<native_handle_t*>(rawHandle));
-    }
-
-    ALOGW_IF(error != GRALLOC1_ERROR_NONE, "importBuffer(%p) failed: %d",
-            rawHandle, error);
-
-    return error;
+    ALOGW_IF(err, "registerBuffer(%p) failed %d (%s)",
+            handle, err, strerror(-err));
+    return err;
 }
 
+/*
 status_t GraphicBufferMapper::freeBuffer(buffer_handle_t handle)
 {
     ATRACE_CALL();
-
     gralloc1_error_t error;
     if (mMapper->valid()) {
         mMapper->freeBuffer(handle);
@@ -133,264 +91,138 @@ status_t GraphicBufferMapper::freeBuffer(buffer_handle_t handle)
 
     return error;
 }
-
-static inline gralloc1_rect_t asGralloc1Rect(const Rect& rect) {
-    gralloc1_rect_t outRect{};
-    outRect.left = rect.left;
-    outRect.top = rect.top;
-    outRect.width = rect.width();
-    outRect.height = rect.height();
-    return outRect;
+*/
+/*
+status_t GraphicBufferMapper::lockAsync(buffer_handle_t handle,
+        uint32_t usage, const Rect& bounds, void** vaddr, int fenceFd)
+{
+    return lockAsync(handle, usage, usage, bounds, vaddr, fenceFd);
 }
+*/
+status_t GraphicBufferMapper::unregisterBuffer(buffer_handle_t handle)
+{
+    ATRACE_CALL();
+    status_t err;
 
-static inline Gralloc2::IMapper::Rect asGralloc2Rect(const Rect& rect) {
-    Gralloc2::IMapper::Rect outRect{};
-    outRect.left = rect.left;
-    outRect.top = rect.top;
-    outRect.width = rect.width();
-    outRect.height = rect.height();
-    return outRect;
-}
+    err = mAllocMod->unregisterBuffer(mAllocMod, handle);
 
-status_t GraphicBufferMapper::lock(buffer_handle_t handle, uint32_t usage,
-        const Rect& bounds, void** vaddr)
-{
-    return lockAsync(handle, usage, bounds, vaddr, -1);
+    ALOGW_IF(err, "unregisterBuffer(%p) failed %d (%s)",
+            handle, err, strerror(-err));
+    return err;
 }
 
-status_t GraphicBufferMapper::lockYCbCr(buffer_handle_t handle, uint32_t usage,
-        const Rect& bounds, android_ycbcr *ycbcr)
+status_t GraphicBufferMapper::lock(buffer_handle_t handle,
+        uint32_t usage, const Rect& bounds, void** vaddr)
 {
-    return lockAsyncYCbCr(handle, usage, bounds, ycbcr, -1);
+    ATRACE_CALL();
+    status_t err;
+
+    err = mAllocMod->lock(mAllocMod, handle, static_cast<int>(usage),
+            bounds.left, bounds.top, bounds.width(), bounds.height(),
+            vaddr);
+
+    ALOGW_IF(err, "lock(...) failed %d (%s)", err, strerror(-err));
+    return err;
 }
 
-status_t GraphicBufferMapper::unlock(buffer_handle_t handle)
+status_t GraphicBufferMapper::lockYCbCr(buffer_handle_t handle,
+        uint32_t usage, const Rect& bounds, android_ycbcr *ycbcr)
 {
-    int32_t fenceFd = -1;
-    status_t error = unlockAsync(handle, &fenceFd);
-    if (error == NO_ERROR) {
-        sync_wait(fenceFd, -1);
-        close(fenceFd);
+    ATRACE_CALL();
+    status_t err;
+
+    if (mAllocMod->lock_ycbcr == NULL) {
+        return -EINVAL; // do not log failure
     }
-    return error;
+
+    err = mAllocMod->lock_ycbcr(mAllocMod, handle, static_cast<int>(usage),
+            bounds.left, bounds.top, bounds.width(), bounds.height(),
+            ycbcr);
+
+    ALOGW_IF(err, "lock(...) failed %d (%s)", err, strerror(-err));
+    return err;
 }
 
-status_t GraphicBufferMapper::lockAsync(buffer_handle_t handle,
-        uint32_t usage, const Rect& bounds, void** vaddr, int fenceFd)
+status_t GraphicBufferMapper::unlock(buffer_handle_t handle)
 {
-    return lockAsync(handle, usage, usage, bounds, vaddr, fenceFd);
+    ATRACE_CALL();
+    status_t err;
+
+    err = mAllocMod->unlock(mAllocMod, handle);
+
+    ALOGW_IF(err, "unlock(...) failed %d (%s)", err, strerror(-err));
+    return err;
 }
 
 status_t GraphicBufferMapper::lockAsync(buffer_handle_t handle,
-        uint64_t producerUsage, uint64_t consumerUsage, const Rect& bounds,
+        uint32_t usage, const Rect& bounds,
         void** vaddr, int fenceFd)
 {
     ATRACE_CALL();
+    status_t err;
 
-    gralloc1_error_t error;
-    if (mMapper->valid()) {
-        const uint64_t usage =
-            static_cast<uint64_t>(android_convertGralloc1To0Usage(
-                        producerUsage, consumerUsage));
-        error = static_cast<gralloc1_error_t>(mMapper->lock(handle,
-                usage, asGralloc2Rect(bounds), fenceFd, vaddr));
+    if (mAllocMod->common.module_api_version >= GRALLOC_MODULE_API_VERSION_0_3) {
+        err = mAllocMod->lockAsync(mAllocMod, handle, static_cast<int>(usage),
+                bounds.left, bounds.top, bounds.width(), bounds.height(),
+                vaddr, fenceFd);
     } else {
-        gralloc1_rect_t accessRegion = asGralloc1Rect(bounds);
-        sp<Fence> fence = new Fence(fenceFd);
-        error = mDevice->lock(handle,
-                static_cast<gralloc1_producer_usage_t>(producerUsage),
-                static_cast<gralloc1_consumer_usage_t>(consumerUsage),
-                &accessRegion, vaddr, fence);
-    }
-
-    ALOGW_IF(error != GRALLOC1_ERROR_NONE, "lock(%p, ...) failed: %d", handle,
-            error);
-
-    return error;
-}
-
-static inline bool isValidYCbCrPlane(const android_flex_plane_t& plane) {
-    if (plane.bits_per_component != 8) {
-        ALOGV("Invalid number of bits per component: %d",
-                plane.bits_per_component);
-        return false;
-    }
-    if (plane.bits_used != 8) {
-        ALOGV("Invalid number of bits used: %d", plane.bits_used);
-        return false;
-    }
-
-    bool hasValidIncrement = plane.h_increment == 1 ||
-            (plane.component != FLEX_COMPONENT_Y && plane.h_increment == 2);
-    hasValidIncrement = hasValidIncrement && plane.v_increment > 0;
-    if (!hasValidIncrement) {
-        ALOGV("Invalid increment: h %d v %d", plane.h_increment,
-                plane.v_increment);
-        return false;
+        if (fenceFd >= 0) {
+            sync_wait(fenceFd, -1);
+            close(fenceFd);
+        }
+        err = mAllocMod->lock(mAllocMod, handle, static_cast<int>(usage),
+                bounds.left, bounds.top, bounds.width(), bounds.height(),
+                vaddr);
     }
 
-    return true;
+    ALOGW_IF(err, "lockAsync(...) failed %d (%s)", err, strerror(-err));
+    return err;
 }
 
 status_t GraphicBufferMapper::lockAsyncYCbCr(buffer_handle_t handle,
         uint32_t usage, const Rect& bounds, android_ycbcr *ycbcr, int fenceFd)
 {
     ATRACE_CALL();
-
-    gralloc1_rect_t accessRegion = asGralloc1Rect(bounds);
-
-    std::vector<android_flex_plane_t> planes;
-    android_flex_layout_t flexLayout{};
-    gralloc1_error_t error;
-
-    if (mMapper->valid()) {
-        Gralloc2::YCbCrLayout layout;
-        error = static_cast<gralloc1_error_t>(mMapper->lock(handle, usage,
-                asGralloc2Rect(bounds), fenceFd, &layout));
-        if (error == GRALLOC1_ERROR_NONE) {
-            ycbcr->y = layout.y;
-            ycbcr->cb = layout.cb;
-            ycbcr->cr = layout.cr;
-            ycbcr->ystride = static_cast<size_t>(layout.yStride);
-            ycbcr->cstride = static_cast<size_t>(layout.cStride);
-            ycbcr->chroma_step = static_cast<size_t>(layout.chromaStep);
+    status_t err;
+
+    if (mAllocMod->common.module_api_version >= GRALLOC_MODULE_API_VERSION_0_3
+            && mAllocMod->lockAsync_ycbcr != NULL) {
+        err = mAllocMod->lockAsync_ycbcr(mAllocMod, handle,
+                static_cast<int>(usage), bounds.left, bounds.top,
+                bounds.width(), bounds.height(), ycbcr, fenceFd);
+    } else if (mAllocMod->lock_ycbcr != NULL) {
+        if (fenceFd >= 0) {
+            sync_wait(fenceFd, -1);
+            close(fenceFd);
         }
-
-        return error;
+        err = mAllocMod->lock_ycbcr(mAllocMod, handle, static_cast<int>(usage),
+                bounds.left, bounds.top, bounds.width(), bounds.height(),
+                ycbcr);
     } else {
-        sp<Fence> fence = new Fence(fenceFd);
-
-        if (mDevice->hasCapability(GRALLOC1_CAPABILITY_ON_ADAPTER)) {
-            error = mDevice->lockYCbCr(handle,
-                    static_cast<gralloc1_producer_usage_t>(usage),
-                    static_cast<gralloc1_consumer_usage_t>(usage),
-                    &accessRegion, ycbcr, fence);
-            ALOGW_IF(error != GRALLOC1_ERROR_NONE,
-                    "lockYCbCr(%p, ...) failed: %d", handle, error);
-            return error;
-        }
-
-        uint32_t numPlanes = 0;
-        error = mDevice->getNumFlexPlanes(handle, &numPlanes);
-
-        if (error != GRALLOC1_ERROR_NONE) {
-            ALOGV("Failed to retrieve number of flex planes: %d", error);
-            return error;
-        }
-        if (numPlanes < 3) {
-            ALOGV("Not enough planes for YCbCr (%u found)", numPlanes);
-            return GRALLOC1_ERROR_UNSUPPORTED;
-        }
-
-        planes.resize(numPlanes);
-        flexLayout.num_planes = numPlanes;
-        flexLayout.planes = planes.data();
-
-        error = mDevice->lockFlex(handle,
-                static_cast<gralloc1_producer_usage_t>(usage),
-                static_cast<gralloc1_consumer_usage_t>(usage),
-                &accessRegion, &flexLayout, fence);
-    }
-
-    if (error != GRALLOC1_ERROR_NONE) {
-        ALOGW("lockFlex(%p, ...) failed: %d", handle, error);
-        return error;
-    }
-    if (flexLayout.format != FLEX_FORMAT_YCbCr) {
-        ALOGV("Unable to convert flex-format buffer to YCbCr");
-        unlock(handle);
-        return GRALLOC1_ERROR_UNSUPPORTED;
-    }
-
-    // Find planes
-    auto yPlane = planes.cend();
-    auto cbPlane = planes.cend();
-    auto crPlane = planes.cend();
-    for (auto planeIter = planes.cbegin(); planeIter != planes.cend();
-            ++planeIter) {
-        if (planeIter->component == FLEX_COMPONENT_Y) {
-            yPlane = planeIter;
-        } else if (planeIter->component == FLEX_COMPONENT_Cb) {
-            cbPlane = planeIter;
-        } else if (planeIter->component == FLEX_COMPONENT_Cr) {
-            crPlane = planeIter;
+        if (fenceFd >= 0) {
+            close(fenceFd);
         }
-    }
-    if (yPlane == planes.cend()) {
-        ALOGV("Unable to find Y plane");
-        unlock(handle);
-        return GRALLOC1_ERROR_UNSUPPORTED;
-    }
-    if (cbPlane == planes.cend()) {
-        ALOGV("Unable to find Cb plane");
-        unlock(handle);
-        return GRALLOC1_ERROR_UNSUPPORTED;
-    }
-    if (crPlane == planes.cend()) {
-        ALOGV("Unable to find Cr plane");
-        unlock(handle);
-        return GRALLOC1_ERROR_UNSUPPORTED;
+        return -EINVAL; // do not log failure
     }
 
-    // Validate planes
-    if (!isValidYCbCrPlane(*yPlane)) {
-        ALOGV("Y plane is invalid");
-        unlock(handle);
-        return GRALLOC1_ERROR_UNSUPPORTED;
-    }
-    if (!isValidYCbCrPlane(*cbPlane)) {
-        ALOGV("Cb plane is invalid");
-        unlock(handle);
-        return GRALLOC1_ERROR_UNSUPPORTED;
-    }
-    if (!isValidYCbCrPlane(*crPlane)) {
-        ALOGV("Cr plane is invalid");
-        unlock(handle);
-        return GRALLOC1_ERROR_UNSUPPORTED;
-    }
-    if (cbPlane->v_increment != crPlane->v_increment) {
-        ALOGV("Cb and Cr planes have different step (%d vs. %d)",
-                cbPlane->v_increment, crPlane->v_increment);
-        unlock(handle);
-        return GRALLOC1_ERROR_UNSUPPORTED;
-    }
-    if (cbPlane->h_increment != crPlane->h_increment) {
-        ALOGV("Cb and Cr planes have different stride (%d vs. %d)",
-                cbPlane->h_increment, crPlane->h_increment);
-        unlock(handle);
-        return GRALLOC1_ERROR_UNSUPPORTED;
-    }
-
-    // Pack plane data into android_ycbcr struct
-    ycbcr->y = yPlane->top_left;
-    ycbcr->cb = cbPlane->top_left;
-    ycbcr->cr = crPlane->top_left;
-    ycbcr->ystride = static_cast<size_t>(yPlane->v_increment);
-    ycbcr->cstride = static_cast<size_t>(cbPlane->v_increment);
-    ycbcr->chroma_step = static_cast<size_t>(cbPlane->h_increment);
-
-    return error;
+    ALOGW_IF(err, "lock(...) failed %d (%s)", err, strerror(-err));
+    return err;
 }
 
 status_t GraphicBufferMapper::unlockAsync(buffer_handle_t handle, int *fenceFd)
 {
     ATRACE_CALL();
+    status_t err;
 
-    gralloc1_error_t error;
-    if (mMapper->valid()) {
-        *fenceFd = mMapper->unlock(handle);
-        error = GRALLOC1_ERROR_NONE;
+    if (mAllocMod->common.module_api_version >= GRALLOC_MODULE_API_VERSION_0_3) {
+        err = mAllocMod->unlockAsync(mAllocMod, handle, fenceFd);
     } else {
-        sp<Fence> fence = Fence::NO_FENCE;
-        error = mDevice->unlock(handle, &fence);
-        if (error != GRALLOC1_ERROR_NONE) {
-            ALOGE("unlock(%p) failed: %d", handle, error);
-            return error;
-        }
-
-        *fenceFd = fence->dup();
+        *fenceFd = -1;
+        err = mAllocMod->unlock(mAllocMod, handle);
     }
-    return error;
+
+    ALOGW_IF(err, "unlockAsync(...) failed %d (%s)", err, strerror(-err));
+    return err;
 }
 
 // ---------------------------------------------------------------------------
-- 
2.7.4

